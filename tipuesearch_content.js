var tipuesearch = {"pages":[{"title":"TofuCode404 Page not found","text":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTofuCode404 Page not found\n\n\n\n\n\n\n\n\nTofuCode\n\n\n\n\n\n\n\n\n\nInterview Questions\n\n\nRecent Questions\n\n\nTags\n\n\n\n\n\n\n\n 404 Page Note Found \n Try a search \n\n\n\n\n\n Eat Tofu and be true \nÂ© 2022 TofuCode.com\n\nBuilt with Pelican using Flex theme\n \n\n\n\n\n","tags":"","url":"https://tofucode.com/404.html"},{"title":"Hello there","text":"Quick Start For a table of all the questions: Interview Questions For a list of all questions tags: Tags Pages Python Basics","tags":"pages","url":"https://tofucode.com/pages/hello-there.html","loc":"https://tofucode.com/pages/hello-there.html"},{"title":"Interview Questions","text":"# Question Tags 0001 Two Sum hash-map 0002 Add Two Numbers linked-list, dummy-list-head 0005 Longest Palindromic Substring palindrome 0011 Container With Most Water two-pointers 0019 Remove Nth Node From End of List linked-list 0020 Valid Parentheses stack, parentheses 0021 Merge Two Sorted Lists linked-list 0026 Remove Duplicates from Sorted Array array-shift, two-pointers 0035 Search Insert Position binary-search 0049 Group Anagrams hash-map, anagram 0056 Merge Intervals interval-merge 0057 Insert Interval interval-merge 0061 Rotate List linked-list, list-to-ring 0070 Climbing Stairs dp 0074 Search a 2D Matrix binary-search 0094 Binary Tree Inorder Traversal binary-tree-traversal-inorder 0101 Symmetric Tree binary-tree-traversal 0104 Maximum Depth of Binary Tree binary-tree-traversal 0112 Path Sum binary-tree, recursion 0136 Single Number math 0138 Copy List with Random Pointer linked-list, dummy-list-head, recursion 0141 Linked List Cycle linked-list, fast-slow-pointer 0160 Intersection of Two Linked Lists linked-list 0167 Two Sum II - Input Array Is Sorted k-sum 0169 Majority Element counting, boyer-moore-voting-algorithm 0173 Binary Search Tree Iterator bst 0198 House Robber dp 0206 Reverse Linked List linked-list 0215 Kth Largest Element in an Array k-most-points, bubble-sort, quick-sort 0226 Invert Binary Tree binary-tree-manipulation 0234 Palindrome Linked List palindrome-center-expansion, fast-slow-pointer 0283 Move Zeroes array-shift, two-pointers 0289 Game of Life simulation, state-changes 0334 Increasing Triplet Subsequence array 0344 Reverse String string 0345 Reverse Vowels of a String two-pointers, string 0347 Top K Frequent Elements k-most-points, bucket-sort, hash-map 0406 Queue Reconstruction by Height sort 0413 Arithmetic Slices dp 0452 Minimum Number of Arrows to Burst Balloons interval-merge 0462 Minimum Moves to Equal Array Elements II math 0495 Teemo Attacking interval-merge, simulation 0509 Fibonacci Number recursion 0543 Diameter of Binary Tree binary-tree-traversal 0623 Add One Row to Tree binary-tree-manipulation, dfs 0647 Palindromic Substrings palindrome, string 0653 Two Sum IV - Input is a BST k-sum, dfs 0665 Non-decreasing Array monotonic-stack 0682 Baseball Game simulation 0700 Search in a Binary Search Tree bst 0740 Delete and Earn dp 0746 Min Cost Climbing Stairs dp 0799 Champagne Tower simulation 0881 Boats to Save People two-pointers, greedy 0897 Increasing Order Search Tree bst 0901 Online Stock Span monotonic-stack 0946 Validate Stack Sequences stack, simulation, greedy 0991 Broken Calculator reverse-thinking, puzzle 1094 Car Pooling interval-overlap 1249 Minimum Remove to Make Valid Parentheses stack, parentheses 1423 Maximum Points You Can Obtain from Cards sliding-window, array 1544 Make The String Great stack 1578 Minimum Time to Make Rope Colorful pointers, array 1647 Minimum Deletions to Make Character Frequencies Unique hash-map-count 1662 Check If Two String Arrays are Equivalent string 1710 Maximum Units on a Truck greedy 2095 Delete the Middle Node of a Linked List fast-slow-pointer 2131 Longest Palindrome by Concatenating Two Letter Words palindrome, string 2283 Check if Number Has Equal Digit Count and Digit Value hash-map-count 2284 Sender With Largest Word Count hash-map-count 2287 Rearrange Characters to Make Target String hash-map-count 2293 Min Max Game recursion, simulation 2294 Partition Array Such That Maximum Difference Is K array 2326 Spiral Matrix IV spiral-matrix 2404 Most Frequent Even Element hash-map-count 2413 Smallest Even Multiple math 2414 Length of the Longest Alphabetical Continuous Substring pointers, stack 2418 Sort the People hash-map 2423 Remove Letter To Equalize Frequency hash-map-count 2427 Number of Common Factors math 2432 The Employee That Worked on the Longest Task array 2433 Find The Original Array of Prefix Xor math 2437 Number of Valid Clock Times simulation 2441 Largest Positive Integer That Exists With Its Negative two-pointers 2446 Determine if Two Events Have Conflict interval 2451 Odd String Difference array, counting 2455 Average Value of Even Numbers That Are Divisible by Three math 2456 Most Popular Video Creator hash-map-count 2460 Apply Operations to an Array two-pointers 0606 Construct String from Binary Tree recursion, binary-tree","tags":"pages","url":"https://tofucode.com/pages/interview-questions.html","loc":"https://tofucode.com/pages/interview-questions.html"},{"title":"Python Basics","text":"Python Basics: Essentials, Data Structure, Collections Essentials Math import math # when you need a infinite max min value: note that this returns floats math . inf - math . inf # log math . log () # random integer N such that a <= N <= b. random . randint ( a , b ) # random item from a list random . choice ( l ) # randomly shuffle a list of nums in place random . shuffle ( nums ) Exceptions try : int ( i ) except Exception as e : print ( e ) loops # you can't modify the i variable inside a for loop. eg. won't work: for i in range ( 6 ): i -= 1 lambda x = lambda a , b , c : a + b + c print ( x ( 5 , 6 , 2 )) # sort a 2d list by increasing of first number, and then increasing of second. eg. [7,0],[4,4],[7,1] sorted_list = sorted ( original_list , key = lambda x : ( x [ 0 ], x [ 1 ])) # filter final_list = list ( filter ( lambda x : ( x % 2 != 0 ) , li )) # filters out to get all odd nums in li # map final_list = list ( map ( lambda x : x * 2 , li )) # applie *2 to all the elements of the list # reduce from functools import reduce sum = reduce (( lambda x , y : x + y ), li ) # sum of the list Class class Dog: all_tricks = [] # class instance shared by all dogs def __init__ ( self , name ): self . name = name self . tricks = [] # creates a new empty list for each dog def add_trick ( self , trick ): self . tricks . append ( trick ) Enum from enum import Enum class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 print ( Color . RED ) # Color.RED print ( Color . RED . name ) # RED print ( Color . RED . value ) # 1 Swapping a , b , c = d , e , f # note that order matters curr has to be last : # eg . when reversing a list in leetcode / leet_0206_reverse - linked - list . py # curr . next , prev , curr = prev , curr , curr . next Data structures Time: https://wiki.python.org/moin/TimeComplexity Char # char to ascii value ord ( c ) # ascii value to char chr ( x ) # ascii value offset from 'a' ord ( c ) - ord ( 'a' ) String Strings are immutable # initialize t = \"string\" t = 'string' # Operators t + t t * 3 # methods t . isdigit () # if made of digits only t . isalpha () # if made of alphabetics only t . isalnum () # if made of digits and alphabetics only t . isspace () # if made of spaces only t . isupper () # if made of upper case only t . upper () # returns an uppercased string t . islower () # if made of lower case only t . lower () # returns an lowercased string t . swapcase () # toggle between lower and upper case for each char # length t . count ( \"t\" ) # count the occurance of the character t len ( t ) #the length of the string # aligning t . center ( 20 ) # center the string in 20 chars t . ljust ( 20 ) # left align in 20 chars t . rjust ( 20 ) # right align in 20 chars # strip t . strirp () # strip trailing whitespaces t . lstrip () t . rstrip () # replace t . replace ( \"a\" , \"b\" ) # replace all occurances of a to b t . replace ( \"a\" , \"b\" , 2 ) # replace only the first 2 # split t . plit ( \"a\" ) # returns a list of strings split by the seperator # find t . startswith ( \"a\" ) # if the string starts with t . endswith ( \"a\" ) # is the string ends with t . find ( \"a\" ) # returns the index of the first occurance t . count ( 'a' ) # returns the occurance of this string # join ' ' . join ([ \"this\" , \"is\" , \"it\" ]) # reverse a string str [:: - 1 ] # [ <first element to include> : <first element to exclude> : <step> ] '' . join ( reversed ( str )) # casting a binary string to int int ( '110' , 2 ) # zfill with zeros txt = \"10\" x = txt . zfill ( 4 ) # 0010 # int to binary string - cut the first 2 chars bin ( 3 )[ 2 :] List same as arrays in java # initilizing l = [ 1 , 2 , 3 ] l = [ 1 ] * 4 # create a list of four 1s # insert and delete l . append ( 4 ) # appends one element to the end of the list l . extend ([ 4 , 5 ]) # This does not return another, but adds a list to l in place [Plus One](leetcode/leet_0066_plus-one.py) l += [ 4 , 5 ] # extends the list l . insert ( 2 , 99 ) # insert the element 99 before the given index 2 l . remove ( 99 ) # removes the first occorance of the given element l . pop ( 0 ) # pop the first element of the list l . pop () # pop the last element of the list l . clear () # clears the whole list # find l . index ( 1 ) # return the index of the given element: 0 l . count ( 2 ) # count the number of the element # sort l . sort () # in place sorting l . sort ( reverse = True ) # reverse sorting l . reverse () # reverse the list in place l [:: - 1 ] # reverse slice to return a reversed list sorted ( l , key = lambda x : len ( x )) # sort by length of string # which is: [ <first element to include> : <first element to exclude> : <step> ] # so is actually l[n-1:-1:-1] sorted ( l ) returns a sorted list of l # sublist l [ 1 :] # sublist from including index 1 to the end [2, 3] l [: 1 ] # sublist from the begining to and not include index 1 [1] l [ 1 : - 1 ] # sublist from including index 1 to the including 1 from the end [2] # list comprehension [ x * 2 for x in l ] # list processing [2, 4, 6] [ x for x in l if x < 2 ] # list filtering [1] # copy l2 = l [:] # shallow copy import copy l2 = copy . deepcopy ( l ) # deep copy l2 = l # reference only l2 [:] = l1 [:] # by value # insert into a sorted list import bisect bisext . insort ( l , 0 ) # inserts the element 0 into the list # enumerate both the index and the iterable for i , num in enumerate ( nums ): # zip : zips togeter multiple list by the element [ sum ( x ) for x in zip ( l1 , l2 )] # sums the 2 lists l1 and l2 element wise # initilizing a 2d list dp = [[ 0 ] * m for x in range ( n )] # dp = [[0] * m] * n # NOPE: This makes a list with five references to the same list Tuple Better way of mixing types in a collection Tuples are faster and consume less memory than list It is immutable Can be used as keys on a dictionary # initilize t = ( 1 , 2 , \"a\" ) t = ( 1 ,) # tuple with a single element t = ( 1 ,) * 3 # a tuple of five 1s # manipulation t += ( 9 ,) # append 9 to t t [ 2 :] # 2 index including to the end # indexing t . count ( 1 ) # count the number of occurances of 1 t . index ( 1 ) # find the first index of 1 # unpacking a , b , c = t # can also return a tuple in a method and unpack to variables # copy t2 = t # tuple is immutabe and this creates a copy # If a value within a tuple is mutable, then you can change it t = ( 1 , [ 9 , 8 ]) # you can change t[1][0] Dictionary Are not sorted Can not have duplicate elements # initilize d = { \"a\" : 1 , \"b\" : 2 } a = {} . fromkeys ([ \"a\" , \"b\" ]) # creat a empty dictionary of None with the keys # accessing d . keys () d . values () d . items () # a list of tuple (key, value) d [ \"a\" ] d . get ( \"a\" ) d . get ( \"a\" , - 1 ) # get -1 as a default value \"a\" in d # returns True or False # manipulation d . pop ( \"a\" ) # pop also removes the element d . clear () # clear the dictionary del d [ \"a\" ] # deletes just one element d2 . update ( d ) # add all key values pairs of d to d2 , duplicated keys will be overwritten # iterating for key , value in d . items (): # iterate all key value # counting items in list counts = dict () for i in items : counts [ i ] = counts . get ( i , 0 ) + 1 from collections import Counter counts = Counter ( items ) # sort by keys with highest first sorted_list = sorted ( freq . keys (), reverse = True ) Set unique elements ordering is arbitrary frozenset() is an immutable version of set # initilize a = set ([ 1 , 2 , 3 ]) b = set ([ 3 , 4 , 5 ]) # add a . add ( 4 ) # union a | b # union # intersection a & b a . intersection ( b ) # subset a < b a . issubset ( b ) a . issuperset ( b ) # difference a - b a . differnece ( b ) # symetric difference a &#94; b a . symmetric_difference ( b ) # copy c = a . copy () Heap priority queue # creating it import heapq l = [ 5 , 7 , 9 , 1 , 3 ] heapq . heapify ( l ) # min heap heapq . _heapify_max ( l ) # max heap # pushing heapq . heappush ( l , 4 ) # pop heapq . heappop ( l ) # min heap heapq . _heappop_max ( l ) # max heap # access heapq . nlargest ( 3 , l ) # returns a list of the 3 largest numbers heapq . nsmallest ( 3 , l ) # returns a list of the 3 smallest numbers # given counts which is a mup of num to counts: get the k most frequent numbers heapq . nlargest ( k , counts . keys (), key = counts . get ) PriorityQueue this is implemented as a wrapper around heap this is thread safe easier sytax from queue import PriorityQueue q = PriorityQueue () q . put ( 1 ) q . put ( 4 ) q . put ( 2 ) next_item = q . get () q . qsize () # get size # if want a reverse one as a max heap, use a tuple with the first one as the key: or use neg q . put (( - n , n )) # peek: q . queue [ 0 ] Collections Counter defaultdict OrderedDict deque ChainMap namedtuple() Counter give it a list and it will count occurances of each element and give dictionary of key => occurances from collections import Counter d = Counter ([ 1 , 1 , 1 , 2 ]) # Counter({1: 3, 2: 1}) d [ 1 ] # 3 # get the original list: list ( b . elements ()) # [1,1,1,2] # sort the counter dictionary and give a sorted list of key-value d . most_common () # [(1, 3), (2, 1)] # subtract another dictionary: it will match the keys and subtract the values d . subtract ( d2 ) defaultdict sets a default return value instead of throwing a KeyError when the key does not exist easier to use d.get('two', 0) instead from collections import defaultdict nums = defaultdict ( int ) nums [ 'two' ] = 2 print ( nums [ 'three' ]) # 0 OrderedDict a dictionary where keys maintain the order in which they are inserted from collections import OrderedDict d = OrderedDict () d [ 'a' ] = 1 d [ 'b' ] = 2 d [ 'c' ] = 3 print ( d ) # OrderedDict([('a', 1), ('b', 2), ('c', 3)]) deque list that append pop from either end in O(1) python list pop(0) would otherwise be O(n) from collections import deque list = [ \"a\" , \"b\" , \"c\" ] dq = deque ( list ) print ( dq ) # deque(['a', 'b', 'c']) # append dq . append ( \"d\" ) dq . appendleft ( \"z\" ) # pop dq . pop () dq . popleft () # other dq . clear () dq . count ( 'a' ) # counts the number of occurances: 1 ChainMap combine multiple dictionaries to be used as a single unit from collections import ChainMap dict1 = { 'a' : 1 , 'b' : 2 } dict2 = { 'c' : 3 , 'b' : 4 } chain_map = ChainMap ( dict1 , dict2 ) print ( chain_map . maps ) # [{'b': 2, 'a': 1}, {'c': 3, 'b': 4}] print ( list ( chain_map . keys ())) # ['b', 'a', 'c'] print ( list ( chain_map . values ())) # [2, 1, 3] chain_map . new_child ( dict3 ) # add another dictionary namedtuple() gives name to each object in tuple from collections import namedtuple Student = namedtuple ( 'Student' , 'fname, lname, age' ) s1 = Student ( 'John' , 'Clarke' , '13' ) print ( s1 . fname ) # Student(fname='John', lname='Clarke', age='13') s2 = Student . _make ([ 'Adam' , 'joe' , '18' ]) # creates new Student tuples s2 = s1 . _replace ( age = '14' ) # changes a field of the tuple: tuples are immutable so this returns new instance","tags":"pages","url":"https://tofucode.com/pages/python-basics.html","loc":"https://tofucode.com/pages/python-basics.html"},{"title":"Leetcode 0056. Merge Intervals","text":"Question Link : https://leetcode.com/problems/merge-intervals/ Difficulty: Medium Question Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1: Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2: Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints: 1 <= intervals.length <= 104 intervals[i].length == 2 0 <= starti <= endi <= 104 Solution Sort by start time and go through and merge. Code ''' Leetcode 0056. Merge Intervals Question Link : https://leetcode.com/problems/merge-intervals/ Solution Link : https://tofucode.com/posts/leetcode_0056_merge-intervals.html ''' class Solution : def merge ( self , intervals : List [ List [ int ]]) -> List [ List [ int ]]: ''' sorted by start time go through and check the last one if can merge: merge with the ending time being the latest else add it in to result [1,3],[2,6],[8,10],[15,18]] [1,3] [1,6] Time : O(n log n) Space: O(n) ''' intervals = sorted ( intervals , key = lambda x : x [ 0 ]) result = [] for interval in intervals : if not result : result . append ( interval ) continue last = result [ - 1 ] if last [ 1 ] >= interval [ 0 ]: result . pop () result . append ([ last [ 0 ], max ( last [ 1 ], interval [ 1 ])]) else : result . append ( interval ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0056_merge-intervals.html","loc":"https://tofucode.com/posts/leetcode_0056_merge-intervals.html"},{"title":"Leetcode 0057. Insert Interval","text":"Question Link : https://leetcode.com/problems/insert-interval/ Difficulty: Medium Question You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Constraints: 0 <= intervals.length <= 104 intervals[i].length == 2 0 <= starti <= endi <= 105 intervals is sorted by starti in ascending order. newInterval.length == 2 0 <= start <= end <= 105 Solution Same as the merge interval problem. Code ''' Leetcode 0057. Insert Interval Question Link : https://leetcode.com/problems/insert-interval/ Solution Link : https://tofucode.com/posts/leetcode_0057_insert-interval.html ''' class Solution : def insert ( self , intervals : List [ List [ int ]], newInterval : List [ int ]) -> List [ List [ int ]]: ''' add the new one in and merge intervals Time : O(n log n) Space: O(n) ''' intervals . append ( newInterval ) intervals = sorted ( intervals , key = lambda x : x [ 0 ]) result = [] for interval in intervals : if not result : result . append ( interval ) continue last = result [ - 1 ] if last [ 1 ] >= interval [ 0 ]: result . pop () result . append ([ last [ 0 ], max ( last [ 1 ], interval [ 1 ])]) else : result . append ( interval ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0057_insert-interval.html","loc":"https://tofucode.com/posts/leetcode_0057_insert-interval.html"},{"title":"Leetcode 0452. Minimum Number of Arrows to Burst Balloons","text":"Question Link : https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/ Difficulty: Medium Question There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons. Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path. Given the array points, return the minimum number of arrows that must be shot to burst all balloons. Example 1: Input: points = [[10,16],[2,8],[1,6],[7,12]] Output: 2 Explanation: The balloons can be burst by 2 arrows: - Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6]. - Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12]. Example 2: Input: points = [[1,2],[3,4],[5,6],[7,8]] Output: 4 Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows. Example 3: Input: points = [[1,2],[2,3],[3,4],[4,5]] Output: 2 Explanation: The balloons can be burst by 2 arrows: - Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3]. - Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5]. Constraints: 1 <= points.length <= 105 points[i].length == 2 -231 <= xstart < xend <= 231 - 1 Solution Merge intervals but only merge and store the overlap Code ''' Leetcode 0452. Minimum Number of Arrows to Burst Balloons Question Link : https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/ Solution Link : https://tofucode.com/posts/leetcode_0452_minimum-number-of-arrows-to-burst-balloons.html ''' class Solution : def findMinArrowShots ( self , points : List [ List [ int ]]) -> int : ''' Merge intervals but only merge and store the overlap [10,16],[2,8],[1,6],[7,12] sorted [1,6],[2,8],[7,12],[10,16] [1,6] [2,6] [2,6],[7,12] [2,6],[10, 12] [1,6],[2,8] and [7,12],[10,16] Time : O(n log n) Space: O(n) ''' intervals = sorted ( points , key = lambda x : x [ 0 ]) result = [] for interval in intervals : if not result : result . append ( interval ) continue last = result [ - 1 ] if last [ 1 ] >= interval [ 0 ]: result . pop () result . append ([ interval [ 0 ], min ( last [ 1 ], interval [ 1 ])]) else : result . append ( interval ) return len ( result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0452_minimum-number-of-arrows-to-burst-balloons.html","loc":"https://tofucode.com/posts/leetcode_0452_minimum-number-of-arrows-to-burst-balloons.html"},{"title":"Leetcode 0495. Teemo Attacking","text":"Question Link : https://leetcode.com/problems/teemo-attacking/ Difficulty: Easy Question Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack. You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration. Return the total number of seconds that Ashe is poisoned. Example 1: Input: timeSeries = [1,4], duration = 2 Output: 4 Explanation: Teemo's attacks on Ashe go as follows: - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2. - At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5. Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total. Example 2: Input: timeSeries = [1,2], duration = 2 Output: 3 Explanation: Teemo's attacks on Ashe go as follows: - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2. - At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3. Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total. Constraints: 1 <= timeSeries.length <= 104 0 <= timeSeries[i], duration <= 107 timeSeries is sorted in non-decreasing order. Solution Go through timeseries, and we keep adding the duration or the time to the next hit time Code ''' Leetcode 0495. Teemo Attacking Question Link : https://leetcode.com/problems/teemo-attacking/ Solution Link : https://tofucode.com/posts/leetcode_0495_teemo-attacking.html ''' class Solution : def findPoisonedDuration ( self , timeSeries : List [ int ], duration : int ) -> int : ''' Greedy: Use one pass, keep adding the duration or time to the next hit time, whichever is smaller Time : O(n) Space: O(n) ''' if not timeSeries or not duration : return 0 result = 0 for i in range ( len ( timeSeries ) - 1 ): result += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ) return result + duration","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0495_teemo-attacking.html","loc":"https://tofucode.com/posts/leetcode_0495_teemo-attacking.html"},{"title":"Leetcode 2446. Determine if Two Events Have Conflict","text":"Question Link : https://leetcode.com/problems/determine-if-two-events-have-conflict/ Difficulty: Easy Question You are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where: event1 = [startTime1, endTime1] and event2 = [startTime2, endTime2]. Event times are valid 24 hours format in the form of HH:MM. A conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events). Return true if there is a conflict between two events. Otherwise, return false. Example 1: Input: event1 = [\"01:15\",\"02:00\"], event2 = [\"02:00\",\"03:00\"] Output: true Explanation: The two events intersect at time 2:00. Example 2: Input: event1 = [\"01:00\",\"02:00\"], event2 = [\"01:20\",\"03:00\"] Output: true Explanation: The two events intersect starting from 01:20 to 02:00. Example 3: Input: event1 = [\"10:00\",\"11:00\"], event2 = [\"14:00\",\"15:00\"] Output: false Explanation: The two events do not intersect. Constraints: evnet1.length == event2.length == 2. event1[i].length == event2[i].length == 5 startTime1 <= endTime1 startTime2 <= endTime2 All the event times follow the HH:MM format. Solution Check event 1 end time and event 2 start time Code ''' Leetcode 2446. Determine if Two Events Have Conflict Question Link : https://leetcode.com/problems/determine-if-two-events-have-conflict/ Solution Link : https://tofucode.com/posts/leetcode_2446_determine-if-two-events-have-conflict.html ''' class Solution : def haveConflict ( self , event1 : List [ str ], event2 : List [ str ]) -> bool : ''' Sort first so the first event happens first Only need to check: event1 end time and event2 start time There are only 2 events Time : O(1) Space: O(1) ''' events = sorted ([ event1 , event2 ]) end_time = events [ 0 ][ 1 ] start_time = events [ 1 ][ 0 ] if end_time < start_time : return False return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2446_determine-if-two-events-have-conflict.html","loc":"https://tofucode.com/posts/leetcode_2446_determine-if-two-events-have-conflict.html"},{"title":"Leetcode 1094. Car Pooling","text":"Question Link : https://leetcode.com/problems/car-pooling/ Difficulty: Medium Question There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west). You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car's initial location. Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise. Example 1: Input: trips = [[2,1,5],[3,3,7]], capacity = 4 Output: false Example 2: Input: trips = [[2,1,5],[3,3,7]], capacity = 5 Output: true Constraints: 1 <= trips.length <= 1000 trips[i].length == 3 1 <= numPassengersi <= 100 0 <= fromi < toi <= 1000 1 <= capacity <= 105 Solution Use a dict or an array to track what the passenger count is at every point, and then whenever that exceeds the capacity, we return False. Code ''' Leetcode 1094. Car Pooling Question Link : https://leetcode.com/problems/car-pooling/ Solution Link : https://tofucode.com/posts/leetcode_1094_car-pooling.html ''' class Solution : def carPooling ( self , trips : List [ List [ int ]], capacity : int ) -> bool : ''' location -> count check through every locaiton needs to be < capacity [2,1,5], passengers, from, to 1 -> 2 2 -> 2 3 -> 2 + 3 4 -> 2 + 3 5 -> 2 + 3 Time : O(1000 * 1000) every trip goes full length Space: O(1000) ''' location = {} # location -> passenger count for trip in trips : p , start , end = trip for i in range ( start , end ): location [ i ] = location . get ( i , 0 ) + p if location [ i ] > capacity : return False return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1094_car-pooling.html","loc":"https://tofucode.com/posts/leetcode_1094_car-pooling.html"},{"title":"Leetcode 0026. Remove Duplicates from Sorted Array","text":"Question Link : https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Difficulty: Easy Question Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted. Example 1: Input: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4, , , , ,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: 1 <= nums.length <= 3 * 104 -100 <= nums[i] <= 100 nums is sorted in non-decreasing order. Solution Keep a pointer as an anchor and use a for loop to move the next none dup number forward. Code ''' Leetcode 0026. Remove Duplicates from Sorted Array Question Link : https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Solution Link : https://tofucode.com/posts/leetcode_0026_remove-duplicates-from-sorted-array.html ''' class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : ''' (move i to p+1) 0,0,1,1,1,2,2,3,3,4 p i 0,1,1,1,1,2,2,3,3,4 p i 0,1,2,1,1,2,2,3,3,4 p i 0,1,2,3,1,2,2,3,3,4 p i 0,1,2,3,4,2,2,3,3,4 p length is p + 1 p: index of last good position p+1: the index of the dup position Time : O(n) Space: O(1) ''' if not nums or len ( nums ) == 0 : return 0 p = 0 for i in range ( len ( nums )): if nums [ i ] != nums [ p ]: p += 1 nums [ p ] = nums [ i ] return p + 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0026_remove-duplicates-from-sorted-array.html","loc":"https://tofucode.com/posts/leetcode_0026_remove-duplicates-from-sorted-array.html"},{"title":"Leetcode 2418. Sort the People","text":"Question Link : https://leetcode.com/problems/sort-the-people/ Difficulty: Easy Question You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n. For each index i, names[i] and heights[i] denote the name and height of the ith person. Return names sorted in descending order by the people's heights. Example 1: Input: names = [\"Mary\",\"John\",\"Emma\"], heights = [180,165,170] Output: [\"Mary\",\"Emma\",\"John\"] Explanation: Mary is the tallest, followed by Emma and John. Example 2: Input: names = [\"Alice\",\"Bob\",\"Bob\"], heights = [155,185,150] Output: [\"Bob\",\"Alice\",\"Bob\"] Explanation: The first Bob is the tallest, followed by Alice and the second Bob. Constraints: n == names.length == heights.length 1 <= n <= 103 1 <= names[i].length <= 20 1 <= heights[i] <= 105 names[i] consists of lower and upper case English letters. All the values of heights are distinct. Solution Use a hashmap to map height to name, and sort by height. Code ''' Leetcode 2418. Sort the People Question Link : https://leetcode.com/problems/sort-the-people/ Solution Link : https://tofucode.com/posts/leetcode_2418_sort-the-people.html ''' class Solution : def sortPeople ( self , names : List [ str ], heights : List [ int ]) -> List [ str ]: ''' height is distinct people = {} # height -> name sort based on key, return name Time : O(n) Space: O(n) ''' people = {} # height -> name for i in range ( len ( names )): p = names [ i ] h = heights [ i ] people [ h ] = p sorted_people = sorted ( people . items (), key = lambda x : x [ 0 ], reverse = True ) return [ x [ 1 ] for x in sorted_people ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2418_sort-the-people.html","loc":"https://tofucode.com/posts/leetcode_2418_sort-the-people.html"},{"title":"Leetcode 2423. Remove Letter To Equalize Frequency","text":"Question Link : https://leetcode.com/problems/remove-letter-to-equalize-frequency/ Difficulty: Easy Question You are given a 0-indexed string word, consisting of lowercase English letters. You need to select one index and remove the letter at that index from word so that the frequency of every letter present in word is equal. Return true if it is possible to remove one letter so that the frequency of all letters in word are equal, and false otherwise. Note: The frequency of a letter x is the number of times it occurs in the string. You must remove exactly one letter and cannot chose to do nothing. Example 1: Input: word = \"abcc\" Output: true Explanation: Select index 3 and delete it: word becomes \"abc\" and each character has a frequency of 1. Example 2: Input: word = \"aazz\" Output: false Explanation: We must delete a character, so either the frequency of \"a\" is 1 and the frequency of \"z\" is 2, or vice versa. It is impossible to make all present letters have equal frequency. Constraints: 2 <= word.length <= 100 word consists of lowercase English letters only. Solution First return True we would need to remove a char and check if all ther others chars are of equal counts, to do this we can use a hash map as a counter, and then loop through all possible chars, remove, and check if the condition is satisfied. Code ''' Leetcode 2423. Remove Letter To Equalize Frequency Question Link : https://leetcode.com/problems/remove-letter-to-equalize-frequency/ Solution Link : https://tofucode.com/posts/leetcode_2423_remove-letter-to-equalize-frequency.html ''' class Solution : def equalFrequency ( self , word : str ) -> bool : ''' go through and map char -> count When removing any char, everything that's left has equal frequency/count So in next for loop, we go through all possible chars: 1. remove 2. check if all other counts are the same (return True if it is) 3. add back 1 if not and keep going counter # char -> count a: 1 b: 1 c: 2 Time : O(n) Space: O(n) ''' counter = {} # char -> count for c in word : counter [ c ] = counter . get ( c , 0 ) + 1 candidates = set ([ c for c in word ]) for c in candidates : counter [ c ] -= 1 if counter [ c ] == 0 : counter . pop ( c ) # check all other counts are the same with a set if len ( set ( counter . values ())) == 1 : return True counter [ c ] = counter . get ( c , 0 ) + 1 return False class SolutionNope1 : def equalFrequency ( self , word : str ) -> bool : ''' Here we try to approach this by getting all the different frequencies Assumed that the True answer has only 2 frequencies and calculate the relationship there. There too many edges cases to consider, and this doesn't work. eg should be True: \"abcc\" \"bac\" \"abbcc\" \"zz\" Time : O(n) Space: O(n) ''' counts = {} # char -> count for c in word : counts [ c ] = counts . get ( c , 0 ) + 1 freq = {} # count -> count of count for _char , count in counts . items (): freq [ count ] = freq . get ( count , 0 ) + 1 # case \"bac\", but not \"aazz\" if len ( freq ) == 1 : [ k ] = freq . keys () return k == 1 # otherwise should have 2 freqences if len ( freq ) != 2 : return False # get the 2 counts, with a as the bigger one [ a , b ] = freq . keys () a , b = max ( a , b ), min ( a , b ) return a - 1 == b and freq [ a ] == 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2423_remove-letter-to-equalize-frequency.html","loc":"https://tofucode.com/posts/leetcode_2423_remove-letter-to-equalize-frequency.html"},{"title":"Leetcode 2414. Length of the Longest Alphabetical Continuous Substring","text":"Question Link : https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/ Difficulty: Medium Question An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string \"abcdefghijklmnopqrstuvwxyz\". For example, \"abc\" is an alphabetical continuous string, while \"acb\" and \"za\" are not. Given a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring. Example 1: Input: s = \"abacaba\" Output: 2 Explanation: There are 4 distinct continuous substrings: \"a\", \"b\", \"c\" and \"ab\". \"ab\" is the longest continuous substring. Example 2: Input: s = \"abcde\" Output: 5 Explanation: \"abcde\" is the longest continuous substring. Constraints: 1 <= s.length <= 105 s consists of only English lowercase letters. Solution We can either use a pointer or a stack to track the current continuous string. Code ''' Leetcode 2414. Length of the Longest Alphabetical Continuous Substring Question Link : https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/ Solution Link : https://tofucode.com/posts/leetcode_2414_length-of-the-longest-alphabetical-continuous-substring.html ''' class Solution : def longestContinuousSubstring ( self , s : str ) -> int : ''' abacaba stack: check if last one is in order [ab] ab a c ab a loop, return max abacaba i s abacaba si Time : O(n) Space: O(1) ''' if not s : return 0 result = 1 # start with the first char start = 0 # the start of the string, s[start, i] is the current string for i in range ( 1 , len ( s )): c = s [ i ] last = s [ i - 1 ] if ( ord ( c ) - ord ( last )) == 1 : result = max ( result , i + 1 - start ) else : start = i return result class SolutionAlternative1 : def longestContinuousSubstring ( self , s : str ) -> int : ''' abacaba [ab] stack: store in order string. check if last one is in order Time : O(n) Space: O(n) ''' if not s : return 0 stack = [] result = 0 for c in s : if not stack : stack . append ( c ) else : last = stack [ - 1 ] if ord ( c ) - ord ( last ) != 1 : stack = [] stack . append ( c ) result = max ( result , len ( stack )) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2414_length-of-the-longest-alphabetical-continuous-substring.html","loc":"https://tofucode.com/posts/leetcode_2414_length-of-the-longest-alphabetical-continuous-substring.html"},{"title":"Leetcode 2404. Most Frequent Even Element","text":"Question Link : https://leetcode.com/problems/most-frequent-even-element/ Difficulty: Easy Question Given an integer array nums, return the most frequent even element. If there is a tie, return the smallest one. If there is no such element, return -1. Example 1: Input: nums = [0,1,2,2,4,4,1] Output: 2 Explanation: The even elements are 0, 2, and 4. Of these, 2 and 4 appear the most. We return the smallest one, which is 2. Example 2: Input: nums = [4,4,4,9,2,4] Output: 4 Explanation: 4 is the even element appears the most. Example 3: Input: nums = [29,47,21,41,13,37,25,7] Output: -1 Explanation: There is no even element. Constraints: 1 <= nums.length <= 2000 0 <= nums[i] <= 105 Solution Count and a sort. Code ''' Leetcode 2404. Most Frequent Even Element Question Link : https://leetcode.com/problems/most-frequent-even-element/ Solution Link : https://tofucode.com/posts/leetcode_2404_most-frequent-even-element.html ''' class Solution : def mostFrequentEven ( self , nums : List [ int ]) -> int : ''' dict of even num -> count sort by count, return smallest num Time : O(n) Space: O(n) ''' counts = {} # even num -> count for num in nums : if num % 2 == 0 : counts [ num ] = counts . get ( num , 0 ) + 1 if not counts : return - 1 # most count, smallest num: sort by reversed count, than the number itself sorted_nums = sorted ( counts . items (), key = lambda x : ( - x [ 1 ], x [ 0 ])) return sorted_nums [ 0 ][ 0 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2404_most-frequent-even-element.html","loc":"https://tofucode.com/posts/leetcode_2404_most-frequent-even-element.html"},{"title":"Leetcode 2413. Smallest Even Multiple","text":"Question Link : https://leetcode.com/problems/smallest-even-multiple/ Difficulty: Easy Question Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n. Example 1: Input: n = 5 Output: 10 Explanation: The smallest multiple of both 5 and 2 is 10. Example 2: Input: n = 6 Output: 6 Explanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself. Constraints: 1 <= n <= 150 Solution Think about the differnt cases, and find the common pattern for n. Code ''' Leetcode 2413. Smallest Even Multiple Question Link : https://leetcode.com/problems/smallest-even-multiple/ Solution Link : https://tofucode.com/posts/leetcode_2413_smallest-even-multiple.html ''' class Solution : def smallestEvenMultiple ( self , n : int ) -> int : ''' 1,2 : return 2 n % 2 == 0 return n else return n * 2 - always even Time : O(1) Space: O(1) ''' if n <= 2 : return 2 if n % 2 == 0 : return n return n * 2","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2413_smallest-even-multiple.html","loc":"https://tofucode.com/posts/leetcode_2413_smallest-even-multiple.html"},{"title":"Leetcode 0901. Online Stock Span","text":"Question Link : https://leetcode.com/problems/online-stock-span/ Difficulty: Medium Question Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day. The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100,80,60,70,60,75,85], then the stock spans would be [1,1,1,2,1,4,6]. Implement the StockSpanner class: StockSpanner() Initializes the object of the class. int next(int price) Returns the span of the stock's price given that today's price is price. Example 1: Input [\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"] [[], [100], [80], [60], [70], [60], [75], [85]] Output [null, 1, 1, 1, 2, 1, 4, 6] Explanation StockSpanner stockSpanner = new StockSpanner(); stockSpanner.next(100); // return 1 stockSpanner.next(80); // return 1 stockSpanner.next(60); // return 1 stockSpanner.next(70); // return 2 stockSpanner.next(60); // return 1 stockSpanner.next(75); // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price. stockSpanner.next(85); // return 6 Constraints: 1 <= price <= 105 At most 104 calls will be made to next. Solution Since we need to keep checking back, we can use a stack, we also need to store how many smaller prices before are seen at each price, so we can use a tuple. Here we have a monotonic stack that is decreasing in price, and with each price, we store the span. Code ''' Leetcode 0901. Online Stock Span Question Link : https://leetcode.com/problems/online-stock-span/ Solution Link : https://tofucode.com/posts/leetcode_0901_online-stock-span.html ''' class StockSpanner : ''' 1: 100 1: 100 80 1: 100 80 60 2: 100 80 60 70 (60 and 70) 1: 100 80 60 70 60 4: 100 80 60 70 60 75 (60 70 60 75) stack keep checking back [(price, span count)] remove all that are smaller than the current price and add +1 monotonic decreasing stack 1: (100, 1) 1: (100, 1), (80, 1) 1: (100, 1), (80, 1), (60, 1) 2: (100, 1), (80, 1), (70, 2) 1: (100, 1), (80, 1), (70, 2), (60, 1) 4: (100, 1), (80, 1), (75, 4) 4 is: (2 + 1 + 1) Time : O(1) Space: O(n) ''' def __init__ ( self ): self . stack = [] def next ( self , price : int ) -> int : count = 1 while self . stack and self . stack [ - 1 ][ 0 ] <= price : count += self . stack . pop ()[ 1 ] self . stack . append (( price , count )) return count # Your StockSpanner object will be instantiated and called as such: # obj = StockSpanner() # param_1 = obj.next(price)","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0901_online-stock-span.html","loc":"https://tofucode.com/posts/leetcode_0901_online-stock-span.html"},{"title":"Leetcode 2427. Number of Common Factors","text":"Question Link : https://leetcode.com/problems/number-of-common-factors/ Difficulty: Easy Question Given two positive integers a and b, return the number of common factors of a and b. An integer x is a common factor of a and b if x divides both a and b. Example 1: Input: a = 12, b = 6 Output: 4 Explanation: The common factors of 12 and 6 are 1, 2, 3, 6. Example 2: Input: a = 25, b = 30 Output: 2 Explanation: The common factors of 25 and 30 are 1, 5. Constraints: 1 <= a, b <= 1000 Solution Check from 1 to the smallest number. Code ''' Leetcode 2427. Number of Common Factors Question Link : https://leetcode.com/problems/number-of-common-factors/ Solution Link : https://tofucode.com/posts/leetcode_2427_number-of-common-factors.html ''' class Solution : def commonFactors ( self , a : int , b : int ) -> int : ''' for loop 1 to min(a,b) and count Time : O(1) Space: O(1) ''' result = 0 for i in range ( 1 , min ( a , b ) + 1 ): if a % i == 0 and b % i == 0 : result += 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2427_number-of-common-factors.html","loc":"https://tofucode.com/posts/leetcode_2427_number-of-common-factors.html"},{"title":"Leetcode 2437. Number of Valid Clock Times","text":"Question Link : https://leetcode.com/problems/number-of-valid-clock-times/ Difficulty: Easy Question You are given a string of length 5 called time, representing the current time on a digital clock in the format \"hh:mm\". The earliest possible time is \"00:00\" and the latest possible time is \"23:59\". In the string time, the digits represented by the ? symbol are unknown, and must be replaced with a digit from 0 to 9. Return an integer answer, the number of valid clock times that can be created by replacing every ? with a digit from 0 to 9. Example 1: Input: time = \"?5:00\" Output: 2 Explanation: We can replace the ? with either a 0 or 1, producing \"05:00\" or \"15:00\". Note that we cannot replace it with a 2, since the time \"25:00\" is invalid. In total, we have two choices. Example 2: Input: time = \"0?:0?\" Output: 100 Explanation: Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices. Example 3: Input: time = \"??:??\" Output: 1440 Explanation: There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 * 60 = 1440 choices. Constraints: time is a valid string of length 5 in the format \"hh:mm\". \"00\" <= hh <= \"23\" \"00\" <= mm <= \"59\" Some of the digits might be replaced with '?' and need to be replaced with digits from 0 to 9. Solution Each digit can be a question mark, but each digit has different restriction, we can analyze the different cases, and the result would be the mutiplicqtion of all ?s. Code ''' Leetcode 2437. Number of Valid Clock Times Question Link : https://leetcode.com/problems/number-of-valid-clock-times/ Solution Link : https://tofucode.com/posts/leetcode_2437_number-of-valid-clock-times.html ''' class Solution : def countTime ( self , time : str ) -> int : ''' ab:cd Restriction on a b, how many valid number each place can have 1. a is 0 or 1, b can be all 10 numbers a: 2 (0 1) b: 10 (0-9) c: 6 (0-5) d: 10 (0-9) 2. a is 2, b has to be < 4 a: is 2 b: 4 (0 1 2 3) cd same Time : O(1) Space: O(1) ''' result = 1 a , b , c , d = time [ 0 ], time [ 1 ], time [ 3 ], time [ 4 ] if a == '?' and b == '?' : result *= 24 elif a == '?' and b != '?' : if int ( b ) >= 4 : result *= 2 else : result *= 3 elif a != '?' and b == '?' : if int ( a ) == 2 : result *= 4 else : result *= 10 if c == '?' : result *= 6 if d == '?' : result *= 10 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2437_number-of-valid-clock-times.html","loc":"https://tofucode.com/posts/leetcode_2437_number-of-valid-clock-times.html"},{"title":"Leetcode 2460. Apply Operations to an Array","text":"Question Link : https://leetcode.com/problems/apply-operations-to-an-array/ Difficulty: Easy Question You are given a 0-indexed array nums of size n consisting of non-negative integers. You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums: If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation. After performing all the operations, shift all the 0's to the end of the array. For example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0]. Return the resulting array. Note that the operations are applied sequentially, not all at once. Example 1: Input: nums = [1,2,2,1,1,0] Output: [1,4,2,0,0,0] Explanation: We do the following operations: - i = 0: nums[0] and nums[1] are not equal, so we skip this operation. - i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0]. - i = 2: nums[2] and nums[3] are not equal, so we skip this operation. - i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0]. - i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0]. After that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0]. Example 2: Input: nums = [0,1] Output: [1,0] Explanation: No operation can be applied, we just shift the 0 to the end. Constraints: 2 <= nums.length <= 2000 0 <= nums[i] <= 1000 Solution First go through the array and apply the operation. Second use two pointers with an anchor p to shift the zeros. Code ''' Leetcode 2460. Apply Operations to an Array Question Link : https://leetcode.com/problems/apply-operations-to-an-array/ Solution Link : https://tofucode.com/posts/leetcode_2460_apply-operations-to-an-array.html ''' class Solution : def applyOperations ( self , nums : List [ int ]) -> List [ int ]: ''' 1,2,2,1,1,0 1,4,0,1,1,0 1,4,0,2,0,0 1,4,2,0,0,0 2 loops, in place Time : O(n) Space: O(1) ''' for i in range ( len ( nums ) - 1 ): a = nums [ i ] b = nums [ i + 1 ] if a == b : nums [ i ] *= 2 nums [ i + 1 ] = 0 p = 0 for i in range ( len ( nums )): if nums [ i ] != 0 : nums [ i ], nums [ p ] = nums [ p ], nums [ i ] p += 1 return nums","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2460_apply-operations-to-an-array.html","loc":"https://tofucode.com/posts/leetcode_2460_apply-operations-to-an-array.html"},{"title":"Leetcode 1544. Make The String Great","text":"Question Link : https://leetcode.com/problems/make-the-string-great/ Difficulty: Easy Question Given a string s of lower and upper case English letters. A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where: 0 <= i <= s.length - 2 s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa. To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good. Return the string after making it good. The answer is guaranteed to be unique under the given constraints. Notice that an empty string is also good. Example 1: Input: s = \"leEeetcode\" Output: \"leetcode\" Explanation: In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\". Example 2: Input: s = \"abBAcC\" Output: \"\" Explanation: We have many possible scenarios, and all lead to the same answer. For example: \"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\" \"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\" Example 3: Input: s = \"s\" Output: \"s\" Constraints: 1 <= s.length <= 100 s contains only lower and upper case English letters. Solution Use a stack so we can check back and deviced if a pair needs to be removed. Code ''' Leetcode 1544. Make The String Great Question Link : https://leetcode.com/problems/make-the-string-great/ Solution Link : https://tofucode.com/posts/leetcode_1544_make-the-string-great.html ''' class Solution : def makeGood ( self , s : str ) -> str : ''' abBA if we remove bB, it will leave aA stack like closing prethesis remove when bB, aA, return what's left for abBAcC: a ab a _ c _ Time : O(n) Sapce: O(n) ''' stack = [] for c in s : if not stack or not self . sameCharDiffCase ( stack [ - 1 ], c ): stack . append ( c ) else : stack . pop () return '' . join ( stack ) def sameCharDiffCase ( self , a , b ): return a . isupper () and a . lower () == b or b . isupper () and b . lower () == a","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1544_make-the-string-great.html","loc":"https://tofucode.com/posts/leetcode_1544_make-the-string-great.html"},{"title":"Leetcode 2441. Largest Positive Integer That Exists With Its Negative","text":"Question Link : https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/ Difficulty: Easy Question Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array. Return the positive integer k. If there is no such integer, return -1. Example 1: Input: nums = [-1,2,-3,3] Output: 3 Explanation: 3 is the only valid k we can find in the array. Example 2: Input: nums = [-1,10,6,7,-7,1] Output: 7 Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value. Example 3: Input: nums = [-10,8,6,7,-2,-3] Output: -1 Explanation: There is no a single valid k, we return -1. Constraints: 1 <= nums.length <= 1000 -1000 <= nums[i] <= 1000 nums[i] != 0 Solution Can use two pointers with a sort or go though it and check the curernt number with a set. Code ''' Leetcode 2441. Largest Positive Integer That Exists With Its Negative Question Link : https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/ Solution Link : https://tofucode.com/posts/leetcode_2441_largest-positive-integer-that-exists-with-its-negative.html ''' class Solution : def findMaxK ( self , nums : List [ int ]) -> int : ''' set of all numbers Go through nums and mark the biggest that have -k in there as well Time : O(n) Space: O(n) ''' result = - 1 all_nums = set ( nums ) for num in nums : if num > result and - num in all_nums : result = num return result class SolutionAlternative1 : def findMaxK ( self , nums : List [ int ]) -> int : ''' set of all numbers Go through nums and mark the biggest that have -k in there as well Time : O(n log n) Space: O(1) ''' l = 0 r = len ( nums ) - 1 all_nums = sorted ( nums ) while l < r : s = all_nums [ l ] + all_nums [ r ] if s == 0 : return all_nums [ r ] elif s < 0 : l += 1 else : r -= 1 return - 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2441_largest-positive-integer-that-exists-with-its-negative.html","loc":"https://tofucode.com/posts/leetcode_2441_largest-positive-integer-that-exists-with-its-negative.html"},{"title":"Leetcode 2451. Odd String Difference","text":"Question Link : https://leetcode.com/problems/odd-string-difference/ Difficulty: Easy Question You are given an array of equal-length strings words. Assume that the length of each string is n. Each string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z' is 25. For example, for the string \"acb\", the difference integer array is [2 - 0, 1 - 2] = [2, -1]. All the strings in words have the same difference integer array, except one. You should find that string. Return the string in words that has different difference integer array. Example 1: Input: words = [\"adc\",\"wzy\",\"abc\"] Output: \"abc\" Explanation: - The difference integer array of \"adc\" is [3 - 0, 2 - 3] = [3, -1]. - The difference integer array of \"wzy\" is [25 - 22, 24 - 25]= [3, -1]. - The difference integer array of \"abc\" is [1 - 0, 2 - 1] = [1, 1]. The odd array out is [1, 1], so we return the corresponding string, \"abc\". Example 2: Input: words = [\"aaa\",\"bob\",\"ccc\",\"ddd\"] Output: \"bob\" Explanation: All the integer arrays are [0, 0] except for \"bob\", which corresponds to [13, -13]. Constraints: 3 <= words.length <= 100 n == words[i].length 2 <= n <= 20 words[i] consists of lowercase English letters. Solution Since there is only one that is different, we can set the first one as the target, and compare all others against the first one. Code ''' Leetcode 2451. Odd String Difference Question Link : https://leetcode.com/problems/odd-string-difference/ Solution Link : https://tofucode.com/posts/leetcode_2451_odd-string-difference.html ''' class Solution : A_ORD = ord ( 'a' ) def oddString ( self , words : List [ str ]) -> str : ''' Mark the first one as target, if we get a different one, set as suspect if have suspect: if current == suspect: return target else current == target: return suspect else: set suspect Time : O(n) Space: O(1) ''' t_word , target = self . getDiffArray ( words [ 0 ]) s_word = suspect = None for i in range ( 1 , len ( words )): word = words [ i ] _w , current = self . getDiffArray ( word ) if suspect : if current == suspect : return t_word if current == target : return s_word elif current != target : s_word , suspect = word , current return s_word def getDiffArray ( self , word ): ''' given a string, return the diff array ''' result = [] for i in range ( 1 , len ( word )): a = word [ i - 1 ] b = word [ i ] result . append (( ord ( b ) - Solution . A_ORD ) - ( ord ( a ) - Solution . A_ORD )) return ( word , result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2451_odd-string-difference.html","loc":"https://tofucode.com/posts/leetcode_2451_odd-string-difference.html"},{"title":"Leetcode 2456. Most Popular Video Creator","text":"Question Link : https://leetcode.com/problems/most-popular-video-creator/ Difficulty: Medium Question You are given two string arrays creators and ids, and an integer array views, all of length n. The ith video on a platform was created by creator[i], has an id of ids[i], and has views[i] views. The popularity of a creator is the sum of the number of views on all of the creator's videos. Find the creator with the highest popularity and the id of their most viewed video. If multiple creators have the highest popularity, find all of them. If multiple videos have the highest view count for a creator, find the lexicographically smallest id. Return a 2D array of strings answer where answer[i] = [creatori, idi] means that creatori has the highest popularity and idi is the id of their most popular video. The answer can be returned in any order. Example 1: Input: creators = [\"alice\",\"bob\",\"alice\",\"chris\"], ids = [\"one\",\"two\",\"three\",\"four\"], views = [5,10,5,4] Output: [[\"alice\",\"one\"],[\"bob\",\"two\"]] Explanation: The popularity of alice is 5 + 5 = 10. The popularity of bob is 10. The popularity of chris is 4. alice and bob are the most popular creators. For bob, the video with the highest view count is \"two\". For alice, the videos with the highest view count are \"one\" and \"three\". Since \"one\" is lexicographically smaller than \"three\", it is included in the answer. Example 2: Input: creators = [\"alice\",\"alice\",\"alice\"], ids = [\"a\",\"b\",\"c\"], views = [1,2,2] Output: [[\"alice\",\"b\"]] Explanation: The videos with id \"b\" and \"c\" have the highest view count. Since \"b\" is lexicographically smaller than \"c\", it is included in the answer. Constraints: n == creators.length == ids.length == views.length 1 <= n <= 105 1 <= creators[i].length, ids[i].length <= 5 creators[i] and ids[i] consist only of lowercase English letters. 0 <= views[i] <= 105 Solution We need to store all of the given info: name, id, view number, as well as the total popularity. We can do this with hashmap. Also much clearer with a new class. Code ''' Leetcode 2456. Most Popular Video Creator Question Link : https://leetcode.com/problems/most-popular-video-creator/ Solution Link : https://tofucode.com/posts/leetcode_2456_most-popular-video-creator.html ''' class Solution : def mostPopularCreator ( self , creators : List [ str ], ids : List [ str ], views : List [ int ]) -> List [ List [ str ]]: ''' popularity = sum (all views on all video) 1 loop: person -> views 2 loop: need sum of views - find top 3 loop: get all people with top reviews. sort based on views people = {} # name -> (popularity, [(sorted view, index)]) Time : O(n) Space: O(n) ''' people = {} # name -> (popularity, [(sorted view, index)]) for i in range ( len ( creators )): name = creators [ i ] vid = ids [ i ] v = views [ i ] people [ name ] = people . get ( name , []) + [( v , vid )] for name , view_list in people . items (): popularity = sum ([ x [ 0 ] for x in view_list ]) people [ name ] = ( popularity , people [ name ]) # sort by popularity, x[1] is the value, x[1][0] is popularity sorted_people = sorted ( people . items (), key = lambda x : x [ 1 ][ 0 ], reverse = True ) max_pop = sorted_people [ 0 ][ 1 ][ 0 ] # for only the top popularity, write the name and id to answer result = [] for person in sorted_people : if person [ 1 ][ 0 ] != max_pop : break view_list = person [ 1 ][ 1 ] # sort by view, negative so views are big to same, and then ids are lexicographical order view_list = sorted ( view_list , key = lambda x : ( - x [ 0 ], x [ 1 ])) result . append ([ person [ 0 ], view_list [ 0 ][ 1 ]]) return result class Creator : def __init__ ( self , name ): self . name = name self . view_list = [] # (view, id) self . popularity = None def addVideo ( self , view , vid ): self . view_list . append (( view , vid )) def getPopularity ( self ): if self . popularity : return self . popularity self . popularity = sum ([ x [ 0 ] for x in self . view_list ]) return self . popularity def getTopVideoWithName ( self ): # sort by view, negative so views are big to small, and then ids are lexicographical order view_list = sorted ( self . view_list , key = lambda x : ( - x [ 0 ], x [ 1 ])) return [ self . name , view_list [ 0 ][ 1 ]] class SolutionImproved1 : def mostPopularCreator ( self , creators : List [ str ], ids : List [ str ], views : List [ int ]) -> List [ List [ str ]]: ''' popularity = sum (all views on all video) Creator: name view_list popularity Time : O(n) Space: O(n) ''' people = {} # name -> creator for i in range ( len ( creators )): name = creators [ i ] vid = ids [ i ] v = views [ i ] person = people . get ( name , Creator ( name )) person . addVideo ( v , vid ) people [ name ] = person # sort by popularity, sorted_people = sorted ( people . items (), key = lambda x : x [ 1 ] . getPopularity (), reverse = True ) max_pop = sorted_people [ 0 ][ 1 ] . getPopularity () # for only the top popularity, write the name and id to answer result = [] for person in sorted_people : if person [ 1 ] . getPopularity () != max_pop : break result . append ( person [ 1 ] . getTopVideoWithName ()) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2456_most-popular-video-creator.html","loc":"https://tofucode.com/posts/leetcode_2456_most-popular-video-creator.html"},{"title":"Leetcode 2455. Average Value of Even Numbers That Are Divisible by Three","text":"Question Link : https://leetcode.com/problems/average-value-of-even-numbers-that-are-divisible-by-three/ Difficulty: Easy Question Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3. Note that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer. Example 1: Input: nums = [1,3,6,10,12,15] Output: 9 Explanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9. Example 2: Input: nums = [1,2,4,7,10] Output: 0 Explanation: There is no single number that satisfies the requirement, so return 0. Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 1000 Solution Go through nums and get the total and the count. Code ''' Leetcode 2455. Average Value of Even Numbers That Are Divisible by Three Question Link : https://leetcode.com/problems/average-value-of-even-numbers-that-are-divisible-by-three/ Solution Link : https://tofucode.com/posts/leetcode_2455_average-value-of-even-numbers-that-are-divisible-by-three.html ''' class Solution : def averageValue ( self , nums : List [ int ]) -> int : ''' even is / 2 / 3 so / 6 Time : O(n) Space: O(1) ''' total = 0 count = 0 for num in nums : if num % 6 == 0 : total += num count += 1 return total // count if count else 0","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2455_average-value-of-even-numbers-that-are-divisible-by-three.html","loc":"https://tofucode.com/posts/leetcode_2455_average-value-of-even-numbers-that-are-divisible-by-three.html"},{"title":"Leetcode 0283. Move Zeroes","text":"Question Link : https://leetcode.com/problems/move-zeroes/ Difficulty: Easy Question Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Example 1: Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2: Input: nums = [0] Output: [0] Constraints: 1 <= nums.length <= 104 -231 <= nums[i] <= 231 - 1 Follow up: Could you minimize the total number of operations done? Solution Use a pointer as anchor for the left most zero, and use another pointer to iterate Code ''' Leetcode 0283. Move Zeroes Question Link : https://leetcode.com/problems/move-zeroes/ Solution Link : https://tofucode.com/posts/leetcode_0283_move-zeroes.html ''' class Solution : def moveZeroes ( self , nums : List [ int ]) -> None : \"\"\" Do not return anything, modify nums in-place instead. \"\"\" ''' p: gets anchored as the left most 0 so when we get to a non zero, we can swap p and i start p at 0 is fine cause the first one if not zero will not do anything and just p +=1 i p 0 0 [2, 1, 0, 3, 12] swaped 1 1 [2, 1, 0, 3, 12] swaped 2 2 [2, 1, 0, 3, 12] nothing, i is at 0 3 2 [2, 1, 3, 0, 12] swaped, p + 1 to 3 4 3 [2, 1, 3, 12, 0] swaped Time : O(n) Space: O(1) ''' p = 0 # last zero position for i in range ( len ( nums )): if nums [ i ] != 0 : nums [ i ], nums [ p ] = nums [ p ], nums [ i ] p += 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0283_move-zeroes.html","loc":"https://tofucode.com/posts/leetcode_0283_move-zeroes.html"},{"title":"Leetcode 0345. Reverse Vowels of a String","text":"Question Link : https://leetcode.com/problems/reverse-vowels-of-a-string/ Difficulty: Easy Question Given a string s, reverse only all the vowels in the string and return it. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once. Example 1: Input: s = \"hello\" Output: \"holle\" Example 2: Input: s = \"leetcode\" Output: \"leotcede\" Constraints: 1 <= s.length <= 3 * 105 s consist of printable ASCII characters. Solution Use 2 pointers to go outside in and swap when needed. Code ''' Leetcode 0345. Reverse Vowels of a String Question Link : https://leetcode.com/problems/reverse-vowels-of-a-string/ Solution Link : https://tofucode.com/posts/leetcode_0345_reverse-vowels-of-a-string.html ''' class Solution : def reverseVowels ( self , s : str ) -> str : ''' hello l r l r - swap Time : O(n) Space: O(n) ''' vowels = set ([ c for c in 'aeiouAEIOU' ]) result = [ c for c in s ] l = 0 r = len ( s ) - 1 while l < r : while l < r and not result [ l ] in vowels : l += 1 while l < r and not result [ r ] in vowels : r -= 1 result [ l ], result [ r ] = result [ r ], result [ l ] l += 1 r -= 1 return '' . join ( result ) class SolutionAlternative1 : def reverseVowels ( self , s : str ) -> str : ''' Go through and get the vowels, and mark the positions with None, Use another loop to add the vowels back in in reverse order Time : O(n) Space: O(n) ''' if not s : return s result = [] vowels = set ([ c for c in 'aeiouAEIOU' ]) v = '' for c in s : if c in vowels : v += c result . append ( None ) else : result . append ( c ) v = v [:: - 1 ] idx = 0 for i in range ( len ( s )): c = s [ i ] if c in vowels : result [ i ] = v [ idx ] idx += 1 return '' . join ( result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0345_reverse-vowels-of-a-string.html","loc":"https://tofucode.com/posts/leetcode_0345_reverse-vowels-of-a-string.html"},{"title":"Leetcode 2131. Longest Palindrome by Concatenating Two Letter Words","text":"Question Link : https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/ Difficulty: Medium Question You are given an array of strings words. Each element of words consists of two lowercase English letters. Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once. Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0. A palindrome is a string that reads the same forward and backward. Example 1: Input: words = [\"lc\",\"cl\",\"gg\"] Output: 6 Explanation: One longest palindrome is \"lc\" + \"gg\" + \"cl\" = \"lcggcl\", of length 6. Note that \"clgglc\" is another longest palindrome that can be created. Example 2: Input: words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"] Output: 8 Explanation: One longest palindrome is \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\", of length 8. Note that \"lcyttycl\" is another longest palindrome that can be created. Example 3: Input: words = [\"cc\",\"ll\",\"xx\"] Output: 2 Explanation: One longest palindrome is \"cc\", of length 2. Note that \"ll\" is another longest palindrome that can be created, and so is \"xx\". Constraints: 1 <= words.length <= 105 words[i].length == 2 words[i] consists of lowercase English letters. Solution Identify the ways that the 2 letter words can be used to form a palindrome, keep a word to count map. go through the words list and match the pairs. This can be done in either one iteration or two iterations. Code ''' Leetcode 2131. Longest Palindrome by Concatenating Two Letter Words Question Link : https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/ Solution Link : https://tofucode.com/posts/leetcode_2131_longest-palindrome-by-concatenating-two-letter-words.html ''' class Solution : def longestPalindrome ( self , words : List [ str ]) -> int : ''' [\"lc\",\"cl\",\"gg\"] \"lc\" + \"gg\" + \"cl\" Each word is 2 chars either : aa OR ab build word counts word -> count lc: 1 cl: 1 gg: 1 go through words count again: diff char words: check if mirror exits, for every pair +4 char same char words: even number: can be added to both end, every pair +4 char odd number: can be added to the center - only 1, check at very end Time : O(n) Space: O(n) ''' counts = {} # word -> count for word in words : counts [ word ] = counts . get ( word , 0 ) + 1 print ( counts ) result = 0 remains_same_char_word = False for word , num in counts . items (): if word [ 0 ] != word [ 1 ]: reverse = word [ 1 ] + word [ 0 ] if reverse in counts : matches = min ( num , counts [ reverse ]) counts [ word ] = counts [ word ] - matches counts [ reverse ] = counts [ reverse ] - matches result += matches * 4 else : # every pair * 4 result += ( num // 2 ) * 4 if num % 2 != 0 : remains_same_char_word = True if remains_same_char_word : result += 2 return result class SolutionImproved1 : def longestPalindrome ( self , words : List [ str ]) -> int : ''' Do this in one loop: check as we go When there is a reverse, just need to -1 for the reverse remaining_same_char_word needs to be changed to a count Time : O(n) Space: O(n) ''' counts = {} # word -> count result = 0 remaining_same_char_word = 0 for word in words : if word [ 0 ] != word [ 1 ]: reverse = word [ 1 ] + word [ 0 ] if counts . get ( reverse , 0 ) > 0 : counts [ reverse ] -= 1 result += 4 else : counts [ word ] = counts . get ( word , 0 ) + 1 else : if counts . get ( word , 0 ) > 0 : counts [ word ] -= 1 result += 4 remaining_same_char_word -= 1 else : counts [ word ] = counts . get ( word , 0 ) + 1 remaining_same_char_word += 1 if remaining_same_char_word : result += 2 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2131_longest-palindrome-by-concatenating-two-letter-words.html","loc":"https://tofucode.com/posts/leetcode_2131_longest-palindrome-by-concatenating-two-letter-words.html"},{"title":"Leetcode 0206. Reverse Linked List","text":"Question Link : https://leetcode.com/problems/reverse-linked-list/ Difficulty: Easy Question Given the head of a singly linked list, reverse the list, and return the reversed list. Example 1: Input: head = [1,2,3,4,5] Output: [5,4,3,2,1] Example 2: Input: head = [1,2] Output: [2,1] Example 3: Input: head = [] Output: [] Constraints: The number of nodes in the list is the range [0, 5000]. -5000 <= Node.val <= 5000 Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? Solution Best solution is to do it in place with a temp pointer. We can use it to store p.next, reverse current, and then update p. Code ''' Leetcode 0206. Reverse Linked List Question Link : https://leetcode.com/problems/reverse-linked-list/ Solution Link : https://tofucode.com/posts/leetcode_0206_reverse-linked-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def reverseList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: ''' [1,2,3,4,5] 1 <- 2 <- 3 For 2 <- 3: p at 2 last at 1 temp = 3 1. set temp as next one of p 2. point back 2 <- 3: last <- p.next 3. update last: last = 2 4. update p: p = temp Time : O(n) Space: O(1) ''' p = head last = None while p : # store p.next temp = p . next p . next = last last = p # update p p = temp return last class SolutionNaive1 : def reverseList ( self , head : ListNode ) -> ListNode : ''' Iteratively: Use a list to go through the list and store the nodes, then go back and link them Time : O(n) Space: O(n) ''' if not head : return head l = [] p = head while p : l . append ( p ) p = p . next p = l . pop () start = p while len ( l ) != 0 : node = l . pop () p . next = node p = node p . next = None return start","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0206_reverse-linked-list.html","loc":"https://tofucode.com/posts/leetcode_0206_reverse-linked-list.html"},{"title":"Leetcode 0234. Palindrome Linked List","text":"Question Link : https://leetcode.com/problems/palindrome-linked-list/ Difficulty: Easy Question Given the head of a singly linked list, return true if it is a palindrome or false otherwise. Example 1: Input: head = [1,2,2,1] Output: true Example 2: Input: head = [1,2] Output: false Constraints: The number of nodes in the list is in the range [1, 105]. 0 <= Node.val <= 9 Follow up: Could you do it in O(n) time and O(1) space? Solution Best solution is to use fast slow pointer to find the mid point, and then expand from the center to check equal. Naive solution would be traverse the whole list and store everything down and compare. Code ''' Leetcode 0234. Palindrome Linked List Question Link : https://leetcode.com/problems/palindrome-linked-list/ Solution Link : https://tofucode.com/posts/leetcode_0234_palindrome-linked-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def isPalindrome ( self , head : Optional [ ListNode ]) -> bool : ''' Use slow, fast pointers to get to the middle of the list, and then from the center go to both directions and if equal Time : O(n) Space: O(1) ''' slow = fast = head back = None while fast and fast . next : fast = fast . next . next # reverse slow . next , back , slow = back , slow , slow . next # if it's odd, slow goes past middle to the next one if fast : slow = slow . next # slow keeps going forward and back goes back while back : if back . val != slow . val : return False back = back . next slow = slow . next return True # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class SolutionNaive1 : def isPalindrome ( self , head : Optional [ ListNode ]) -> bool : ''' Use a list to store the path of values and check if that list is a palindrome Time : O(n) Space: O(n) ''' if not head : return True l = [] p = head while p is not None : l . append ( p . val ) p = p . next return l == l [:: - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0234_palindrome-linked-list.html","loc":"https://tofucode.com/posts/leetcode_0234_palindrome-linked-list.html"},{"title":"Leetcode 0226. Invert Binary Tree","text":"Question Link : https://leetcode.com/problems/invert-binary-tree/ Difficulty: Easy Question Given the root of a binary tree, invert the tree, and return its root. Example 1: Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] Example 2: Input: root = [2,1,3] Output: [2,3,1] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 100]. -100 <= Node.val <= 100 Solution Do a flip at every node. Remember to check None Code ''' Leetcode 0226. Invert Binary Tree Question Link : https://leetcode.com/problems/invert-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0226_invert-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def invertTree ( self , root : Optional [ TreeNode ]) -> Optional [ TreeNode ]: ''' For every node do an invert Time : O(n) Space: O(n) ''' if not root : return None root . left , root . right = self . invertTree ( root . right ), self . invertTree ( root . left ) return root","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0226_invert-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0226_invert-binary-tree.html"},{"title":"Leetcode 0543. Diameter of Binary Tree","text":"Question Link : https://leetcode.com/problems/diameter-of-binary-tree/ Difficulty: Easy Question Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them. Example 1: Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3]. Example 2: Input: root = [1,2] Output: 1 Constraints: The number of nodes in the tree is in the range [1, 104]. -100 <= Node.val <= 100 Solution Go through the whole tree and keep track of the max (left depth + right depth). Note the anwser does not need to pass the original root node so we can't only calculate depth sum of root.left and root.right. Code ''' Leetcode 0543. Diameter of Binary Tree Question Link : https://leetcode.com/problems/diameter-of-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0543_diameter-of-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def diameterOfBinaryTree ( self , root : Optional [ TreeNode ]) -> int : ''' diameter doesn't have to path root node traverse the whole tree and keep returning the max depth, the result would be the max of left max depth + right max depth Time : O(n) Space: O(n) ''' self . result = 0 self . traverse ( root ) return self . result def traverse ( self , node ): ''' max depth ''' if not node : return 0 left = self . traverse ( node . left ) right = self . traverse ( node . right ) self . result = max ( self . result , left + right ) return 1 + max ( left , right )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0543_diameter-of-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0543_diameter-of-binary-tree.html"},{"title":"Leetcode 0049. Group Anagrams","text":"Question Link : https://leetcode.com/problems/group-anagrams/ Difficulty: Medium Question Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] Example 2: Input: strs = [\"\"] Output: [[\"\"]] Example 3: Input: strs = [\"a\"] Output: [[\"a\"]] Constraints: 1 <= strs.length <= 104 0 <= strs[i].length <= 100 strs[i] consists of lowercase English letters. Solution for each we want to count the chars, and the same char count would mean anagrams. Use a hash map to store the char count to word mapping. Code ''' Leetcode 0049. Group Anagrams Question Link : https://leetcode.com/problems/group-anagrams/ Solution Link : https://tofucode.com/posts/leetcode_0049_group-anagrams.html ''' class Solution : def groupAnagrams ( self , strs : List [ str ]) -> List [ List [ str ]]: ''' result = char count string -> [word1, word2] for every word: word: eat 26 count: [1, 0, 0, 0, 1 ...] convert to a string, store in index_map Time : O(nm) n words, m highest length of a wrod Space: O(nm) ''' result = {} # char count string -> [word] for word in strs : count = [ 0 ] * 26 for c in word : count [ ord ( c ) - ord ( 'a' )] += 1 s = str ( count ) result [ s ] = result . get ( s , []) + [ word ] return result . values ()","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0049_group-anagrams.html","loc":"https://tofucode.com/posts/leetcode_0049_group-anagrams.html"},{"title":"Leetcode 0169. Majority Element","text":"Question Link : https://leetcode.com/problems/majority-element/ Difficulty: Easy Question Given an array nums of size n, return the majority element. The majority element is the element that appears more than ân / 2â times. You may assume that the majority element always exists in the array. Example 1: Input: nums = [3,2,3] Output: 3 Example 2: Input: nums = [2,2,1,1,1,2,2] Output: 2 Constraints: n == nums.length 1 <= n <= 5 * 104 -109 <= nums[i] <= 109 Follow-up: Could you solve the problem in linear time and in O(1) space? Solution Either using a hash map to count or boyer-moore-voting-algorithm Code ''' Leetcode 0169. Majority Element Question Link : https://leetcode.com/problems/majority-element/ Solution Link : https://tofucode.com/posts/leetcode_0169_majority-element.html ''' class Solution : def majorityElement ( self , nums : List [ int ]) -> int : ''' loop and count, exit when reachs more than half Time : O(n) Space: O(n) ''' half = len ( nums ) // 2 counts = {} # num -> count for num in nums : counts [ num ] = counts . get ( num , 0 ) + 1 if counts [ num ] > half : return num class SolutionImproved1 : def majorityElement ( self , nums : List [ int ]) -> int : ''' Boyce-Moore Algorithms If we can count +1 for the majority element, and -1 for all otehrs only keep 1 variable to track the count, and +1 if seeing the same one, -1 otherwise, if we reach 0 again: reset the majority element [2,2,1,1,1,2,2] 1 2 This is safe as we are discarding equal number of majority and non majority elements, We can still find the major element from the rest Time : O(n) Space: O(1) ''' count = 0 result = 0 for i in nums : if count == 0 : result = i if i == result : count += 1 else : count -= 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0169_majority-element.html","loc":"https://tofucode.com/posts/leetcode_0169_majority-element.html"},{"title":"Leetcode 1662. Check If Two String Arrays are Equivalent","text":"Question Link : https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/ Difficulty: Easy Question Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise. A string is represented by an array if the array elements concatenated in order forms the string. Example 1: Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"] Output: true Explanation: word1 represents string \"ab\" + \"c\" -> \"abc\" word2 represents string \"a\" + \"bc\" -> \"abc\" The strings are the same, so return true. Example 2: Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"] Output: false Example 3: Input: word1 = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"] Output: true Constraints: 1 <= word1.length, word2.length <= 103 1 <= word1[i].length, word2[i].length <= 103 1 <= sum(word1[i].length), sum(word2[i].length) <= 103 word1[i] and word2[i] consist of lowercase letters. Solution Caculate the 2 words and compare Code ''' Leetcode 1662. Check If Two String Arrays are Equivalent Question Link : https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/ Solution Link : https://tofucode.com/posts/leetcode_1662_check-if-two-string-arrays-are-equivalent.html ''' class Solution : def arrayStringsAreEqual ( self , word1 : List [ str ], word2 : List [ str ]) -> bool : ''' calculate w1, w2, compare the 2 Time : O(n) Space: O(1) ''' w1 = w2 = '' for part in word1 : w1 += part for part in word2 : w2 += part return w1 == w2","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1662_check-if-two-string-arrays-are-equivalent.html","loc":"https://tofucode.com/posts/leetcode_1662_check-if-two-string-arrays-are-equivalent.html"},{"title":"Leetcode 0160. Intersection of Two Linked Lists","text":"Question Link : https://leetcode.com/problems/intersection-of-two-linked-lists/ Difficulty: Easy Question Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. Custom Judge: The inputs to the judge are given as follows (your program is not given these inputs): intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node. listA - The first linked list. listB - The second linked list. skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node. skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node. The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted. Example 1: Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 Output: Intersected at '8' Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. - Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory. Example 2: Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Intersected at '2' Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3: Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: No intersection Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null. Constraints: The number of nodes of listA is in the m. The number of nodes of listB is in the n. 1 <= m, n <= 3 * 104 1 <= Node.val <= 105 0 <= skipA < m 0 <= skipB < n intersectVal is 0 if listA and listB do not intersect. intersectVal == listA[skipA] == listB[skipB] if listA and listB intersect. Follow up: Could you write a solution that runs in O(m + n) time and use only O(1) memory? Solution when one list ends, direct it to the start of the other list, this way the long short list cancels themself out Code ''' Leetcode 0160. Intersection of Two Linked Lists Question Link : https://leetcode.com/problems/intersection-of-two-linked-lists/ Solution Link : https://tofucode.com/posts/leetcode_0160_intersection-of-two-linked-lists.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution : def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> Optional [ ListNode ]: ''' when one list ends, direct it to the start of the other list [4,1,8,4,5] [5,6,1,8,4,5] A: 4,1,8,4,5 | 5,6,1,8,4,5 B: 5,6,1,8,4,5 | 4,1,8,4,5 Both pointer will meet at the intersection if p1 = p2 = None it means after the switch traversal they got to the end and have no intersection ''' if headA is None or headB is None : return None x = headA y = headB while True : if x == y : return x if x is None : x = headB else : x = x . next if y is None : y = headA else : y = y . next","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0160_intersection-of-two-linked-lists.html","loc":"https://tofucode.com/posts/leetcode_0160_intersection-of-two-linked-lists.html"},{"title":"Leetcode 0104. Maximum Depth of Binary Tree","text":"Question Link : https://leetcode.com/problems/maximum-depth-of-binary-tree/ Difficulty: Easy Question Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example 1: Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2: Input: root = [1,null,2] Output: 2 Constraints: The number of nodes in the tree is in the range [0, 104]. -100 <= Node.val <= 100 Solution Use Recursion Code ''' Leetcode 0104. Maximum Depth of Binary Tree Question Link : https://leetcode.com/problems/maximum-depth-of-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0104_maximum-depth-of-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def maxDepth ( self , root : Optional [ TreeNode ]) -> int : ''' Use recursion max(left, right) + 1 Time : O(n) Space: O(n) ''' if root is None : return 0 return max ( self . maxDepth ( root . left ), self . maxDepth ( root . right )) + 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0104_maximum-depth-of-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0104_maximum-depth-of-binary-tree.html"},{"title":"Leetcode 0136. Single Number","text":"Question Link : https://leetcode.com/problems/single-number/ Difficulty: Easy Question Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1: Input: nums = [2,2,1] Output: 1 Example 2: Input: nums = [4,1,2,1,2] Output: 4 Example 3: Input: nums = [1] Output: 1 Constraints: 1 <= nums.length <= 3 * 104 -3 * 104 <= nums[i] <= 3 * 104 Each element in the array appears twice except for one element which appears only once. Solution Any number that XOR it self would cancel itself out. So we can go through nums and xor everything Code ''' Leetcode 0136. Single Number Question Link : https://leetcode.com/problems/single-number/ Solution Link : https://tofucode.com/posts/leetcode_0136_single-number.html ''' class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ''' xor Time : O(n) Space: O(1) ''' result = nums [ 0 ] for i in range ( 1 , len ( nums )): result &#94;= nums [ i ] return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0136_single-number.html","loc":"https://tofucode.com/posts/leetcode_0136_single-number.html"},{"title":"Leetcode 2095. Delete the Middle Node of a Linked List","text":"Question Link : https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/ Difficulty: Medium Question You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list. The middle node of a linked list of size n is the ân / 2âth node from the start using 0-based indexing, where âxâ denotes the largest integer less than or equal to x. For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively. Example 1: Input: head = [1,3,4,7,1,2,6] Output: [1,3,4,1,2,6] Explanation: The above figure represents the given linked list. The indices of the nodes are written below. Since n = 7, node 3 with value 7 is the middle node, which is marked in red. We return the new list after removing this node. Example 2: Input: head = [1,2,3,4] Output: [1,2,4] Explanation: The above figure represents the given linked list. For n = 4, node 2 with value 3 is the middle node, which is marked in red. Example 3: Input: head = [2,1] Output: [2] Explanation: The above figure represents the given linked list. For n = 2, node 1 with value 1 is the middle node, which is marked in red. Node 0 with value 2 is the only node remaining after removing node 1. Constraints: The number of nodes in the list is in the range [1, 105]. 1 <= Node.val <= 105 Solution Use a fast pointer that travels at twice the speed of the slow pointer. When the fast one is at the end, the slow one is at the position that needs to be removed. Code ''' Leetcode 2095. Delete the Middle Node of a Linked List Question Link : https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/ Solution Link : https://tofucode.com/posts/leetcode_2095_delete-the-middle-node-of-a-linked-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def deleteMiddle ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: ''' [1,3,4,7,1,2,6] s f l remove s using l.next Time : O(n) Space: O(1) ''' # return if zero or one node if not head or not head . next : return None fast = slow = last = head while fast and fast . next : last = slow slow = slow . next fast = fast . next . next # delete slow last . next = slow . next return head","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2095_delete-the-middle-node-of-a-linked-list.html","loc":"https://tofucode.com/posts/leetcode_2095_delete-the-middle-node-of-a-linked-list.html"},{"title":"Leetcode 0101. Symmetric Tree","text":"Question Link : https://leetcode.com/problems/symmetric-tree/ Difficulty: Easy Question Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). Example 1: Input: root = [1,2,2,3,4,4,3] Output: true Example 2: Input: root = [1,2,2,null,3,null,3] Output: false Constraints: The number of nodes in the tree is in the range [1, 1000]. -100 <= Node.val <= 100 Follow up: Could you solve it both recursively and iteratively? Solution Check Symmety by either recursively or iteratively checking is symmetric Code ''' Leetcode 0101. Symmetric Tree Question Link : https://leetcode.com/problems/symmetric-tree/ Solution Link : https://tofucode.com/posts/leetcode_0101_symmetric-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def isSymmetric ( self , root : Optional [ TreeNode ]) -> bool : ''' Recursively check branches are mirrors of each other Time : O(n) Space: O(n) ''' if not root : return True return self . isMirror ( root . left , root . right ) def isMirror ( self , x , y ): if x is None and y is None : return True if x is None and y is not None : return False if y is None and x is not None : return False if x . val != y . val : return False return self . isMirror ( x . left , y . right ) and self . isMirror ( x . right , y . left ) class SolutionAlternative1 : def isSymmetric ( self , root : Optional [ TreeNode ]) -> bool : ''' Flip one branch and compare if the two branches are equal with Recursion Time : O(n) Space: O(n) ''' if root is None : return True # flip the right and then compare the 2 self . flip ( root . right ) return self . equal ( root . left , root . right ) def flip ( self , x ): if x is None : return x . left , x . right = x . right , x . left self . flip ( x . left ) self . flip ( x . right ) def equal ( self , x , y ): if x is None and y is None : return True if x is None and y is not None : return False if y is None and x is not None : return False if x . val != y . val : return False return self . equal ( x . left , y . left ) and self . equal ( x . right , y . right ) class SolutionAlternative2 : def isSymmetric ( self , root : Optional [ TreeNode ]) -> bool : ''' Iterative with a queue Time : O(n) Space: O(n) ''' if root is None : return True queue = [] queue . append (( root . left , root . right )) while queue : x , y = queue . pop ( 0 ) if not x and not y : continue if not x or not y : return False if x . val != y . val : return False # here l and r are symmetric queue . append (( x . left , y . right )) queue . append (( x . right , y . left )) return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0101_symmetric-tree.html","loc":"https://tofucode.com/posts/leetcode_0101_symmetric-tree.html"},{"title":"Leetcode 0334. Increasing Triplet Subsequence","text":"Question Link : https://leetcode.com/problems/increasing-triplet-subsequence/ Difficulty: Medium Question Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false. Example 1: Input: nums = [1,2,3,4,5] Output: true Explanation: Any triplet where i < j < k is valid. Example 2: Input: nums = [5,4,3,2,1] Output: false Explanation: No triplet exists. Example 3: Input: nums = [2,1,5,0,4,6] Output: true Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6. Constraints: 1 <= nums.length <= 5 * 105 -231 <= nums[i] <= 231 - 1 Follow up: Could you implement a solution that runs in O(n) time complexity and O(1) space complexity? Solution Keep track of 2 pointers, and find 2 places where the second > the first, after we find this, if we come upon a thrid where third > second, we return True Code ''' Leetcode 0334. Increasing Triplet Subsequence Question Link : https://leetcode.com/problems/increasing-triplet-subsequence/ Solution Link : https://tofucode.com/posts/leetcode_0334_increasing-triplet-subsequence.html ''' class Solution : def increasingTriplet ( self , nums : List [ int ]) -> bool : ''' first, second, thrid Time : O(n) Space: O(1) ''' first = second = math . inf for n in nums : if n <= first : first = n elif n <= second : second = n else : return True return False","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0334_increasing-triplet-subsequence.html","loc":"https://tofucode.com/posts/leetcode_0334_increasing-triplet-subsequence.html"},{"title":"Leetcode 0070. Climbing Stairs","text":"Question Link : https://leetcode.com/problems/climbing-stairs/ Difficulty: Easy Question You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Example 1: Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2: Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step Constraints: 1 <= n <= 45 Solution Use dp as the number of ways at step i is the sum of the previous 2 Code ''' Leetcode 0070. Climbing Stairs Question Link : https://leetcode.com/problems/climbing-stairs/ Solution Link : https://tofucode.com/posts/leetcode_0070_climbing-stairs.html ''' class Solution : def climbStairs ( self , n : int ) -> int : ''' dp[i] number of ways to reach stairs i dp[i] = dp[i-2] + dp[i-1] Time : O(n) Space: O(n) ''' if n <= 2 : return n dp = [ 0 ] * n dp [ 0 ] = 1 dp [ 1 ] = 2 for i in range ( 2 , n ): dp [ i ] = dp [ i - 2 ] + dp [ i - 1 ] return dp [ - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0070_climbing-stairs.html","loc":"https://tofucode.com/posts/leetcode_0070_climbing-stairs.html"},{"title":"Leetcode 2432. The Employee That Worked on the Longest Task","text":"Question Link : https://leetcode.com/problems/the-employee-that-worked-on-the-longest-task/ Difficulty: Easy Question There are n employees, each with a unique id from 0 to n - 1. You are given a 2D integer array logs where logs[i] = [idi, leaveTimei] where: idi is the id of the employee that worked on the ith task, and leaveTimei is the time at which the employee finished the ith task. All the values leaveTimei are unique. Note that the ith task starts the moment right after the (i - 1)th task ends, and the 0th task starts at time 0. Return the id of the employee that worked the task with the longest time. If there is a tie between two or more employees, return the smallest id among them. Example 1: Input: n = 10, logs = [[0,3],[2,5],[0,9],[1,15]] Output: 1 Explanation: Task 0 started at 0 and ended at 3 with 3 units of times. Task 1 started at 3 and ended at 5 with 2 units of times. Task 2 started at 5 and ended at 9 with 4 units of times. Task 3 started at 9 and ended at 15 with 6 units of times. The task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1. Example 2: Input: n = 26, logs = [[1,1],[3,7],[2,12],[7,17]] Output: 3 Explanation: Task 0 started at 0 and ended at 1 with 1 unit of times. Task 1 started at 1 and ended at 7 with 6 units of times. Task 2 started at 7 and ended at 12 with 5 units of times. Task 3 started at 12 and ended at 17 with 5 units of times. The tasks with the longest time is task 1. The employees that worked on it is 3, so we return 3. Example 3: Input: n = 2, logs = [[0,10],[1,20]] Output: 0 Explanation: Task 0 started at 0 and ended at 10 with 10 units of times. Task 1 started at 10 and ended at 20 with 10 units of times. The tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0. Constraints: 2 <= n <= 500 1 <= logs.length <= 500 logs[i].length == 2 0 <= idi <= n - 1 1 <= leaveTimei <= 500 idi != idi+1 leaveTimei are sorted in a strictly increasing order. Solution Go through the logs and keep track of the max Code ''' Leetcode 2432. The Employee That Worked on the Longest Task Question Link : https://leetcode.com/problems/the-employee-that-worked-on-the-longest-task/ Solution Link : https://tofucode.com/posts/leetcode_2432_the-employee-that-worked-on-the-longest-task.html ''' class Solution : def hardestWorker ( self , n : int , logs : List [ List [ int ]]) -> int : ''' keep a max id and time, if there is a tie on time, we want the smallest id Time : O(n) Space: O(1) ''' longest_id = logs [ 0 ][ 0 ] longest_time = logs [ 0 ][ 1 ] for i in range ( 1 , len ( logs )): current_id , leave_time = logs [ i ] used_time = leave_time - logs [ i - 1 ][ 1 ] if used_time > longest_time or ( used_time == longest_time and current_id < longest_id ): longest_id = current_id longest_time = used_time return longest_id","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2432_the-employee-that-worked-on-the-longest-task.html","loc":"https://tofucode.com/posts/leetcode_2432_the-employee-that-worked-on-the-longest-task.html"},{"title":"Leetcode 2433. Find The Original Array of Prefix Xor","text":"Question Link : https://leetcode.com/problems/find-the-original-array-of-prefix-xor/ Difficulty: Medium Question You are given an integer array pref of size n. Find and return the array arr of size n that satisfies: pref[i] = arr[0] &#94; arr[1] &#94; ... &#94; arr[i]. Note that &#94; denotes the bitwise-xor operation. It can be proven that the answer is unique. Example 1: Input: pref = [5,2,0,3,1] Output: [5,7,2,3,2] Explanation: From the array [5,7,2,3,2] we have the following: - pref[0] = 5. - pref[1] = 5 &#94; 7 = 2. - pref[2] = 5 &#94; 7 &#94; 2 = 0. - pref[3] = 5 &#94; 7 &#94; 2 &#94; 3 = 3. - pref[4] = 5 &#94; 7 &#94; 2 &#94; 3 &#94; 2 = 1. Example 2: Input: pref = [13] Output: [13] Explanation: We have pref[0] = arr[0] = 13. Constraints: 1 <= pref.length <= 105 0 <= pref[i] <= 106 Solution By looking at the XOR truth table, one can find that using the result to XOR one number gives the other number Code ''' Leetcode 2433. Find The Original Array of Prefix Xor Question Link : https://leetcode.com/problems/find-the-original-array-of-prefix-xor/ Solution Link : https://tofucode.com/posts/leetcode_2433_find-the-original-array-of-prefix-xor.html ''' class Solution : def findArray ( self , pref : List [ int ]) -> List [ int ]: ''' if a &#94; b = c then b &#94; c = a Time : O(n) Space: O(n) ''' result = [ pref [ 0 ]] for i in range ( 1 , len ( pref )): result . append ( pref [ i - 1 ] &#94; pref [ i ]) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2433_find-the-original-array-of-prefix-xor.html","loc":"https://tofucode.com/posts/leetcode_2433_find-the-original-array-of-prefix-xor.html"},{"title":"Leetcode 0035. Search Insert Position","text":"Question Link : https://leetcode.com/problems/search-insert-position/ Difficulty: Easy Question Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. Example 1: Input: nums = [1,3,5,6], target = 5 Output: 2 Example 2: Input: nums = [1,3,5,6], target = 2 Output: 1 Example 3: Input: nums = [1,3,5,6], target = 7 Output: 4 Constraints: 1 <= nums.length <= 104 -104 <= nums[i] <= 104 nums contains distinct values sorted in ascending order. -104 <= target <= 104 Solution Binary search. Need to note when not found, we want to return the insert position Code ''' Leetcode 0035. Search Insert Position Question Link : https://leetcode.com/problems/search-insert-position/ Solution Link : https://tofucode.com/posts/leetcode_0035_search-insert-position.html ''' class Solution : def searchInsert ( self , nums : List [ int ], target : int ) -> int : ''' binary search while condition should be >= cause for the following case when r,l = 0, l needs to be mid + 1 to give the current insert position [1,3,5,6] 2 Time : O(log n) Space: O(1) ''' l = 0 r = len ( nums ) - 1 while l <= r : mid = ( l + r ) // 2 if nums [ mid ] == target : return mid elif nums [ mid ] > target : r = mid - 1 else : l = mid + 1 return l","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0035_search-insert-position.html","loc":"https://tofucode.com/posts/leetcode_0035_search-insert-position.html"},{"title":"Leetcode 0094. Binary Tree Inorder Traversal","text":"Question Link : https://leetcode.com/problems/binary-tree-inorder-traversal/ Difficulty: Easy Question Given the root of a binary tree, return the inorder traversal of its nodes' values. Example 1: Input: root = [1,null,2,3] Output: [1,3,2] Example 2: Input: root = [] Output: [] Example 3: Input: root = [1] Output: [1] Constraints: The number of nodes in the tree is in the range [0, 100]. -100 <= Node.val <= 100 Follow up: Recursive solution is trivial, could you do it iteratively? Solution Recursive traversal of the whole tree Code ''' Leetcode 0094. Binary Tree Inorder Traversal Question Link : https://leetcode.com/problems/binary-tree-inorder-traversal/ Solution Link : https://tofucode.com/posts/leetcode_0094_binary-tree-inorder-traversal.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def inorderTraversal ( self , root : Optional [ TreeNode ]) -> List [ int ]: ''' inorder: left, node, right Time : O(n) Space: O(n) ''' self . result = [] self . inorder ( root ) return self . result def inorder ( self , node ): if not node : return self . inorder ( node . left ) self . result . append ( node . val ) self . inorder ( node . right )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0094_binary-tree-inorder-traversal.html","loc":"https://tofucode.com/posts/leetcode_0094_binary-tree-inorder-traversal.html"},{"title":"Leetcode 0653. Two Sum IV - Input is a BST","text":"Question Link : https://leetcode.com/problems/two-sum-iv-input-is-a-bst/ Difficulty: Easy Question Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: Input: root = [5,3,6,2,4,null,7], k = 9 Output: true Example 2: Input: root = [5,3,6,2,4,null,7], k = 28 Output: false Constraints: The number of nodes in the tree is in the range [1, 104]. -104 <= Node.val <= 104 root is guaranteed to be a valid binary search tree. -105 <= k <= 105 Solution Go through the whole tree while keeping a seen set, and at each new node keep checking if (k - current.val) is in seen Code ''' Leetcode 0653. Two Sum IV - Input is a BST Question Link : https://leetcode.com/problems/two-sum-iv-input-is-a-bst/ Solution Link : https://tofucode.com/posts/leetcode_0653_two-sum-iv-input-is-a-bst.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def findTarget ( self , root : Optional [ TreeNode ], k : int ) -> bool : ''' seen = set() track seen number dfs: for every node: check k - current Time : O(n) Space: O(n) ''' stack = [ root ] seen = set () while stack : current = stack . pop () # dfs if k - current . val in seen : return True seen . add ( current . val ) if current . left : stack . append ( current . left ) if current . right : stack . append ( current . right ) return False class SolutionAlternative1 : def findTarget ( self , root : TreeNode , k : int ) -> bool : ''' Use inorder traversal and a hashmap Can also inorder traverse and store everything down, and then 2 pointers Time : O(n) Space: O(n) ''' seen = set () return self . traverse ( root , seen , k ) def traverse ( self , node , seen , k ): if not node : return False # in order l = self . traverse ( node . left , seen , k ) if l : return True if k - node . val in seen : return True seen . add ( node . val ) return self . traverse ( node . right , seen , k )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0653_two-sum-iv-input-is-a-bst.html","loc":"https://tofucode.com/posts/leetcode_0653_two-sum-iv-input-is-a-bst.html"},{"title":"Leetcode 0623. Add One Row to Tree","text":"Question Link : https://leetcode.com/problems/add-one-row-to-tree/ Difficulty: Medium Question Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth. Note that the root node is at depth 1. The adding rule is: Given the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root. cur's original left subtree should be the left subtree of the new left subtree root. cur's original right subtree should be the right subtree of the new right subtree root. If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1: Input: root = [4,2,6,3,1,5], val = 1, depth = 2 Output: [4,1,1,2,null,null,6,3,1,5] Example 2: Input: root = [4,2,null,3,1], val = 1, depth = 3 Output: [4,2,null,1,1,3,null,null,1] Constraints: The number of nodes in the tree is in the range [1, 104]. The depth of the tree is in the range [1, 104]. -100 <= Node.val <= 100 -105 <= val <= 105 1 <= depth <= the depth of tree + 1 Solution Traverse the tree with dfs stack and keep strack of depth information along with each node. At the given dpeth, attach the new nodes. Will have to go through the whole tree. Code ''' Leetcode 0623. Add One Row to Tree Question Link : https://leetcode.com/problems/add-one-row-to-tree/ Solution Link : https://tofucode.com/posts/leetcode_0623_add-one-row-to-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def addOneRow ( self , root : Optional [ TreeNode ], val : int , depth : int ) -> Optional [ TreeNode ]: ''' dfs with a stack (depth, node) # -1 for left, 1 for right at depth-1: create 2 nodes and link Time : O(n) Space: O(n) ''' if depth == 1 : new_node = TreeNode ( val ) new_node . left = root return new_node stack = [( 1 , root )] while stack : d , node = stack . pop ( 0 ) if d == depth - 1 : # create 2 nodes l = TreeNode ( val ) r = TreeNode ( val ) # link node . left , l . left = l , node . left node . right , r . right = r , node . right left = node . left right = node . right if left : stack . append (( d + 1 , left )) if right : stack . append (( d + 1 , right )) return root","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0623_add-one-row-to-tree.html","loc":"https://tofucode.com/posts/leetcode_0623_add-one-row-to-tree.html"},{"title":"Leetcode 0112. Path Sum","text":"Question Link : https://leetcode.com/problems/path-sum/ Difficulty: Easy Question Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Explanation: The root-to-leaf path with the target sum is shown. Example 2: Input: root = [1,2,3], targetSum = 5 Output: false Explanation: There two root-to-leaf paths in the tree: (1 --> 2): The sum is 3. (1 --> 3): The sum is 4. There is no root-to-leaf path with sum = 5. Example 3: Input: root = [], targetSum = 0 Output: false Explanation: Since the tree is empty, there are no root-to-leaf paths. Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 <= Node.val <= 1000 -1000 <= targetSum <= 1000 Solution Use recursion to check the whole tree, and return true when there is a sum at a leaf node Code ''' Leetcode 0112. Path Sum Question Link : https://leetcode.com/problems/path-sum/ Solution Link : https://tofucode.com/posts/leetcode_0112_path-sum.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def hasPathSum ( self , root : Optional [ TreeNode ], targetSum : int ) -> bool : ''' For True check: 1. sum 2. is leaf node Time : O(n) Space: O(n) ''' if not root : return False remain = targetSum - root . val if remain == 0 and not root . left and not root . right : return True return self . hasPathSum ( root . left , remain ) or self . hasPathSum ( root . right , remain )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0112_path-sum.html","loc":"https://tofucode.com/posts/leetcode_0112_path-sum.html"},{"title":"Leetcode 1578. Minimum Time to Make Rope Colorful","text":"Question Link : https://leetcode.com/problems/minimum-time-to-make-rope-colorful/ Difficulty: Medium Question Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon. Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope. Return the minimum time Bob needs to make the rope colorful. Example 1: Input: colors = \"abaac\", neededTime = [1,2,3,4,5] Output: 3 Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green. Bob can remove the blue balloon at index 2. This takes 3 seconds. There are no longer two consecutive balloons of the same color. Total time = 3. Example 2: Input: colors = \"abc\", neededTime = [1,2,3] Output: 0 Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope. Example 3: Input: colors = \"aabaa\", neededTime = [1,2,3,4,1] Output: 2 Explanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove. There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2. Constraints: n == colors.length == neededTime.length 1 <= n <= 105 1 <= neededTime[i] <= 104 colors contains only lowercase English letters. Solution Do not need to use DP, instead see the problem by splitting the ballons into groups by color and we need to remove the lower cost ones for each group. This would mean leaving the highest cost one, so cost for each group is sum time of group - max time in this group. Code ''' Leetcode 1578. Minimum Time to Make Rope Colorful Question Link : https://leetcode.com/problems/minimum-time-to-make-rope-colorful/ Solution Link : https://tofucode.com/posts/leetcode_1578_minimum-time-to-make-rope-colorful.html ''' class Solution : def minCost ( self , colors : str , neededTime : List [ int ]) -> int : ''' \"a,a,b,a,a\" [1,2,3,4,1] 1,2 4,1 for each group: needed time = sum time - max time Time : O(n) Space: O(1) ''' current = None currentMax = 0 currentSum = 0 result = 0 for i in range ( len ( colors )): if colors [ i ] == current : # update current sum, max currentMax = max ( currentMax , neededTime [ i ]) currentSum += neededTime [ i ] else : result += currentSum - currentMax # update current color, sum, max current = colors [ i ] currentMax = neededTime [ i ] currentSum = neededTime [ i ] # check the last group result += currentSum - currentMax return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1578_minimum-time-to-make-rope-colorful.html","loc":"https://tofucode.com/posts/leetcode_1578_minimum-time-to-make-rope-colorful.html"},{"title":"Leetcode 0746. Min Cost Climbing Stairs","text":"Question Link : https://leetcode.com/problems/min-cost-climbing-stairs/ Difficulty: Easy Question You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor. Example 1: Input: cost = [10,15,20] Output: 15 Explanation: You will start at index 1. - Pay 15 and climb two steps to reach the top. The total cost is 15. Example 2: Input: cost = [1,100,1,1,1,100,1,1,100,1] Output: 6 Explanation: You will start at index 0. - Pay 1 and climb two steps to reach index 2. - Pay 1 and climb two steps to reach index 4. - Pay 1 and climb two steps to reach index 6. - Pay 1 and climb one step to reach index 7. - Pay 1 and climb two steps to reach index 9. - Pay 1 and climb one step to reach the top. The total cost is 6. Constraints: 2 <= cost.length <= 1000 0 <= cost[i] <= 999 Solution Look back at -1 and -2 positions and take the min Code ''' Leetcode 0746. Min Cost Climbing Stairs Question Link : https://leetcode.com/problems/min-cost-climbing-stairs/ Solution Link : https://tofucode.com/posts/leetcode_0746_min-cost-climbing-stairs.html ''' class Solution : def minCostClimbingStairs ( self , cost : List [ int ]) -> int : ''' [10,15,20] [10 15 X Y] The End Y can either be achived: X -> Y or 15 -> Y In other words: 15 or X can be the ending Time : O(n) Space: O(n) ''' n = len ( cost ) dp = [ - 1 ] * n dp [ 0 ] = cost [ 0 ] dp [ 1 ] = cost [ 1 ] for i in range ( 2 , n ): dp [ i ] = min ( dp [ i - 1 ], dp [ i - 2 ]) + cost [ i ] return min ( dp [ - 2 ], dp [ - 1 ])","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0746_min-cost-climbing-stairs.html","loc":"https://tofucode.com/posts/leetcode_0746_min-cost-climbing-stairs.html"},{"title":"Leetcode 0406. Queue Reconstruction by Height","text":"Question Link : https://leetcode.com/problems/queue-reconstruction-by-height/ Difficulty: Medium Question You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi. Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue). Example 1: Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] Explanation: Person 0 has height 5 with no other people taller or the same height in front. Person 1 has height 7 with no other people taller or the same height in front. Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1. Person 3 has height 6 with one person taller or the same height in front, which is person 1. Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3. Person 5 has height 7 with one person taller or the same height in front, which is person 1. Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue. Example 2: Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] Constraints: 1 <= people.length <= 2000 0 <= hi <= 106 0 <= ki < people.length It is guaranteed that the queue can be reconstructed. Solution Try to write out what would happen if we sorted from decreasing h or increasing h, and how each one needs to be inserted with relation to its k. Code ''' Leetcode 0406. Queue Reconstruction by Height Question Link : https://leetcode.com/problems/queue-reconstruction-by-height/ Solution Link : https://tofucode.com/posts/leetcode_0406_queue-reconstruction-by-height.html ''' class Solution : def reconstructQueue ( self , people : List [ List [ int ]]) -> List [ List [ int ]]: ''' [7,0],[4,4],[7,1],[5,0],[6,1],[5,2] k: num of people in front >= me # start from smallest height [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] [4,4] [5,0] [5,2] [6,1] [7,0] [7,1] from h smallest to largest: count empties or same height till upto k and insert Time : O(nlogn + n&#94;2) Space: O(n) ''' result = [ None ] * len ( people ) # sort the array in increasing order of height, increasing of k # before: [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] # after : [[4,4],[5,0],[5,2],[6,1],[7,0],[7,1]] people = sorted ( people , key = lambda x : ( x [ 0 ], x [ 1 ])) for p in people : h , k = p for i in range ( len ( people )): if result [ i ] is None or result [ i ][ 0 ] == h : k -= 1 # found position for p, -1 now cause there were k before if k == - 1 : result [ i ] = p break return result class SolutionAlternative1 : def reconstructQueue ( self , people : List [ List [ int ]]) -> List [ List [ int ]]: ''' [7,0],[4,4],[7,1],[5,0],[6,1],[5,2] k: num of people in front >= me insert with k as index [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] 0: [7,0] 1: [7,0], [7,1] 1: [7,0], [6,1], [7,1] 1: [7,0], [6,1], [7,1] 0: [5,0], [7,0], [6,1], [7,1] 2: [5,0], [7,0], [5,2], [6,1], [7,1] 4: [5,0], [7,0], [5,2], [6,1], [4,4], [7,1] * persons with the same height are sorted by the second value Time : O(nlogn + n&#94;2) Space: O(n) ''' result = [] # sort the array in decreasing order of height, increasing of k # before: [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] # after: [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]] people . sort ( key = lambda x : ( - x [ 0 ], x [ 1 ])) for p in people : h , k = p # greedy insert with k as the index result . insert ( k , p ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0406_queue-reconstruction-by-height.html","loc":"https://tofucode.com/posts/leetcode_0406_queue-reconstruction-by-height.html"},{"title":"Leetcode 2326. Spiral Matrix IV","text":"Question Link : https://leetcode.com/problems/spiral-matrix-iv/ Difficulty: Medium Question You are given two integers m and n, which represent the dimensions of a matrix. You are also given the head of a linked list of integers. Generate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1. Return the generated matrix. Example 1: Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0] Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]] Explanation: The diagram above shows how the values are printed in the matrix. Note that the remaining spaces in the matrix are filled with -1. Example 2: Input: m = 1, n = 4, head = [0,1,2] Output: [[0,1,2,-1]] Explanation: The diagram above shows how the values are printed from left to right in the matrix. The last space in the matrix is set to -1. Constraints: 1 <= m, n <= 105 1 <= m * n <= 105 The number of nodes in the list is in the range [1, m * n]. 0 <= Node.val <= 1000 Solution Traverse matrix with dx, dy denoting movement in x and y direction and keep inserting the next val from the list Code ''' Leetcode 2326. Spiral Matrix IV Question Link : https://leetcode.com/problems/spiral-matrix-iv/ Solution Link : https://tofucode.com/posts/leetcode_2326_spiral-matrix-iv.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def spiralMatrix ( self , m : int , n : int , head : Optional [ ListNode ]) -> List [ List [ int ]]: ''' Use dx, dy to denote movement instead of a direction variable Time : O(n*m) Space: O(n*m) ''' result = [[ - 1 ] * n for i in range ( m )] x , y = 0 , 0 dx , dy = 1 , 0 # change in x , change in y p = head for i in range ( n * m ): # boundary for direction change if x + dx < 0 or x + dx > n - 1 or y + dy > m - 1 or y + dy < 0 or result [ y + dy ][ x + dx ] != - 1 : dx , dy = - dy , dx # update if not p : break result [ y ][ x ] = p . val # x, y as x is the horizontal movement p = p . next # move x , y = x + dx , y + dy return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2326_spiral-matrix-iv.html","loc":"https://tofucode.com/posts/leetcode_2326_spiral-matrix-iv.html"},{"title":"Leetcode 1710. Maximum Units on a Truck","text":"Question Link : https://leetcode.com/problems/maximum-units-on-a-truck/ Difficulty: Easy Question You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]: numberOfBoxesi is the number of boxes of type i. numberOfUnitsPerBoxi is the number of units in each box of the type i. You are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed truckSize. Return the maximum total number of units that can be put on the truck. Example 1: Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4 Output: 8 Explanation: There are: - 1 box of the first type that contains 3 units. - 2 boxes of the second type that contain 2 units each. - 3 boxes of the third type that contain 1 unit each. You can take all the boxes of the first and second types, and one box of the third type. The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8. Example 2: Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10 Output: 91 Constraints: 1 <= boxTypes.length <= 1000 1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000 1 <= truckSize <= 106 Solution Sort by the highest value, and greedily take from the front until truck is full Code ''' Leetcode 1710. Maximum Units on a Truck Question Link : https://leetcode.com/problems/maximum-units-on-a-truck/ Solution Link : https://tofucode.com/posts/leetcode_1710_maximum-units-on-a-truck.html ''' class Solution : def maximumUnits ( self , boxTypes : List [ List [ int ]], truckSize : int ) -> int : ''' [[5,10],[2,5],[4,7],[3,9]] [5,10], [3,9], [4,7], [2,5] 10 50 + 27 + 14 = 91 Time : O(n log n) Space: O(n) ''' boxes = sorted ( boxTypes , key = lambda x : - x [ 1 ]) result = 0 idx = 0 currentTruck = truckSize while idx < len ( boxes ) and currentTruck > 0 : currentBoxes = boxes [ idx ][ 0 ] take = min ( currentBoxes , currentTruck ) result += take * boxes [ idx ][ 1 ] currentTruck -= take idx += 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1710_maximum-units-on-a-truck.html","loc":"https://tofucode.com/posts/leetcode_1710_maximum-units-on-a-truck.html"},{"title":"Leetcode 0462. Minimum Moves to Equal Array Elements II","text":"Question Link : https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/ Difficulty: Medium Question Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal. In one move, you can increment or decrement an element of the array by 1. Test cases are designed so that the answer will fit in a 32-bit integer. Example 1: Input: nums = [1,2,3] Output: 2 Explanation: Only two moves are needed (remember each move increments or decrements one element): [1,2,3] => [2,2,3] => [2,2,2] Example 2: Input: nums = [1,10,2,9] Output: 16 Constraints: n == nums.length 1 <= nums.length <= 105 -109 <= nums[i] <= 109 Solution We are basically looking for a point that produces the min sum of distances to all other points, that's the median Code ''' Leetcode 0462. Minimum Moves to Equal Array Elements II Question Link : https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/ Solution Link : https://tofucode.com/posts/leetcode_0462_minimum-moves-to-equal-array-elements-ii.html ''' class Solution : def minMoves2 ( self , nums : List [ int ]) -> int : ''' Use median not average Time : O(n log n) Space: O(n) ''' median = sorted ( nums )[ len ( nums ) // 2 ] moves = [ abs ( num - median ) for num in nums ] return sum ( moves )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0462_minimum-moves-to-equal-array-elements-ii.html","loc":"https://tofucode.com/posts/leetcode_0462_minimum-moves-to-equal-array-elements-ii.html"},{"title":"Leetcode 1647. Minimum Deletions to Make Character Frequencies Unique","text":"Question Link : https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/ Difficulty: Medium Question A string s is called good if there are no two different characters in s that have the same frequency. Given a string s, return the minimum number of characters you need to delete to make s good. The frequency of a character in a string is the number of times it appears in the string. For example, in the string \"aab\", the frequency of 'a' is 2, while the frequency of 'b' is 1. Example 1: Input: s = \"aab\" Output: 0 Explanation: s is already good. Example 2: Input: s = \"aaabbbcc\" Output: 2 Explanation: You can delete two 'b's resulting in the good string \"aaabcc\". Another way it to delete one 'b' and one 'c' resulting in the good string \"aaabbc\". Example 3: Input: s = \"ceabaacb\" Output: 2 Explanation: You can delete both 'c's resulting in the good string \"eabaab\". Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored). Constraints: 1 <= s.length <= 105 s contains only lowercase English letters. Solution Count the frequency and sort in reverse. Go through it and use a max_freq marker to calculate what the max possible freq is Code ''' Leetcode 1647. Minimum Deletions to Make Character Frequencies Unique Question Link : https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/ Solution Link : https://tofucode.com/posts/leetcode_1647_minimum-deletions-to-make-character-frequencies-unique.html ''' class Solution : def minDeletions ( self , s : str ) -> int : ''' \"aaabbbcc\" a: 3 b: 3 c: 2 \"ceabaacb\" a: 3 b: 2 c: 2 e: 1 count first, sort by value, from highest to lowest freq: keep trying max_freq # s has n length, and k number of distinct chars (which is 26 max) Time : O(n) Space: O(1) ''' counts = {} # letter -> count for c in s : counts [ c ] = counts . get ( c , 0 ) + 1 max_freq = len ( s ) result = 0 for k , v in sorted ( counts . items (), key = lambda x : x [ 1 ], reverse = True ): if v > max_freq : result += v - max_freq # frequency of 0 is ignored if max_freq > 0 : max_freq -= 1 else : max_freq = v - 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1647_minimum-deletions-to-make-character-frequencies-unique.html","loc":"https://tofucode.com/posts/leetcode_1647_minimum-deletions-to-make-character-frequencies-unique.html"},{"title":"Leetcode 1423. Maximum Points You Can Obtain from Cards","text":"Question Link : https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/ Difficulty: Medium Question There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k, return the maximum score you can obtain. Example 1: Input: cardPoints = [1,2,3,4,5,6,1], k = 3 Output: 12 Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12. Example 2: Input: cardPoints = [2,2,2], k = 2 Output: 4 Explanation: Regardless of which two cards you take, your score will always be 4. Example 3: Input: cardPoints = [9,7,7,9,7,7,9], k = 7 Output: 55 Explanation: You have to take all the cards. Your score is the sum of points of all cards. Constraints: 1 <= cardPoints.length <= 105 1 <= cardPoints[i] <= 104 1 <= k <= cardPoints.length Solution First calculate the sum of the first k elements which is the starting window, then at each step we remove the latest one from the front and add in one from the back. Take the max point any time that's in the window. Code ''' Leetcode 1423. Maximum Points You Can Obtain from Cards Question Link : https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/ Solution Link : https://tofucode.com/posts/leetcode_1423_maximum-points-you-can-obtain-from-cards.html ''' class Solution : def maxScore ( self , cardPoints : List [ int ], k : int ) -> int : ''' [1,2,3,4,5,6,1], k = 3 5,6,1 sum (1,2,3) = 6 -3+1 = 4 -2+6 = 8 -1+5 = 12 Time : O(k) Space: O(1) ''' n = len ( cardPoints ) current = sum ( cardPoints [: k ]) result = current for i in range ( k ): current = current - cardPoints [ k - 1 - i ] + cardPoints [ n - 1 - i ] result = max ( result , current ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1423_maximum-points-you-can-obtain-from-cards.html","loc":"https://tofucode.com/posts/leetcode_1423_maximum-points-you-can-obtain-from-cards.html"},{"title":"Leetcode 0665. Non-decreasing Array","text":"Question Link : https://leetcode.com/problems/non-decreasing-array/ Difficulty: Medium Question Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element. We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2). Example 1: Input: nums = [4,2,3] Output: true Explanation: You could modify the first 4 to 1 to get a non-decreasing array. Example 2: Input: nums = [4,2,1] Output: false Explanation: You can't get a non-decreasing array by modify at most one element. Constraints: n == nums.length 1 <= n <= 104 -105 <= nums[i] <= 105 Solution Test out a few examples to find that there are different cases of where the fix needs to be Code ''' Leetcode 0665. Non-decreasing Array Question Link : https://leetcode.com/problems/non-decreasing-array/ Solution Link : https://tofucode.com/posts/leetcode_0665_non-decreasing-array.html ''' class Solution : def checkPossibility ( self , nums : List [ int ]) -> bool : ''' monotonic-stack - but can skip one when i is at number 2: [4, 2, 3] skip i-1 [1, 4, 2, 5] skip i-1 skip 4 works [3, 4, 2, 5] skip i skip 4 does not work skip 2 works when i = 2, Time : O(n) Space: O(1) ''' skipped = False for i in range ( 1 , len ( nums )): if nums [ i - 1 ] > nums [ i ]: if skipped : return False # skip i: make it the same to keep going if i - 2 >= 0 and nums [ i - 2 ] > nums [ i ]: nums [ i ] = nums [ i - 1 ] # skip i-1 skipped = True return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0665_non-decreasing-array.html","loc":"https://tofucode.com/posts/leetcode_0665_non-decreasing-array.html"},{"title":"Leetcode 0215. Kth Largest Element in an Array","text":"Question Link : https://leetcode.com/problems/kth-largest-element-in-an-array/ Difficulty: Medium Question Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Example 2: Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 Constraints: 1 <= k <= nums.length <= 104 -104 <= nums[i] <= 104 Solution Max heap or quick sort Code ''' Leetcode 0215. Kth Largest Element in an Array Question Link : https://leetcode.com/problems/kth-largest-element-in-an-array/ Solution Link : https://tofucode.com/posts/leetcode_0215_kth-largest-element-in-an-array.html ''' class Solution : def findKthLargest ( self , nums : List [ int ], k : int ) -> int : ''' Simple Solution: sort Time : O(n log n) Space: O(n) ''' n = len ( nums ) return sorted ( nums , reverse = True )[ k - 1 ] class SolutionAlternative1 : def findKthLargest ( self , nums : List [ int ], k : int ) -> int : ''' Use bubble sort to bubble k times to the end Time : O(nk) Space: O(1) ''' for i in range ( k ): for j in range ( len ( nums ) - 1 - i ): if nums [ j ] > nums [ j + 1 ]: nums [ j ], nums [ j + 1 ] = nums [ j + 1 ], nums [ j ] return nums [ - k ] class SolutionAlternative2 : def findKthLargest ( self , nums : List [ int ], k : int ) -> int : ''' Use selection sort to find the biggest k times and swap them to the end n = 6 0 1 2 3 4 5 [3,2,1,5,6,4] for i in index [5, 4]: range (n-1, n-k-1) for j in range(0, i + 1) # inclusive of i find the biggest index swap(biggest index, i) return nums[n-k] Time : O(nk) Space: O(1) ''' n = len ( nums ) for i in range ( n - 1 , n - k - 1 , - 1 ): temp = 0 for j in range ( i + 1 ): if nums [ j ] > nums [ temp ]: temp = j nums [ temp ], nums [ i ] = nums [ i ], nums [ temp ] return nums [ n - k ] class SolutionAlternative3 : def findKthLargest ( self , nums : List [ int ], k : int ) -> int : ''' Use a max heap, where it only storess the k largest elements Time : O(n log k) Space: O(n) ''' pq = PriorityQueue () for i in range ( len ( nums )): num = nums [ i ] pq . put ( num ) if pq . qsize () > k : pq . get () return pq . get () class SolutionAlternative4 : def findKthLargest ( self , nums : List [ int ], k : int ) -> int : ''' Use quick sort: convert the kth largest to smallest Same as https://leetc ode.com/problems/k-closest-points-to-origin/ except here we sort by putting the largest to the start Time : O(n) Space: O(1) ''' l = 0 r = len ( nums ) - 1 self . quicksort ( nums , l , r , k ) return nums [ k - 1 ] def quicksort ( self , nums , l , r , k ): if l < r : p = self . partition ( nums , l , r ) # check which part good = p - l + 1 if k == good : return elif k < good : return self . quicksort ( nums , l , p - 1 , k ) else : return self . quicksort ( nums , p + 1 , r , k - good ) def partition ( self , nums , l , r ): pivotNum = nums [ r ] p = l for i in range ( l , r ): if nums [ i ] > pivotNum : nums [ i ], nums [ p ] = nums [ p ] , nums [ i ] p += 1 # put the pivot in nums [ r ], nums [ p ] = nums [ p ], nums [ r ] return p","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0215_kth-largest-element-in-an-array.html","loc":"https://tofucode.com/posts/leetcode_0215_kth-largest-element-in-an-array.html"},{"title":"Leetcode 2294. Partition Array Such That Maximum Difference Is K","text":"Question Link : https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/ Difficulty: Medium Question You are given an integer array nums and an integer k. You may partition nums into one or more subsequences such that each element in nums appears in exactly one of the subsequences. Return the minimum number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is at most k. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Example 1: Input: nums = [3,6,1,2,5], k = 2 Output: 2 Explanation: We can partition nums into the two subsequences [3,1,2] and [6,5]. The difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2. The difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1. Since two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed. Example 2: Input: nums = [1,2,3], k = 1 Output: 2 Explanation: We can partition nums into the two subsequences [1,2] and [3]. The difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1. The difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0. Since two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3]. Example 3: Input: nums = [2,2,4,5], k = 0 Output: 3 Explanation: We can partition nums into the three subsequences [2,2], [4], and [5]. The difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0. The difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0. The difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0. Since three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed. Constraints: 1 <= nums.length <= 105 0 <= nums[i] <= 105 0 <= k <= 105 Solution To create the min partition, we first sort it and then go through and group the closet ones. Also +1 for the ending partition Code ''' Leetcode 2294. Partition Array Such That Maximum Difference Is K Question Link : https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/ Solution Link : https://tofucode.com/posts/leetcode_2294_partition-array-such-that-maximum-difference-is-k.html ''' class Solution : def partitionArray ( self , nums : List [ int ], k : int ) -> int : ''' [1,2,3,5,6] 1. sort it 2. loop through and update count when > 2 Time : O(nlogn) Space: O(n) ''' if not nums : return 0 nums = sorted ( nums ) result = 0 last = nums [ 0 ] for num in nums : if num - last > k : result += 1 last = num # +1 for the last partition return result + 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2294_partition-array-such-that-maximum-difference-is-k.html","loc":"https://tofucode.com/posts/leetcode_2294_partition-array-such-that-maximum-difference-is-k.html"},{"title":"Leetcode 0005. Longest Palindromic Substring","text":"Question Link : https://leetcode.com/problems/longest-palindromic-substring/ Difficulty: Medium Question Given a string s, return the longest palindromic substring in s. Example 1: Input: s = \"babad\" Output: \"bab\" Explanation: \"aba\" is also a valid answer. Example 2: Input: s = \"cbbd\" Output: \"bb\" Constraints: 1 <= s.length <= 1000 s consist of only digits and English letters. Solution For each char expand from the center, make note that we need to check both odd and even cases Code ''' Leetcode 0005. Longest Palindromic Substring Question Link : https://leetcode.com/problems/longest-palindromic-substring/ Solution Link : https://tofucode.com/posts/leetcode_0005_longest-palindromic-substring.html ''' class Solution : def longestPalindrome ( self , s : str ) -> str : ''' expand from center 0 123 b aba d <-b-> aba Time : O(n&#94;2) Space: O(1) ''' result = '' for i in range ( len ( s )): odd = self . expandPalindrome ( s , i , i ) if len ( odd ) > len ( result ): result = odd even = self . expandPalindrome ( s , i , i + 1 ) if len ( even ) > len ( result ): result = even return result def expandPalindrome ( self , s , l , r ): while l >= 0 and r < len ( s ): if s [ l ] != s [ r ]: break l -= 1 r += 1 return s [ l + 1 : r ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0005_longest-palindromic-substring.html","loc":"https://tofucode.com/posts/leetcode_0005_longest-palindromic-substring.html"},{"title":"Leetcode 2284. Sender With Largest Word Count","text":"Question Link : https://leetcode.com/problems/sender-with-largest-word-count/ Difficulty: Medium Question You have a chat log of n messages. You are given two string arrays messages and senders where messages[i] is a message sent by senders[i]. A message is list of words that are separated by a single space with no leading or trailing spaces. The word count of a sender is the total number of words sent by the sender. Note that a sender may send more than one message. Return the sender with the largest word count. If there is more than one sender with the largest word count, return the one with the lexicographically largest name. Note: Uppercase letters come before lowercase letters in lexicographical order. \"Alice\" and \"alice\" are distinct. Example 1: Input: messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"], senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"] Output: \"Alice\" Explanation: Alice sends a total of 2 + 3 = 5 words. userTwo sends a total of 2 words. userThree sends a total of 3 words. Since Alice has the largest word count, we return \"Alice\". Example 2: Input: messages = [\"How is leetcode for everyone\",\"Leetcode is useful for practice\"], senders = [\"Bob\",\"Charlie\"] Output: \"Charlie\" Explanation: Bob sends a total of 5 words. Charlie sends a total of 5 words. Since there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie. Constraints: n == messages.length == senders.length 1 <= n <= 104 1 <= messages[i].length <= 100 1 <= senders[i].length <= 10 messages[i] consists of uppercase and lowercase English letters and ' '. All the words in messages[i] are separated by a single space. messages[i] does not have leading or trailing spaces. senders[i] consists of uppercase and lowercase English letters only. Solution Use a hashmap to count for each person, than go through the map to find the max Code ''' Leetcode 2284. Sender With Largest Word Count Question Link : https://leetcode.com/problems/sender-with-largest-word-count/ Solution Link : https://tofucode.com/posts/leetcode_2284_sender-with-largest-word-count.html ''' class Solution : def largestWordCount ( self , messages : List [ str ], senders : List [ str ]) -> str : ''' messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"] senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"] {} # sender -> message count loop through map to find largest sender with max count Time: O(n) Space: O(n) ''' counts = {} # sender -> message count for i in range ( len ( messages )): message = messages [ i ] sender = senders [ i ] counts [ sender ] = counts . get ( sender , 0 ) + self . countWords ( message ) result = \"\" max_count = 0 for sender , count in counts . items (): if count > max_count or ( count == max_count and sender > result ): result = sender max_count = count return result def countWords ( self , message ): return len ( message . split ( ' ' ))","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2284_sender-with-largest-word-count.html","loc":"https://tofucode.com/posts/leetcode_2284_sender-with-largest-word-count.html"},{"title":"Leetcode 0167. Two Sum II - Input Array Is Sorted","text":"Question Link : https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ Difficulty: Medium Question Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. Example 1: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]. Example 2: Input: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]. Example 3: Input: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2]. Constraints: 2 <= numbers.length <= 3 * 104 -1000 <= numbers[i] <= 1000 numbers is sorted in non-decreasing order. -1000 <= target <= 1000 The tests are generated such that there is exactly one solution. Solution Since the numbers are sorted we can start two pointers from each end and move inwards till the sum is the target Code ''' Leetcode 0167. Two Sum II - Input Array Is Sorted Question Link : https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ Solution Link : https://tofucode.com/posts/leetcode_0167_two-sum-ii-input-array-is-sorted.html ''' class Solution : def twoSum ( self , numbers : List [ int ], target : int ) -> List [ int ]: ''' Either move i+1 or move j-1 till the sum is target Time : O(n) Space: O(1) ''' i = 0 j = len ( numbers ) - 1 while i < j : s = numbers [ i ] + numbers [ j ] if s == target : return [ i + 1 , j + 1 ] elif s < target : i += 1 else : j -= 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0167_two-sum-ii-input-array-is-sorted.html","loc":"https://tofucode.com/posts/leetcode_0167_two-sum-ii-input-array-is-sorted.html"},{"title":"Leetcode 2283. Check if Number Has Equal Digit Count and Digit Value","text":"Question Link : https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/ Difficulty: Easy Question You are given a 0-indexed string num of length n consisting of digits. Return true if for every index i in the range 0 <= i < n, the digit i occurs num[i] times in num, otherwise return false. Example 1: Input: num = \"1210\" Output: true Explanation: num[0] = '1'. The digit 0 occurs once in num. num[1] = '2'. The digit 1 occurs twice in num. num[2] = '1'. The digit 2 occurs once in num. num[3] = '0'. The digit 3 occurs zero times in num. The condition holds true for every index in \"1210\", so return true. Example 2: Input: num = \"030\" Output: false Explanation: num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num. num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num. num[2] = '0'. The digit 2 occurs zero times in num. The indices 0 and 1 both violate the condition, so return false. Constraints: n == num.length 1 <= n <= 10 num consists of digits. Solution First loops counts each digit, second loop checks if the condition is met Code ''' Leetcode 2283. Check if Number Has Equal Digit Count and Digit Value Question Link : https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/ Solution Link : https://tofucode.com/posts/leetcode_2283_check-if-number-has-equal-digit-count-and-digit-value.html ''' class Solution : def digitCount ( self , num : str ) -> bool : ''' Use a Counter and 2 loops Time : O(n) Space: O(n) ''' count = {} # digit => count for i in range ( len ( num )): n = int ( num [ i ]) count [ n ] = count . get ( n , 0 ) + 1 for i in range ( len ( num )): n = int ( num [ i ]) if count . get ( i , 0 ) != n : return False return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2283_check-if-number-has-equal-digit-count-and-digit-value.html","loc":"https://tofucode.com/posts/leetcode_2283_check-if-number-has-equal-digit-count-and-digit-value.html"},{"title":"Leetcode 2287. Rearrange Characters to Make Target String","text":"Question Link : https://leetcode.com/problems/rearrange-characters-to-make-target-string/ Difficulty: Easy Question You are given two 0-indexed strings s and target. You can take some letters from s and rearrange them to form new strings. Return the maximum number of copies of target that can be formed by taking letters from s and rearranging them. Example 1: Input: s = \"ilovecodingonleetcode\", target = \"code\" Output: 2 Explanation: For the first copy of \"code\", take the letters at indices 4, 5, 6, and 7. For the second copy of \"code\", take the letters at indices 17, 18, 19, and 20. The strings that are formed are \"ecod\" and \"code\" which can both be rearranged into \"code\". We can make at most two copies of \"code\", so we return 2. Example 2: Input: s = \"abcba\", target = \"abc\" Output: 1 Explanation: We can make one copy of \"abc\" by taking the letters at indices 0, 1, and 2. We can make at most one copy of \"abc\", so we return 1. Note that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of \"abc\". Example 3: Input: s = \"abbaccaddaeea\", target = \"aaaaa\" Output: 1 Explanation: We can make one copy of \"aaaaa\" by taking the letters at indices 0, 3, 6, 9, and 12. We can make at most one copy of \"aaaaa\", so we return 1. Constraints: 1 <= s.length <= 100 1 <= target.length <= 10 s and target consist of lowercase English letters. Solution Count the chars that is given and needed, do a division to find the possible copies Code ''' Leetcode 2287. Rearrange Characters to Make Target String Question Link : https://leetcode.com/problems/rearrange-characters-to-make-target-string/ Solution Link : https://tofucode.com/posts/leetcode_2287_rearrange-characters-to-make-target-string.html ''' class Solution : def rearrangeCharacters ( self , s : str , target : str ) -> int : ''' 1. Count how many times each char is given 2. Count how many times each char is needed 3. Do a division to see how many copies each char can provide 4. Take the min which is the bottleneck Time : O(1) s and target length is constant Space: O(1) ''' given_counts = [ 0 ] * 26 # given: count of a b c ... for c in s : i = ord ( c ) - ord ( 'a' ) given_counts [ i ] += 1 need_counts = [ 0 ] * 26 # needed: count of a b c ... for c in target : i = ord ( c ) - ord ( 'a' ) need_counts [ i ] += 1 copies = [] # for all the needed chars, how many copies each char can provide for i in range ( len ( need_counts )): if need_counts [ i ] != 0 : copies . append ( given_counts [ i ] // need_counts [ i ]) return min ( copies )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2287_rearrange-characters-to-make-target-string.html","loc":"https://tofucode.com/posts/leetcode_2287_rearrange-characters-to-make-target-string.html"},{"title":"Leetcode 2293. Min Max Game","text":"Question Link : https://leetcode.com/problems/min-max-game/ Difficulty: Easy Question You are given a 0-indexed integer array nums whose length is a power of 2. Apply the following algorithm on nums: Let n be the length of nums. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n / 2. For every even index i where 0 <= i < n / 2, assign the value of newNums[i] as min(nums[2 * i], nums[2 * i + 1]). For every odd index i where 0 <= i < n / 2, assign the value of newNums[i] as max(nums[2 * i], nums[2 * i + 1]). Replace the array nums with newNums. Repeat the entire process starting from step 1. Return the last number that remains in nums after applying the algorithm. Example 1: Input: nums = [1,3,5,2,4,8,2,2] Output: 1 Explanation: The following arrays are the results of applying the algorithm repeatedly. First: nums = [1,5,4,2] Second: nums = [1,4] Third: nums = [1] 1 is the last remaining number, so we return 1. Example 2: Input: nums = [3] Output: 3 Explanation: 3 is already the last remaining number, so we return 3. Constraints: 1 <= nums.length <= 1024 1 <= nums[i] <= 109 nums.length is a power of 2. Solution Write a recursion based on the given rules. Code ''' Leetcode 2293. Min Max Game Question Link : https://leetcode.com/problems/min-max-game/ Solution Link : https://tofucode.com/posts/leetcode_2293_min-max-game.html ''' class Solution : def minMaxGame ( self , nums : List [ int ]) -> int : if len ( nums ) == 1 : return nums [ 0 ] half = len ( nums ) // 2 temp = [ None ] * half for i in range ( half ): if i % 2 == 0 : temp [ i ] = min ( nums [ 2 * i ], nums [ 2 * i + 1 ]) else : temp [ i ] = max ( nums [ 2 * i ], nums [ 2 * i + 1 ]) return self . minMaxGame ( temp )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2293_min-max-game.html","loc":"https://tofucode.com/posts/leetcode_2293_min-max-game.html"},{"title":"Leetcode 0647. Palindromic Substrings","text":"Question Link : https://leetcode.com/problems/palindromic-substrings/ Difficulty: Medium Question Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string. Example 1: Input: s = \"abc\" Output: 3 Explanation: Three palindromic strings: \"a\", \"b\", \"c\". Example 2: Input: s = \"aaa\" Output: 6 Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". Constraints: 1 <= s.length <= 1000 s consists of lowercase English letters. Solution This is a palindrome problem where we need to use center expansion for each char in the string, and check ood and even cases of palindromes Code ''' Leetcode 0647. Palindromic Substrings Question Link : https://leetcode.com/problems/palindromic-substrings/ Solution Link : https://tofucode.com/posts/leetcode_0647_palindromic-substrings.html ''' class Solution : def countSubstrings ( self , s : str ) -> int : ''' Go through every char and expand from the center Need to check odd and even cases of palindromes Time : O(n&#94;2) Space: O(1) ''' count = 0 for i in range ( len ( s )): count += self . countPalindrome ( s , i , i ) count += self . countPalindrome ( s , i , i + 1 ) return count def countPalindrome ( self , s , l , r ): ''' returns Palindrome count starting at l, r index''' start = l while l >= 0 and r <= len ( s ) - 1 : if s [ l ] == s [ r ]: l -= 1 r += 1 else : break return start - l","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0647_palindromic-substrings.html","loc":"https://tofucode.com/posts/leetcode_0647_palindromic-substrings.html"},{"title":"Leetcode 0173. Binary Search Tree Iterator","text":"Question Link : https://leetcode.com/problems/binary-search-tree-iterator/ Difficulty: Medium Question Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false. int next() Moves the pointer to the right, then returns the number at the pointer. Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. Example 1: Input [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3 bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return False Constraints: The number of nodes in the tree is in the range [1, 105]. 0 <= Node.val <= 106 At most 105 calls will be made to hasNext, and next. Follow up: Could you implement next() and hasNext() to run in average O(1) time and use O(h) memory, where h is the height of the tree? Solution Trivial solution is to use a stack and traverse the whole tree in init Best solution is to use a stack to only always store the left subtree Code ''' Leetcode 0173. Binary Search Tree Iterator Question Link : https://leetcode.com/problems/binary-search-tree-iterator/ Solution Link : https://tofucode.com/posts/leetcode_0173_binary-search-tree-iterator.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class BSTIterator : ''' Use in order traversal to put everything into a stack first Time and space for next: Time : O(1) Space: O(n) ''' def __init__ ( self , root : Optional [ TreeNode ]): self . stack = [] self . idx = 0 self . traverse ( root ) def next ( self ) -> int : result = self . stack [ self . idx ] self . idx += 1 return result def hasNext ( self ) -> bool : return self . idx < len ( self . stack ) def traverse ( self , node ): if not node : return self . traverse ( node . left ) self . stack . append ( node . val ) self . traverse ( node . right ) class BSTIteratorImproved1 : ''' stack only stores the current left tree [7 3] [7] # next [15, 9] # next [15] # next [20] # next Time : O(1) Space: O(h) ''' def __init__ ( self , root : Optional [ TreeNode ]): # store in reverse so we can pop() self . stack = [] self . traverseLeft ( root ) def next ( self ) -> int : node = self . stack . pop () if node . right : self . traverseLeft ( node . right ) return node . val def hasNext ( self ) -> bool : return len ( self . stack ) > 0 def traverseLeft ( self , node ): if not node : return self . stack . append ( node ) self . traverseLeft ( node . left ) # Your BSTIterator object will be instantiated and called as such: # obj = BSTIterator(root) # param_1 = obj.next() # param_2 = obj.hasNext()","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0173_binary-search-tree-iterator.html","loc":"https://tofucode.com/posts/leetcode_0173_binary-search-tree-iterator.html"},{"title":"Leetcode 0897. Increasing Order Search Tree","text":"Question Link : https://leetcode.com/problems/increasing-order-search-tree/ Difficulty: Easy Question Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child. Example 1: Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9] Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] Example 2: Input: root = [5,1,7] Output: [1,null,5,null,7] Constraints: The number of nodes in the given tree will be in the range [1, 100]. 0 <= Node.val <= 1000 Solution Use the same left traversal as the iterator problem and link the right pointer, and set the left pointer to None Code ''' Leetcode 0897. Increasing Order Search Tree Question Link : https://leetcode.com/problems/increasing-order-search-tree/ Solution Link : https://tofucode.com/posts/leetcode_0897_increasing-order-search-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def increasingBST ( self , root : TreeNode ) -> TreeNode : ''' Time : O(n) Space: O(h) ''' if not root : return # store in reverse so we can pop() self . stack = [] self . traverseLeft ( root ) last = self . next () new_head = last while self . hasNext (): node = self . next () last . right = node node . left = None last = node return new_head def next ( self ): node = self . stack . pop () if node . right : self . traverseLeft ( node . right ) return node def hasNext ( self ) -> bool : return len ( self . stack ) > 0 def traverseLeft ( self , node ): if not node : return self . stack . append ( node ) self . traverseLeft ( node . left )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0897_increasing-order-search-tree.html","loc":"https://tofucode.com/posts/leetcode_0897_increasing-order-search-tree.html"},{"title":"Leetcode 0700. Search in a Binary Search Tree","text":"Question Link : https://leetcode.com/problems/search-in-a-binary-search-tree/ Difficulty: Easy Question You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null. Example 1: Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Example 2: Input: root = [4,2,7,1,3], val = 5 Output: [] Constraints: The number of nodes in the tree is in the range [1, 5000]. 1 <= Node.val <= 107 root is a binary search tree. 1 <= val <= 107 Solution Recursive or Iterative Code ''' Leetcode 0700. Search in a Binary Search Tree Question Link : https://leetcode.com/problems/search-in-a-binary-search-tree/ Solution Link : https://tofucode.com/posts/leetcode_0700_search-in-a-binary-search-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def searchBST ( self , root : Optional [ TreeNode ], val : int ) -> Optional [ TreeNode ]: ''' Recursive Time : O(log n) Space: O(1) ''' if not root : return if val == root . val : return root elif val < root . val : return self . searchBST ( root . left , val ) else : return self . searchBST ( root . right , val ) class SolutionAlternative1 : def searchBST ( self , root : Optional [ TreeNode ], val : int ) -> Optional [ TreeNode ]: ''' Iterative Time : O(log n) Space: O(1) ''' node = root while node : if node . val == val : return node elif node . val < val : node = node . right else : node = node . left return None","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0700_search-in-a-binary-search-tree.html","loc":"https://tofucode.com/posts/leetcode_0700_search-in-a-binary-search-tree.html"},{"title":"Leetcode 0289. Game of Life","text":"Question Link : https://leetcode.com/problems/game-of-life/ Difficulty: Medium Question According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\" The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state. Example 1: Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Example 2: Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]] Constraints: m == board.length n == board[i].length 1 <= m, n <= 25 board[i][j] is 0 or 1. Follow up: Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems? Solution With Extra space, we can check all cells based on the original board With no extra space, we can use different numbers to encode more info Code ''' Leetcode 0289. Game of Life Question Link : https://leetcode.com/problems/game-of-life/ Solution Link : https://tofucode.com/posts/leetcode_0289_game-of-life.html ''' class Solution : def gameOfLife ( self , board : List [ List [ int ]]) -> None : ''' With another board: go through each one and calculated he updated status Time : O(mn) Space: O(mn) ''' if len ( board ) == 0 : return rows = len ( board ) cols = len ( board [ 0 ]) if rows else 0 temp = [[ 0 ] * cols for x in range ( rows )] for i in range ( rows ): for j in range ( cols ): temp [ i ][ j ] = self . getState ( i , j , board , rows , cols ) # copy the board over board [:] = temp [:] def getState ( self , i , j , board , rows , cols ): offsets = [( - 1 , - 1 ), ( - 1 , 0 ), ( - 1 , 1 ), ( 0 , - 1 ), ( 0 , 1 ), ( 1 , - 1 ), ( 1 , 0 ), ( 1 , 1 )] live = 0 cell = board [ i ][ j ] for offset in offsets : x = i + offset [ 0 ] y = j + offset [ 1 ] if 0 <= x < rows and 0 <= y < cols : if board [ x ][ y ] == 1 : live += 1 # Any live cell with fewer than two live neighbors dies, as if caused by under-population. if live < 2 and cell == 1 : return 0 # Any live cell with two or three live neighbors lives on to the next generation. if ( live == 2 or live == 3 ) and cell == 1 : return 1 # Any live cell with more than three live neighbors dies, as if by over-population.. if live > 3 and cell == 1 : return 0 # Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. if cell == 0 and live == 3 : return 1 return cell class SolutionFollowUp1 : def gameOfLife ( self , board : List [ List [ int ]]) -> None : ''' Follow up: Could you solve it in-place? To do it in place: * need to save a intermediate state * later run another loop to turn it to 1, 0 End up Alive: 1: live 2: dead -> live End up Dead: 0: dead -1: live -> dead Time : O(mn) Space: O(1) ''' if len ( board ) == 0 : return rows = len ( board ) cols = len ( board [ 0 ]) if rows else 0 # update with intermediate state for i in range ( rows ): for j in range ( cols ): board [ i ][ j ] = self . getState ( board , i , j , rows , cols ) # process another loop to write 1, 0 based on state info for i in range ( rows ): for j in range ( cols ): if board [ i ][ j ] >= 1 : board [ i ][ j ] = 1 else : board [ i ][ j ] = 0 def getState ( self , board , i , j , rows , cols ): offsets = [( - 1 , - 1 ), ( - 1 , 0 ), ( - 1 , 1 ), ( 0 , - 1 ), ( 0 , 1 ), ( 1 , - 1 ), ( 1 , 0 ), ( 1 , 1 )] live = 0 cell = board [ i ][ j ] for offset in offsets : x = i + offset [ 0 ] y = j + offset [ 1 ] if 0 <= x < rows and 0 <= y < cols : if self . wasAlive ( board [ x ][ y ]): live += 1 # Any live cell with fewer than two live neighbors dies, as if caused by under-population. if live < 2 and cell == 1 : return - 1 # live -> dead # Any live cell with two or three live neighbors lives on to the next generation. if ( live == 2 or live == 3 ) and cell == 1 : return 1 # Any live cell with more than three live neighbors dies, as if by over-population.. if live > 3 and cell == 1 : return - 1 # live -> dead # Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. if cell == 0 and live == 3 : return 2 # dead -> live return cell def wasAlive ( self , i ): return i == 1 or i == - 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0289_game-of-life.html","loc":"https://tofucode.com/posts/leetcode_0289_game-of-life.html"},{"title":"Leetcode 0347. Top K Frequent Elements","text":"Question Link : https://leetcode.com/problems/top-k-frequent-elements/ Difficulty: Medium Question Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 <= nums.length <= 105 k is in the range [1, the number of unique elements in the array]. It is guaranteed that the answer is unique. Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size. Solution First get a number to count map, then get the count to frequency map, last is to take the top k from the frequency map Code ''' Leetcode 0347. Top K Frequent Elements Question Link : https://leetcode.com/problems/top-k-frequent-elements/ Solution Link : https://tofucode.com/posts/leetcode_0347_top-k-frequent-elements.html ''' class Solution : def topKFrequent ( self , nums : List [ int ], k : int ) -> List [ int ]: ''' freq: count -> number list Sort and take the top K Time : O(n) + O(m logm) m is the number of frequencies Space: O(n) ''' counts = {} # number -> count freq = {} # count -> number list for n in nums : counts [ n ] = counts . get ( n , 0 ) + 1 for n , v in counts . items (): freq [ v ] = freq . get ( v , []) + [ n ] # sorted by requency, take the highest ones first occur_list = sorted ( freq . keys (), reverse = True ) result = [] while len ( result ) < k : num_list = freq . get ( occur_list . pop ( 0 )) result += num_list return result [: k ] class SolutionImproved1 : def topKFrequent ( self , nums : List [ int ], k : int ) -> List [ int ]: ''' freq: count -> number list Skip sort: find the Max freq, take that, and then keep try -1 (like bucket sort) Time : O(n) Space: O(n) ''' counts = {} # number -> count freq = {} # count -> number list for n in nums : counts [ n ] = counts . get ( n , 0 ) + 1 for n , v in counts . items (): freq [ v ] = freq . get ( v , []) + [ n ] occur = max ( freq . keys ()) result = [] while len ( result ) < k : if occur in freq : num_list = freq . pop ( occur ) result += num_list occur -= 1 return result [: k ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0347_top-k-frequent-elements.html","loc":"https://tofucode.com/posts/leetcode_0347_top-k-frequent-elements.html"},{"title":"Leetcode 0682. Baseball Game","text":"Question Link : https://leetcode.com/problems/baseball-game/ Difficulty: Easy Question You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds' scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following: An integer x - Record a new score of x. \"+\" - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. \"D\" - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. \"C\" - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. Example 1: Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"] Output: 30 Explanation: \"5\" - Add 5 to the record, record is now [5]. \"2\" - Add 2 to the record, record is now [5, 2]. \"C\" - Invalidate and remove the previous score, record is now [5]. \"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10]. \"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15]. The total sum is 5 + 10 + 15 = 30. Example 2: Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"] Output: 27 Explanation: \"5\" - Add 5 to the record, record is now [5]. \"-2\" - Add -2 to the record, record is now [5, -2]. \"4\" - Add 4 to the record, record is now [5, -2, 4]. \"C\" - Invalidate and remove the previous score, record is now [5, -2]. \"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4]. \"9\" - Add 9 to the record, record is now [5, -2, -4, 9]. \"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5]. \"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14]. The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27. Example 3: Input: ops = [\"1\"] Output: 1 Constraints: 1 <= ops.length <= 1000 ops[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104]. For operation \"+\", there will always be at least two previous scores on the record. For operations \"C\" and \"D\", there will always be at least one previous score on the record. Solution Note that isdigit() does not check for negative numbers so either do a left strip first or add number in the else statement Code ''' Leetcode 0682. Baseball Game Question Link : https://leetcode.com/problems/baseball-game/ Solution Link : https://tofucode.com/posts/leetcode_0682_baseball-game.html ''' class Solution : def calPoints ( self , ops : List [ str ]) -> int : result = [] for x in ops : if x . lstrip ( \"-\" ) . isdigit (): result . append ( int ( x )) elif x == \"+\" : result . append ( result [ - 1 ] + result [ - 2 ]) elif x == \"D\" : result . append ( result [ - 1 ] * 2 ) elif x == \"C\" : result . pop () return sum ( result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0682_baseball-game.html","loc":"https://tofucode.com/posts/leetcode_0682_baseball-game.html"},{"title":"Leetcode 0011. Container With Most Water","text":"Question Link : https://leetcode.com/problems/container-with-most-water/ Difficulty: Medium Question You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container. Example 1: Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example 2: Input: height = [1,1] Output: 1 Constraints: n == height.length 2 <= n <= 105 0 <= height[i] <= 104 Solution Use two pointers from start and end and go towards the middle. Always move the shorter one of the two since that is the bottleneck Code ''' Leetcode 0011. Container With Most Water Question Link : https://leetcode.com/problems/container-with-most-water/ Solution Link : https://tofucode.com/posts/leetcode_0011_container-with-most-water.html ''' class Solution : def maxArea ( self , height : List [ int ]) -> int : ''' Time : O(n) Space: O(1) ''' a = 0 b = len ( height ) - 1 result = 0 while a < b : current = min ( height [ a ], height [ b ]) * ( b - a ) result = max ( result , current ) if height [ a ] < height [ b ]: a += 1 else : b -= 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0011_container-with-most-water.html","loc":"https://tofucode.com/posts/leetcode_0011_container-with-most-water.html"},{"title":"Leetcode 0344. Reverse String","text":"Question Link : https://leetcode.com/problems/reverse-string/ Difficulty: Easy Question Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. Example 1: Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] Example 2: Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] Constraints: 1 <= s.length <= 105 s[i] is a printable ascii character. Solution Use 2 pointers from start and end and swap Code ''' Leetcode 0344. Reverse String Question Link : https://leetcode.com/problems/reverse-string/ Solution Link : https://tofucode.com/posts/leetcode_0344_reverse-string.html ''' class Solution : def reverseString ( self , s : List [ str ]) -> None : \"\"\" Do not return anything, modify s in-place instead. \"\"\" if not s : return i = 0 j = len ( s ) - 1 while i < j : s [ i ], s [ j ] = s [ j ], s [ i ] i += 1 j -= 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0344_reverse-string.html","loc":"https://tofucode.com/posts/leetcode_0344_reverse-string.html"},{"title":"Leetcode 0074. Search a 2D Matrix","text":"Question Link : https://leetcode.com/problems/search-a-2d-matrix/ Difficulty: Medium Question Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: true Example 2: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output: false Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 100 -104 <= matrix[i][j], target <= 104 Solution Use 2x binary search with a bisect_left, note that the first one for the row position we use everthing of the last column Code ''' Leetcode 0074. Search a 2D Matrix Question Link : https://leetcode.com/problems/search-a-2d-matrix/ Solution Link : https://tofucode.com/posts/leetcode_0074_search-a-2d-matrix.html ''' class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : ''' 2x Binary search Time : O(log m + log n) Space: O(1) ''' if not matrix or not matrix [ 0 ]: return False # use the right most col as we are doing bisect_left row = self . binarySearch ([ x [ - 1 ] for x in matrix ], target ) if row == len ( matrix ): return False col = self . binarySearch ( matrix [ row ], target ) if col == len ( matrix [ row ]): return False return matrix [ row ][ col ] == target def binarySearch ( self , nums , target ): ''' bisect_left: returns the left index that target would go ''' l = 0 r = len ( nums ) while l < r : mid = ( l + r ) // 2 if nums [ mid ] < target : l = mid + 1 else : r = mid return l","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0074_search-a-2d-matrix.html","loc":"https://tofucode.com/posts/leetcode_0074_search-a-2d-matrix.html"},{"title":"Leetcode 0881. Boats to Save People","text":"Question Link : https://leetcode.com/problems/boats-to-save-people/ Difficulty: Medium Question You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person. Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Constraints: 1 <= people.length <= 5 * 104 1 <= people[i] <= limit <= 3 * 104 Solution First sort the people by weight Since each boat can at most carry 2 people, we can greedily try to pair people from the lightest and heaviest using two pointers Code ''' Leetcode 0881. Boats to Save People Question Link : https://leetcode.com/problems/boats-to-save-people/ Solution Link : https://tofucode.com/posts/leetcode_0881_boats-to-save-people.html ''' class Solution : def numRescueBoats ( self , people : List [ int ], limit : int ) -> int : people = sorted ( people ) result = 0 i = 0 j = len ( people ) - 1 while i <= j : if people [ i ] + people [ j ] <= limit : i += 1 j -= 1 else : j -= 1 result += 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0881_boats-to-save-people.html","loc":"https://tofucode.com/posts/leetcode_0881_boats-to-save-people.html"},{"title":"Leetcode 0991. Broken Calculator","text":"Question Link : https://leetcode.com/problems/broken-calculator/ Difficulty: Medium Question There is a broken calculator that has the integer startValue on its display initially. In one operation, you can: multiply the number on display by 2, or subtract 1 from the number on display. Given two integers startValue and target, return the minimum number of operations needed to display target on the calculator. Example 1: Input: startValue = 2, target = 3 Output: 2 Explanation: Use double operation and then decrement operation {2 -> 4 -> 3}. Example 2: Input: startValue = 5, target = 8 Output: 2 Explanation: Use decrement and then double {5 -> 4 -> 8}. Example 3: Input: startValue = 3, target = 10 Output: 3 Explanation: Use double, decrement and double {3 -> 6 -> 5 -> 10}. Constraints: 1 <= x, y <= 109 Solution Because there are only 2 operations, and given the odd even of a number, only 1 operation can be take if we work backwards Think in reverse since it will reveal the single correct path Code ''' Leetcode 0991. Broken Calculator Question Link : https://leetcode.com/problems/broken-calculator/ Solution Link : https://tofucode.com/posts/leetcode_0991_broken-calculator.html ''' class Solution : def brokenCalc ( self , startValue : int , target : int ) -> int : result = 0 while target > startValue : # // 2 when we can, otherwise +1 if target % 2 == 0 : target //= 2 else : target += 1 result += 1 # the remaining diff is made up with the -1 operation result += startValue - target return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0991_broken-calculator.html","loc":"https://tofucode.com/posts/leetcode_0991_broken-calculator.html"},{"title":"Leetcode 0946. Validate Stack Sequences","text":"Question Link : https://leetcode.com/problems/validate-stack-sequences/ Difficulty: Medium Question Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise. Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. Constraints: 1 <= pushed.length <= 1000 0 <= pushed[i] <= 1000 All the elements of pushed are unique. popped.length == pushed.length popped is a permutation of pushed. Solution Simulated keep pushing into a stack Whenever there a chance to pop based on popped, greedily pop that Code ''' Leetcode 0946. Validate Stack Sequences Question Link : https://leetcode.com/problems/validate-stack-sequences/ Solution Link : https://tofucode.com/posts/leetcode_0946_validate-stack-sequences.html ''' class Solution : def validateStackSequences ( self , pushed : List [ int ], popped : List [ int ]) -> bool : ''' Whenever there's one that can be popped, try to keep popping [1,2,3,4,5] [4,5,3,2,1] ''' idx = 0 # idx of popped stack = [] for x in pushed : stack . append ( x ) while stack and idx < len ( popped ) and stack [ - 1 ] == popped [ idx ]: stack . pop () idx += 1 # valid if went through all of popped return idx == len ( popped )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0946_validate-stack-sequences.html","loc":"https://tofucode.com/posts/leetcode_0946_validate-stack-sequences.html"},{"title":"Leetcode 1249. Minimum Remove to Make Valid Parentheses","text":"Question Link : https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/ Difficulty: Medium Question Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Example 1: Input: s = \"lee(t(c)o)de)\" Output: \"lee(t(c)o)de\" Explanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted. Example 2: Input: s = \"a)b(c)d\" Output: \"ab(c)d\" Example 3: Input: s = \"))((\" Output: \"\" Explanation: An empty string is also valid. Constraints: 1 <= s.length <= 105 s[i] is either'(' , ')', or lowercase English letter. Solution Use a stack to cancel out the parentheses, the ones that are left are the invalid ones We run another loop through the stack to strip out the invalid ones from the string Code ''' Leetcode 1249. Minimum Remove to Make Valid Parentheses Question Link : https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/ Solution Link : https://tofucode.com/posts/leetcode_1249_minimum-remove-to-make-valid-parentheses.html ''' class Solution : def minRemoveToMakeValid ( self , s : str ) -> str : ''' lee(t(c)o)de) stack: ( (( ( Nothing ) remove what ever is left Time : O(n) Space: O(n) ''' stack = [] for i in range ( len ( s )): c = s [ i ] if c == '(' or c == ')' : if stack : last = stack [ - 1 ] if last [ 1 ] == '(' and c == ')' : stack . pop () else : stack . append (( i , c )) else : stack . append (( i , c )) # remove the invalid ones result = list ( s ) for i , c in stack : result [ i ] = '' return '' . join ( result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1249_minimum-remove-to-make-valid-parentheses.html","loc":"https://tofucode.com/posts/leetcode_1249_minimum-remove-to-make-valid-parentheses.html"},{"title":"Leetcode 0020. Valid Parentheses","text":"Question Link : https://leetcode.com/problems/valid-parentheses/ Difficulty: Easy Question Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Example 1: Input: s = \"()\" Output: true Example 2: Input: s = \"()[]{}\" Output: true Example 3: Input: s = \"(]\" Output: false Constraints: 1 <= s.length <= 104 s consists of parentheses only '()[]{}'. Solution Use a stack to match the parentheses Code ''' Leetcode 0020. Valid Parentheses Question Link : https://leetcode.com/problems/valid-parentheses/ Solution Link : https://tofucode.com/posts/leetcode_0020_valid-parentheses.html ''' class Solution : def isValid ( self , s : str ) -> bool : ''' Time : O(n) Space: O(n) ''' matches = { \"(\" : \")\" , \"{\" : \"}\" , \"[\" : \"]\" } stack = [] for c in s : if len ( stack ) == 0 or matches . get ( stack [ - 1 ]) != c : stack . append ( c ) else : stack . pop () return len ( stack ) == 0","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0020_valid-parentheses.html","loc":"https://tofucode.com/posts/leetcode_0020_valid-parentheses.html"},{"title":"Leetcode 0138. Copy List with Random Pointer","text":"Question Link : https://leetcode.com/problems/copy-list-with-random-pointer/ Difficulty: Medium Question A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list. Example 1: Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]] Output: [[7,null],[13,0],[11,4],[10,2],[1,0]] Example 2: Input: head = [[1,1],[2,1]] Output: [[1,1],[2,1]] Example 3: Input: head = [[3,null],[3,0],[3,null]] Output: [[3,null],[3,0],[3,null]] Constraints: 0 <= n <= 1000 -104 <= Node.val <= 104 Node.random is null or is pointing to some node in the linked list. Solution This is essentially a list iteration with a bit of extra work to deal with the random pointers with a hashmap Alternatively recursive solution can also be very clean Code ''' Leetcode 0138. Copy List with Random Pointer Question Link : https://leetcode.com/problems/copy-list-with-random-pointer/ Solution Link : https://tofucode.com/posts/leetcode_0138_copy-list-with-random-pointer.html ''' \"\"\" # Definition for a Node. class Node: def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None): self.val = int(x) self.next = next self.random = random \"\"\" class Solution : def copyRandomList ( self , head : 'Optional[Node]' ) -> 'Optional[Node]' : ''' list iteration with a hashmap old pointers -> new node Time : O(n) space: O(n) ''' pointers = {} # old pointers -> new node dummy = Node ( 0 ) p = head new_p = dummy while p : # get or create new node pointers [ p ] = pointers . get ( p , Node ( p . val )) # if there is random: get or create random r = p . random if r : pointers [ r ] = pointers . get ( r , Node ( r . val )) pointers [ p ] . random = pointers [ r ] # set up the new random node # move both pointers new_p . next = pointers [ p ] new_p = new_p . next p = p . next return dummy . next class SolutionAlternative1 : def copyRandomList ( self , head : 'Optional[Node]' ) -> 'Optional[Node]' : ''' list iteration with a hashmap old pointers -> new node Time : O(n) space: O(n) ''' self . pointers = {} # old pointer -> new node return self . copyRandom ( head ) def copyRandom ( self , head ): if head == None : return None if head in self . pointers : return self . pointers [ head ] # create a new node. node = Node ( head . val ) # save in hashmap self . pointers [ head ] = node # keep going to next and random via recursion node . next = self . copyRandom ( head . next ) node . random = self . copyRandom ( head . random ) return node","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0138_copy-list-with-random-pointer.html","loc":"https://tofucode.com/posts/leetcode_0138_copy-list-with-random-pointer.html"},{"title":"Leetcode 0061. Rotate List","text":"Question Link : https://leetcode.com/problems/rotate-list/ Difficulty: Medium Question Given the head of a linked list, rotate the list to the right by k places. Example 1: Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2: Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints: The number of nodes in the list is in the range [0, 500]. -100 <= Node.val <= 100 0 <= k <= 2 * 109 Solution Connect the tail to the head of the list to form a ring, this way the new problem becomes as to where to cut a new list We can k % count to find the actual offset needed to move since this is a ring Code ''' Leetcode 0061. Rotate List Question Link : https://leetcode.com/problems/rotate-list/ Solution Link : https://tofucode.com/posts/leetcode_0061_rotate-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def rotateRight ( self , head : Optional [ ListNode ], k : int ) -> Optional [ ListNode ]: ''' [1,2,3,4,5] T H count = 5 k = 2 offset = 2 # position calculated from start of the list head_position = 3 tail_position = 2 Time : O(n) Space: O(1) ''' if not head or not head . next : return head # keep a count of the size so we know where to move count = 1 # set up a ring p = head while p . next : count += 1 p = p . next p . next = head # find the new head and tail p = head offset = k % count head_position = count - offset # subtract to go from the back tail_position = head_position - 1 for i in range ( tail_position ): p = p . next # cut the ring result = p . next p . next = None return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0061_rotate-list.html","loc":"https://tofucode.com/posts/leetcode_0061_rotate-list.html"},{"title":"Leetcode 0002. Add Two Numbers","text":"Question Link : https://leetcode.com/problems/add-two-numbers/ Difficulty: Medium Question You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2: Input: l1 = [0], l2 = [0] Output: [0] Example 3: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] Constraints: The number of nodes in each linked list is in the range [1, 100]. 0 <= Node.val <= 9 It is guaranteed that the list represents a number that does not have leading zeros. Solution Use 2 pointers to go through each list and sum up each digit Use a carry to denote when it's >= 10 At the very end, check the carry again Code ''' Leetcode 0002. Add Two Numbers Question Link : https://leetcode.com/problems/add-two-numbers/ Solution Link : https://tofucode.com/posts/leetcode_0002_add-two-numbers.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def addTwoNumbers ( self , l1 : Optional [ ListNode ], l2 : Optional [ ListNode ]) -> Optional [ ListNode ]: ''' [2,4,3] [5,6,4] 7 0 7+1 carry Time : O(m + n) Space: O(m + n) ''' a = l1 b = l2 dummy = ListNode () p = dummy carry = 0 while a or b : s = carry if a : s += a . val a = a . next if b : s += b . val b = b . next carry = s // 10 s = s % 10 node = ListNode ( s ) p . next = node p = p . next # check if there is still a 1 if carry : node = ListNode ( carry ) p . next = node return dummy . next","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0002_add-two-numbers.html","loc":"https://tofucode.com/posts/leetcode_0002_add-two-numbers.html"},{"title":"Leetcode 0141. Linked List Cycle","text":"Question Link : https://leetcode.com/problems/linked-list-cycle/ Difficulty: Easy Question Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). Example 2: Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 0th node. Example 3: Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. Constraints: The number of the nodes in the list is in the range [0, 104]. -105 <= Node.val <= 105 pos is -1 or a valid index in the linked-list. Follow up: Can you solve it using O(1) (i.e. constant) memory? Solution Use two pointer where the fast the twice the speed of the slow one If there is a cycle the fast one would catch up with the slow one Code ''' Leetcode 0141. Linked List Cycle Question Link : https://leetcode.com/problems/linked-list-cycle/ Solution Link : https://tofucode.com/posts/leetcode_0141_linked-list-cycle.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution : def hasCycle ( self , head : Optional [ ListNode ]) -> bool : ''' Time : O(n) Space: O(1) ''' fast = head slow = head while True : if fast is None or fast . next is None : return False fast = fast . next . next slow = slow . next if fast == slow : return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0141_linked-list-cycle.html","loc":"https://tofucode.com/posts/leetcode_0141_linked-list-cycle.html"},{"title":"Leetcode 0021. Merge Two Sorted Lists","text":"Question Link : https://leetcode.com/problems/merge-two-sorted-lists/ Difficulty: Easy Question You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Example 1: Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2: Input: list1 = [], list2 = [] Output: [] Example 3: Input: list1 = [], list2 = [0] Output: [0] Constraints: The number of nodes in both lists is in the range [0, 50]. -100 <= Node.val <= 100 Both list1 and list2 are sorted in non-decreasing order. Solution Use 2 pointers to trace both lists and form a new list starting at a dummy head pointer When one list ends, we can append the remains of the other list onto the combined list Code ''' Leetcode 0021. Merge Two Sorted Lists Question Link : https://leetcode.com/problems/merge-two-sorted-lists/ Solution Link : https://tofucode.com/posts/leetcode_0021_merge-two-sorted-lists.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def mergeTwoLists ( self , list1 : Optional [ ListNode ], list2 : Optional [ ListNode ]) -> Optional [ ListNode ]: p1 = list1 p2 = list2 head = ListNode () x = head while p1 and p2 : if p1 . val < p2 . val : x . next = p1 p1 = p1 . next else : x . next = p2 p2 = p2 . next x = x . next if p1 : x . next = p1 else : x . next = p2 return head . next","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0021_merge-two-sorted-lists.html","loc":"https://tofucode.com/posts/leetcode_0021_merge-two-sorted-lists.html"},{"title":"Leetcode 0198. House Robber","text":"Question Link : https://leetcode.com/problems/house-robber/ Difficulty: Medium Question You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Constraints: 1 <= nums.length <= 100 0 <= nums[i] <= 400 Solution Find the dp relationship where max money at house i depends on if you rob house i-1 or not Code ''' Leetcode 0198. House Robber Question Link : https://leetcode.com/problems/house-robber/ Solution Link : https://tofucode.com/posts/leetcode_0198_house-robber.html ''' class Solution : def rob ( self , nums : List [ int ]) -> int : ''' dp[i] = max money up to house i [2,7,9,3,1] [2 7 x ] x = max(7, 2+9) = 11 Time : O(n) Space: O(n) ''' if not nums : return 0 dp = [ 0 ] * len ( nums ) # max at robbing house i for i in range ( len ( nums )): if i == 0 : dp [ i ] = nums [ i ] elif i == 1 : dp [ i ] = max ( dp [ i - 1 ], nums [ i ]) else : dp [ i ] = max ( dp [ i - 1 ], dp [ i - 2 ] + nums [ i ]) return dp [ - 1 ] class SolutionImproved1 : def rob ( self , nums : List [ int ]) -> int : ''' Use DP with two pointers to keep track: p1 is current, p2 is previous Improved Space Time : O(n) Space: O(1) ''' if not nums : return 0 p1 = 0 p2 = 0 for i in range ( len ( nums )): p1 , p2 = max ( p2 + nums [ i ] , p1 ), p1 return p1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0198_house-robber.html","loc":"https://tofucode.com/posts/leetcode_0198_house-robber.html"},{"title":"Leetcode 0740. Delete and Earn","text":"Question Link : https://leetcode.com/problems/delete-and-earn/ Difficulty: Medium Question You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times: Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1. Return the maximum number of points you can earn by applying the above operation some number of times. Example 1: Input: nums = [3,4,2] Output: 6 Explanation: You can perform the following operations: - Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2]. - Delete 2 to earn 2 points. nums = []. You earn a total of 6 points. Example 2: Input: nums = [2,2,3,3,3,4] Output: 9 Explanation: You can perform the following operations: - Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3]. - Delete a 3 again to earn 3 points. nums = [3]. - Delete a 3 once more to earn 3 points. nums = []. You earn a total of 9 points. Constraints: 1 <= nums.length <= 2 * 104 1 <= nums[i] <= 104 Solution First observation is that for any number that we take, we'd want to tak all intances of that number, so we can reduce nums to a counting dict This then is the same problem as the house robber problem where dp is used to solve whether to take the adjacent number Code ''' Leetcode 0740. Delete and Earn Question Link : https://leetcode.com/problems/delete-and-earn/ Solution Link : https://tofucode.com/posts/leetcode_0740_delete-and-earn.html ''' class Solution : def deleteAndEarn ( self , nums : List [ int ]) -> int : ''' [2,2,3,3,3,4] map: num -> count 2: 2 3: 3 4: 1 dp[i] = max(taking last one, not taking last one + num * count) With n elements, and k as the max number Time : O(n + x) Space: O(n + x) ''' if not nums : return 0 counts = {} for num in nums : counts [ num ] = counts . get ( num , 0 ) + 1 # + 1 so the last key is included, and can direct access with dp[-1] dp = [ 0 ] * ( max ( counts . keys ()) + 1 ) for i in range ( 1 , len ( dp )): if i == 1 : dp [ i ] = max ( dp [ i - 1 ], i * counts . get ( i , 0 )) else : dp [ i ] = max ( dp [ i - 1 ], dp [ i - 2 ] + i * counts . get ( i , 0 )) return dp [ - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0740_delete-and-earn.html","loc":"https://tofucode.com/posts/leetcode_0740_delete-and-earn.html"},{"title":"Leetcode 0799. Champagne Tower","text":"Question Link : https://leetcode.com/problems/champagne-tower/ Difficulty: Medium Question We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row. Each glass holds one cup of champagne. Then, some champagne is poured into the first glass at the top. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. (A glass at the bottom row has its excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full. After two cups of champagne are poured, the two glasses on the second row are half full. After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now. After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below. Now after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed.) Example 1: Input: poured = 1, query_row = 1, query_glass = 1 Output: 0.00000 Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty. Example 2: Input: poured = 2, query_row = 1, query_glass = 1 Output: 0.50000 Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange. Example 3: Input: poured = 100000009, query_row = 33, query_glass = 17 Output: 1.00000 Constraints: 0 <= poured <= 109 0 <= query_glass <= query_row < 100 Solution Just simulate how the pouring happens Here we create a tower with 100 rows just like the description This means we'd need to check if next row exists when pouring in the double for loop we can just query tower[query_row][query_glass] in the end For the pouring: think of all the glasses as left aligned in the 2d array, and the ones to pour into for [i][j] are [i+1][j] and [i+1][j+1] Code ''' Leetcode 0799. Champagne Tower Question Link : https://leetcode.com/problems/champagne-tower/ Solution Link : https://tofucode.com/posts/leetcode_0799_champagne-tower.html ''' class Solution : def champagneTower ( self , poured : int , query_row : int , query_glass : int ) -> float : ''' Use similation 2 0 0 0 0 0 1 .5 .5 0 0 0 for every row including the query_row: for every col: check if excess Time : O(1) Rows&#94;2 but Rows is fixed Space: O(1) ''' tower = [[ 0 ] * x for x in range ( 1 , 101 )] # first: len 1, last: len 100 tower [ 0 ][ 0 ] = poured for i in range ( query_row + 1 ): for j in range ( len ( tower [ i ])): # if there's a next row and current cup >= 1 if i + 1 < len ( tower ) and tower [ i ][ j ] >= 1 : half = ( tower [ i ][ j ] - 1 ) / 2.0 tower [ i + 1 ][ j ] += half tower [ i + 1 ][ j + 1 ] += half tower [ i ][ j ] = 1 return tower [ query_row ][ query_glass ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0799_champagne-tower.html","loc":"https://tofucode.com/posts/leetcode_0799_champagne-tower.html"},{"title":"Leetcode 0413. Arithmetic Slices","text":"Question Link : https://leetcode.com/problems/arithmetic-slices/ Difficulty: Medium Question An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences. Given an integer array nums, return the number of arithmetic subarrays of nums. A subarray is a contiguous subsequence of the array. Example 1: Input: nums = [1,2,3,4] Output: 3 Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself. Example 2: Input: nums = [1] Output: 0 Constraints: 1 <= nums.length <= 5000 -1000 <= nums[i] <= 1000 Solution At any time you have an subarray with >= 3 elements, and want to add the next number to the Sequence, you are extending the sequence * And add an amount of subarraies based on the current count. This hints at dp Code ''' Leetcode 0413. Arithmetic Slices Question Link : https://leetcode.com/problems/arithmetic-slices/ Solution Link : https://tofucode.com/posts/leetcode_0413_arithmetic-slices.html ''' class Solution : def numberOfArithmeticSlices ( self , nums : List [ int ]) -> int : ''' eg. 1,2,3,4,5 (sub) [1, 2, 3] at 3: have this with the first 3 elements (sub ) [1,2,3,4] at 4: 1 subarray for every subarray that starts at the current sequence and ends at 4 (dp[i-1]) (sub) [2, 3, 4] at 4: + 1 for the 3 element ending at 4 idx: 0 1 2 3 arr: [1,2,3,4] dp: [0 0 1 x] dp[i] = number of subarrays that end at index i x = (1 from dp[i-1]) + 1 dp[i] = dp[i-1] + 1 return sum(dp) ''' dp = [ 0 ] * len ( nums ) result = 0 for i in range ( 2 , len ( dp )): if self . endsAtArithSubarray ( nums , i ): dp [ i ] = dp [ i - 1 ] + 1 result += dp [ i ] return result def endsAtArithSubarray ( self , nums , i ): return nums [ i ] - nums [ i - 1 ] == nums [ i - 1 ] - nums [ i - 2 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0413_arithmetic-slices.html","loc":"https://tofucode.com/posts/leetcode_0413_arithmetic-slices.html"},{"title":"Leetcode 0001. Two Sum","text":"Question Link : https://leetcode.com/problems/two-sum/ Difficulty: Easy Question Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 <= nums.length <= 104 -109 <= nums[i] <= 109 -109 <= target <= 109 Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity? Solution ww Code ''' Leetcode 0001. Two Sum Question Link : https://leetcode.com/problems/two-sum/ Solution Link : https://tofucode.com/posts/leetcode_0001_two-sum.html ''' class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: ''' [3,2,4], target = 6 numbers: [2, 4] indices: [1, 2] other = target - current number 3 ? 4 ? 2 ? seen = {} # number -> index 3 -> 0, 2 -> 1, Time: O(n) Space: O(n) ''' seen = {} # number -> index for i in range ( len ( nums )): num = nums [ i ] other = target - num if other in seen : return [ seen [ other ], i ] seen [ num ] = i","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0001_two-sum.html","loc":"https://tofucode.com/posts/leetcode_0001_two-sum.html"},{"title":"Leetcode 0019. Remove Nth Node From End of List","text":"Question Link : https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Difficulty: Medium Question Given the head of a linked list, remove the nth node from the end of the list and return its head. Example 1: Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2: Input: head = [1], n = 1 Output: [] Example 3: Input: head = [1,2], n = 1 Output: [1] Constraints: The number of nodes in the list is sz. 1 <= sz <= 30 0 <= Node.val <= 100 1 <= n <= sz Follow up: Could you do this in one pass? Solution Use two pointers to mark out the ideal end location and remove the next node. Code ''' Leetcode 0019. Remove Nth Node From End of List Question Link : https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Solution Link : https://tofucode.com/posts/leetcode_0019_remove-nth-node-from-end-of-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def removeNthFromEnd ( self , head : ListNode , n : int ) -> ListNode : ''' First move x, then start moving both x and p p x n1 n2 n3 n4 n5 x->x p->p x: goes through the whole list * count: num of nodes up to x. 1, 2, ... total size of list p: pointer to one node before the deletion * Ideal Position: (position of x) - (position of p) == n * So start moving p: count - 1 > n Time: O(n) - one pass Space: O(1) ''' if not head : return None count = 1 x = p = head while x . next : x = x . next count += 1 if count - 1 > n : p = p . next if count == n : return head . next p . next = p . next . next return head","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0019_remove-nth-node-from-end-of-list.html","loc":"https://tofucode.com/posts/leetcode_0019_remove-nth-node-from-end-of-list.html"},{"title":"Leetcode 0509. Fibonacci Number","text":"Question Link : https://leetcode.com/problems/fibonacci-number/ Difficulty: Easy Question The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n > 1. Given n, calculate F(n). Example 1: Input: n = 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: Input: n = 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: Input: n = 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Constraints: 0 <= n <= 30 Solution Use recursion and a cache. Code ''' Leetcode 0509. Fibonacci Number Question Link : https://leetcode.com/problems/fibonacci-number/ Solution Link : https://tofucode.com/posts/leetcode_0509_fibonacci-number.html ''' class Solution : # @functools.cache def fib ( self , n : int ) -> int : ''' base: F(0) = 0, F(1) = 1 func: F(n) = F(n - 1) + F(n - 2), for n > 1 eg. fib(4) fib(3) + fib(2) fib(2)+fib(1) Time: O(n) Space: O(n) ''' cache = { 0 : 0 , 1 : 1 } # n -> number return self . getFib ( cache , n ) def getFib ( self , cache , n ): if n in cache : return cache [ n ] cache [ n ] = self . getFib ( cache , n - 1 ) + self . getFib ( cache , n - 2 ) return cache [ n ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0509_fibonacci-number.html","loc":"https://tofucode.com/posts/leetcode_0509_fibonacci-number.html"},{"title":"Leetcode 0606. Construct String from Binary Tree","text":"Question Link : https://leetcode.com/problems/construct-string-from-binary-tree/ Difficulty: Easy Question Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: root = [1,2,3,4] Output: \"1(2(4))(3)\" Explanation: Originally, it needs to be \"1(2(4)())(3()())\", but you need to omit all the unnecessary empty parenthesis pairs. And it will be \"1(2(4))(3)\" Example 2: Input: root = [1,2,3,null,4] Output: \"1(2()(4))(3)\" Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. Constraints: The number of nodes in the tree is in the range [1, 104]. -1000 <= Node.val <= 1000 Solution Use recursion to build the string while considering different cases of when to omit the parenthesis. Code ''' Leetcode 0606. Construct String from Binary Tree Question Link : https://leetcode.com/problems/construct-string-from-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0606_construct-string-from-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def tree2str ( self , t : TreeNode ) -> str : ''' current + left + right 1 (2(4)()) (3()()) (4)() 3()() Time: O(n) Space: O(n) ''' if not t : return \"\" current = str ( t . val ) left = self . wrap ( self . tree2str ( t . left )) right = self . wrap ( self . tree2str ( t . right )) if not t . left and not t . right : return current elif not t . right : return current + left return current + left + right def wrap ( self , s ): return '(' + s + ')'","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0606_construct-string-from-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0606_construct-string-from-binary-tree.html"}]};