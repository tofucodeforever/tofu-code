var tipuesearch = {"pages":[{"title":"TofuCode404 Page not found","text":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n\n  ga('create', 'G-DCBDZPQQD1', 'auto');\n  ga('send', 'pageview');\n\n\n\n\n\n\n\n\n\n\nTofuCode404 Page not found\n\n\n\n\n\n\n\n\nTofuCode\n\n\n\n\n\n\n\n\n\nInterview Questions\n\n\nRecent Questions\n\n\nTags\n\n\n\n\n\n\n\n 404 Page Note Found \n Try a search \n\n\n\n\n\n Eat Tofu and be true \nÂ© 2022 TofuCode.com\n\nBuilt with Pelican using Flex theme\n \n\n\n{\n  \"@context\" : \"http://schema.org\",\n  \"@type\" : \"Blog\",\n  \"name\": \" TofuCode \",\n  \"url\" : \"https://tofucode.com\",\n  \"image\": \"\",\n  \"description\": \"\"\n}\n\n\n      $(document).ready(function() {\n        $('#tipue_search_input').tipuesearch();\n      });\n    \n\n","tags":"","url":"https://tofucode.com/404.html"},{"title":"Hello there","text":"Quick Start For a table of all the questions: Interview Questions For a list of all questions tags: Tags","tags":"pages","url":"https://tofucode.com/pages/hello-there.html","loc":"https://tofucode.com/pages/hello-there.html"},{"title":"Interview Questions","text":"# Question Tags 0001 Two Sum hash-map 0019 Remove Nth Node From End of List linked-list 0413 Arithmetic Slices dp 0509 Fibonacci Number recursion 0606 Construct String from Binary Tree recursion, binary-tree","tags":"pages","url":"https://tofucode.com/pages/interview-questions.html","loc":"https://tofucode.com/pages/interview-questions.html"},{"title":"Leetcode 0413. Arithmetic Slices","text":"Question Link : https://leetcode.com/problems/arithmetic-slices/ Difficulty: Medium Question An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences. Given an integer array nums, return the number of arithmetic subarrays of nums. A subarray is a contiguous subsequence of the array. Example 1: Input: nums = [1,2,3,4] Output: 3 Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself. Example 2: Input: nums = [1] Output: 0 Constraints: 1 <= nums.length <= 5000 -1000 <= nums[i] <= 1000 Solution At any time you have an subarray with >= 3 elements, and want to add the next number to the Sequence, you are extending the sequence * And add an amount of subarraies based on the current count. This hints at dp Code ''' Leetcode 0413. Arithmetic Slices Question Link : https://leetcode.com/problems/arithmetic-slices/ Solution Link : https://tofucode.com/posts/leetcode_0413_arithmetic-slices.html ''' class Solution : def numberOfArithmeticSlices ( self , nums : List [ int ]) -> int : ''' eg. 1,2,3,4,5 (sub) [1, 2, 3] at 3: have this with the first 3 elements (sub ) [1,2,3,4] at 4: 1 subarray for every subarray that starts at the current sequence and ends at 4 (dp[i-1]) (sub) [2, 3, 4] at 4: + 1 for the 3 element ending at 4 idx: 0 1 2 3 arr: [1,2,3,4] dp: [0 0 1 x] dp[i] = number of subarrays that end at index i x = (1 from dp[i-1]) + 1 dp[i] = dp[i-1] + 1 return sum(dp) ''' dp = [ 0 ] * len ( nums ) result = 0 for i in range ( 2 , len ( dp )): if self . endsAtArithSubarray ( nums , i ): dp [ i ] = dp [ i - 1 ] + 1 result += dp [ i ] return result def endsAtArithSubarray ( self , nums , i ): return nums [ i ] - nums [ i - 1 ] == nums [ i - 1 ] - nums [ i - 2 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0413_arithmetic-slices.html","loc":"https://tofucode.com/posts/leetcode_0413_arithmetic-slices.html"},{"title":"Leetcode 0001. Two Sum","text":"Question Link : https://leetcode.com/problems/two-sum/ Difficulty: Easy Question Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 <= nums.length <= 104 -109 <= nums[i] <= 109 -109 <= target <= 109 Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity? Solution Use a hashmap to store number => index info for look up. Go through the array and look for the other number needed for the sum by checking the hashmap Code ''' Leetcode 0001. Two Sum Question Link : https://leetcode.com/problems/two-sum/ Solution Link : https://tofucode.com/posts/leetcode_0001_two-sum.html ''' class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: ''' [3,2,4], target = 6 numbers: [2, 4] indices: [1, 2] other = target - current number 3 ? 4 ? 2 ? seen = {} # number -> index 3 -> 0, 2 -> 1, Time: O(n) Space: O(n) ''' seen = {} # number -> index for i in range ( len ( nums )): num = nums [ i ] other = target - num if other in seen : return [ seen [ other ], i ] seen [ num ] = i","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0001_two-sum.html","loc":"https://tofucode.com/posts/leetcode_0001_two-sum.html"},{"title":"Leetcode 0019. Remove Nth Node From End of List","text":"Question Link : https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Difficulty: Medium Question Given the head of a linked list, remove the nth node from the end of the list and return its head. Example 1: Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2: Input: head = [1], n = 1 Output: [] Example 3: Input: head = [1,2], n = 1 Output: [1] Constraints: The number of nodes in the list is sz. 1 <= sz <= 30 0 <= Node.val <= 100 1 <= n <= sz Follow up: Could you do this in one pass? Solution Use two pointers to mark out the ideal end location and remove the next node. Code ''' Leetcode 0019. Remove Nth Node From End of List Question Link : https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Solution Link : https://tofucode.com/posts/leetcode_0019_remove-nth-node-from-end-of-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def removeNthFromEnd ( self , head : ListNode , n : int ) -> ListNode : ''' First move x, then start moving both x and p p x n1 n2 n3 n4 n5 x->x p->p x: goes through the whole list * count: num of nodes up to x. 1, 2, ... total size of list p: pointer to one node before the deletion * Ideal Position: (position of x) - (position of p) == n * So start moving p: count - 1 > n Time: O(n) - one pass Space: O(1) ''' if not head : return None count = 1 x = p = head while x . next : x = x . next count += 1 if count - 1 > n : p = p . next if count == n : return head . next p . next = p . next . next return head","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0019_remove-nth-node-from-end-of-list.html","loc":"https://tofucode.com/posts/leetcode_0019_remove-nth-node-from-end-of-list.html"},{"title":"Leetcode 0509. Fibonacci Number","text":"Question Link : https://leetcode.com/problems/fibonacci-number/ Difficulty: Easy Question The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n > 1. Given n, calculate F(n). Example 1: Input: n = 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: Input: n = 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: Input: n = 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Constraints: 0 <= n <= 30 Solution Use recursion and a cache. Code ''' Leetcode 0509. Fibonacci Number Question Link : https://leetcode.com/problems/fibonacci-number/ Solution Link : https://tofucode.com/posts/leetcode_0509_fibonacci-number.html ''' class Solution : # @functools.cache def fib ( self , n : int ) -> int : ''' base: F(0) = 0, F(1) = 1 func: F(n) = F(n - 1) + F(n - 2), for n > 1 eg. fib(4) fib(3) + fib(2) fib(2)+fib(1) Time: O(n) Space: O(n) ''' cache = { 0 : 0 , 1 : 1 } # n -> number return self . getFib ( cache , n ) def getFib ( self , cache , n ): if n in cache : return cache [ n ] cache [ n ] = self . getFib ( cache , n - 1 ) + self . getFib ( cache , n - 2 ) return cache [ n ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0509_fibonacci-number.html","loc":"https://tofucode.com/posts/leetcode_0509_fibonacci-number.html"},{"title":"Leetcode 0606. Construct String from Binary Tree","text":"Question Link : https://leetcode.com/problems/construct-string-from-binary-tree/ Difficulty: Easy Question Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: root = [1,2,3,4] Output: \"1(2(4))(3)\" Explanation: Originally, it needs to be \"1(2(4)())(3()())\", but you need to omit all the unnecessary empty parenthesis pairs. And it will be \"1(2(4))(3)\" Example 2: Input: root = [1,2,3,null,4] Output: \"1(2()(4))(3)\" Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. Constraints: The number of nodes in the tree is in the range [1, 104]. -1000 <= Node.val <= 1000 Solution Use recursion to build the string while considering different cases of when to omit the parenthesis. Code ''' Leetcode 0606. Construct String from Binary Tree Question Link : https://leetcode.com/problems/construct-string-from-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0606_construct-string-from-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def tree2str ( self , t : TreeNode ) -> str : ''' current + left + right 1 (2(4)()) (3()()) (4)() 3()() Time: O(n) Space: O(n) ''' if not t : return \"\" current = str ( t . val ) left = self . wrap ( self . tree2str ( t . left )) right = self . wrap ( self . tree2str ( t . right )) if not t . left and not t . right : return current elif not t . right : return current + left return current + left + right def wrap ( self , s ): return '(' + s + ')'","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0606_construct-string-from-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0606_construct-string-from-binary-tree.html"}]};