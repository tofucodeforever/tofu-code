var tipuesearch = {"pages":[{"title":"TofuCode404 Page not found","text":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTofuCode404 Page not found\n\n\n\n\n\n\n\n\nTofuCode\n\n\n\n\n\n\n\n\n\nInterview Questions\n\n\nRecent Questions\n\n\nTags\n\n\n\n\n\n\n\n 404 Page Not Found \n Try a search \n\n\n\n\n\n Eat Tofu and be true \nÂ© 2025 TofuCode.com\n\nBuilt with Pelican using Flex theme\n \n\n\n\n\n","tags":"","url":"https://tofucode.com/404.html"},{"title":"Hello there","text":"Quick Start For a table of all the questions: Interview Questions For a list of all questions tags: Tags Pages Python Basics","tags":"pages","url":"https://tofucode.com/pages/hello-there.html","loc":"https://tofucode.com/pages/hello-there.html"},{"title":"Interview Questions Premium","text":"# Question Tags Companies 0001 Two Sum hash-map 74 0002 Add Two Numbers linked-list, dummy-list-head 34 0003 Longest Substring Without Repeating Characters sliding-window 30 0005 Longest Palindromic Substring palindrome 40 0009 Palindrome Number palindrome, math 16 0011 Container With Most Water two-pointers 28 0015 3Sum k-sum 27 0019 Remove Nth Node From End of List linked-list, two-pointers, trailing-pointer 14 0020 Valid Parentheses stack, parentheses 30 0021 Merge Two Sorted Lists linked-list 0026 Remove Duplicates from Sorted Array array-shift, two-pointers 17 0027 Remove Element two-pointers 10 0033 Search in Rotated Sorted Array binary-search 26 0034 Find First and Last Position of Element in Sorted Array binary-search 20 0035 Search Insert Position binary-search 11 0039 Combination Sum backtracking 22 0042 Trapping Rain Water pointers, reverse-thinking 30 0048 Rotate Image matrix, math 23 0049 Group Anagrams hash-map, anagram 0053 Maximum Subarray subset-sum, dp 30 0054 Spiral Matrix matrix 30 0055 Jump Game dp, greedy 23 0056 Merge Intervals interval-merge 0057 Insert Interval interval-merge 0061 Rotate List linked-list, list-to-ring 0062 Unique Paths dp-2d 17 0064 Minimum Path Sum dp-2d, dp 16 0070 Climbing Stairs dp 0071 Simplify Path stack 13 0073 Set Matrix Zeroes matrix 16 0074 Search a 2D Matrix binary-search 0079 Word Search backtracking-with-matrix 31 0088 Merge Sorted Array pointers 30 0091 Decode Ways dp, backtracking 19 0093 Restore IP Addresses backtracking 10 0094 Binary Tree Inorder Traversal binary-tree-traversal-inorder 8 0098 Validate Binary Search Tree bst, recursion 21 0100 Same Tree binary-tree-traversal, recursion 12 0101 Symmetric Tree binary-tree-traversal 0102 Binary Tree Level Order Traversal binary-tree-traversal-level-order, bfs-layered, recursion 14 0104 Maximum Depth of Binary Tree binary-tree-traversal 0105 Construct Binary Tree from Preorder and Inorder Traversal binary-tree-traversal-inorder, binary-tree-traversal-preorder 13 0106 Construct Binary Tree from Inorder and Postorder Traversal binary-tree-manipulation 5 0108 Convert Sorted Array to Binary Search Tree bst 4 0111 Minimum Depth of Binary Tree bfs, binary-tree 6 0112 Path Sum binary-tree, recursion 0121 Best Time to Buy and Sell Stock dp-stock 30 0122 Best Time to Buy and Sell Stock II dp-stock, greedy 19 0123 Best Time to Buy and Sell Stock III dp-stock, state-machine 14 0124 Binary Tree Maximum Path Sum recursion, binary-tree 30 0125 Valid Palindrome palindrome 21 0128 Longest Consecutive Sequence set 24 0129 Sum Root to Leaf Numbers recursion, binary-tree 7 0133 Clone Graph dfs, bfs 15 0136 Single Number math 0138 Copy List with Random Pointer linked-list, dummy-list-head, recursion 0139 Word Break dfs, dp 28 0141 Linked List Cycle linked-list, fast-slow-pointer 0143 Reorder List linked-list 12 0144 Binary Tree Preorder Traversal binary-tree-traversal-preorder 4 0145 Binary Tree Postorder Traversal binary-tree-traversal-postorder 5 0146 LRU Cache lru-cache 68 0150 Evaluate Reverse Polish Notation stack 12 0152 Maximum Product Subarray dp, greedy, prefix-sum-subarray 18 0153 Find Minimum in Rotated Sorted Array binary-search 20 0160 Intersection of Two Linked Lists linked-list 0163 Missing Ranges array 4 0167 Two Sum II - Input Array Is Sorted k-sum 0169 Majority Element counting, boyer-moore-voting-algorithm 0173 Binary Search Tree Iterator bst 9 0188 Best Time to Buy and Sell Stock IV dp-stock, state-machine 14 0190 Reverse Bits bits 6 0191 Number of 1 Bits bits 13 0198 House Robber dp 26 0200 Number of Islands dfs-bfs-grid 30 0202 Happy Number set, fast-slow-pointer 20 0206 Reverse Linked List linked-list 0207 Course Schedule topological-sorting, bfs-layered 28 0208 Implement Trie (Prefix Tree) trie-prefix-tree 17 0211 Design Add and Search Words Data Structure trie-prefix-tree, dfs, recursion 9 0212 Word Search II backtracking-with-matrix, trie-prefix-tree 22 0213 House Robber II dp 17 0215 Kth Largest Element in an Array k-most-points, priority-queue, bubble-sort, quick-sort, counting-sort 27 0217 Contains Duplicate set 13 0221 Maximal Square dp-2d 22 0222 Count Complete Tree Nodes binary-tree 0223 Rectangle Area math 0224 Basic Calculator calculator, parentheses 0226 Invert Binary Tree binary-tree-manipulation 0227 Basic Calculator II calculator 0232 Implement Queue using Stacks stack, queue 14 0234 Palindrome Linked List palindrome-center-expansion, fast-slow-pointer 0235 Lowest Common Ancestor of a Binary Search Tree least-common-ancestor, bst 13 0236 Lowest Common Ancestor of a Binary Tree least-common-ancestor 18 0238 Product of Array Except Self math, subset-sum 27 0242 Valid Anagram string 20 0251 Flatten 2D Vector iterator 5 0252 Meeting Rooms sort 12 0253 Meeting Rooms II interval-merge, interval-overlap, priority-queue 25 0261 Graph Valid Tree graph, tree, dfs, union-find 9 0263 Ugly Number math 0268 Missing Number math 19 0269 Alien Dictionary topological-sorting 16 0270 Closest Binary Search Tree Value bst, binary-search 6 0271 Encode and Decode Strings string 5 0273 Integer to English Words string, recursion 21 0277 Find the Celebrity greedy 11 0278 First Bad Version binary-search 10 0283 Move Zeroes array-shift, two-pointers 0289 Game of Life simulation, state-changes 0297 Serialize and Deserialize Binary Tree binary-tree 20 0309 Best Time to Buy and Sell Stock with Cooldown state-machine 6 0322 Coin Change knapsack-unbounded, dp-2d 20 0328 Odd Even Linked List two-pointers 13 0334 Increasing Triplet Subsequence array 0338 Counting Bits bits, dp 9 0344 Reverse String string 0345 Reverse Vowels of a String two-pointers, string 0347 Top K Frequent Elements k-most-points, bucket-sort, hash-map 0348 Design Tic-Tac-Toe simulation 12 0374 Guess Number Higher or Lower binary-search 0380 Insert Delete GetRandom O(1) hash-map, array 40 0406 Queue Reconstruction by Height sort 0413 Arithmetic Slices dp 0415 Add Strings string 7 0416 Partition Equal Subset Sum knapsack-1-0 18 0417 Pacific Atlantic Water Flow bfs-grid, reverse-thinking 12 0424 Longest Repeating Character Replacement sliding-window 17 0426 Convert Binary Search Tree to Sorted Doubly Linked List linked-list 5 0435 Non-overlapping Intervals interval-merge, greedy 0451 Sort Characters By Frequency counting 9 0452 Minimum Number of Arrows to Burst Balloons interval-merge 0460 LFU Cache lfu-cache 19 0462 Minimum Moves to Equal Array Elements II math 0494 Target Sum backtracking, dp, knapsack-1-0 8 0495 Teemo Attacking greedy, interval-merge, simulation 0501 Find Mode in Binary Search Tree bst, binary-tree-traversal-inorder, dfs 3 0509 Fibonacci Number recursion 0543 Diameter of Binary Tree binary-tree-traversal 0572 Subtree of Another Tree tree-serialization, binary-tree 8 0605 Can Place Flowers array 7 0606 Construct String from Binary Tree recursion, binary-tree 0621 Task Scheduler greedy, math 17 0623 Add One Row to Tree binary-tree-manipulation, dfs 3 0647 Palindromic Substrings palindrome, string 0653 Two Sum IV - Input is a BST k-sum, dfs 0665 Non-decreasing Array monotonic-stack 0682 Baseball Game simulation 0695 Max Area of Island dfs-bfs-grid 16 0698 Partition to K Equal Sum Subsets subset-sum, backtracking 11 0700 Search in a Binary Search Tree bst 0704 Binary Search binary-search 15 0740 Delete and Earn dp 0746 Min Cost Climbing Stairs dp 0755 Pour Water simulation, array 2 0771 Jewels and Stones set 6 0799 Champagne Tower simulation 0872 Leaf-Similar Trees binary-tree-traversal 3 0876 Middle of the Linked List fast-slow-pointer 14 0881 Boats to Save People two-pointers, greedy 9 0897 Increasing Order Search Tree bst 0901 Online Stock Span monotonic-stack 0931 Minimum Falling Path Sum dp-2d 5 0938 Range Sum of BST bst, recursion 7 0946 Validate Stack Sequences stack, simulation, greedy 0953 Verifying an Alien Dictionary hash-map, topological-sorting 7 0958 Check Completeness of a Binary Tree binary-tree, bfs 4 0983 Minimum Cost For Tickets dp, knapsack-unbounded 10 0991 Broken Calculator reverse-thinking, puzzle 1020 Number of Enclaves dfs-bfs-grid 2 1046 Last Stone Weight priority-queue 12 1094 Car Pooling interval-overlap 1143 Longest Common Subsequence dp-2d 13 1162 As Far from Land as Possible bfs-layered, bfs-grid 4 1207 Unique Number of Occurrences counting 7 1213 Intersection of Three Sorted Arrays pointers 1 1249 Minimum Remove to Make Valid Parentheses stack, parentheses 1254 Number of Closed Islands dfs-bfs-grid 6 1257 Smallest Common Region least-common-ancestor 2 1339 Maximum Product of Splitted Binary Tree binary-tree 4 1423 Maximum Points You Can Obtain from Cards sliding-window, array 1431 Kids With the Greatest Number of Candies simulation 5 1466 Reorder Routes to Make All Paths Lead to the City Zero dfs, bfs 5 1470 Shuffle the Array array 7 1472 Design Browser History stack 8 1544 Make The String Great stack 1578 Minimum Time to Make Rope Colorful pointers, array 1644 Lowest Common Ancestor of a Binary Tree II least-common-ancestor 3 1647 Minimum Deletions to Make Character Frequencies Unique hash-map-count 1650 Lowest Common Ancestor of a Binary Tree III least-common-ancestor 5 1657 Determine if Two Strings Are Close counting 1 1662 Check If Two String Arrays are Equivalent string 1673 Find the Most Competitive Subsequence monotonic-stack 3 1704 Determine if String Halves Are Alike string 0 1710 Maximum Units on a Truck greedy 1757 Recyclable and Low Fat Products sql 9 1768 Merge Strings Alternately pointers 1 1891 Cutting Ribbons binary-search 2 2095 Delete the Middle Node of a Linked List fast-slow-pointer 2107 Number of Unique Flavors After Sharing K Candies sliding-window-fixed 1 2131 Longest Palindrome by Concatenating Two Letter Words palindrome, string 2182 Construct String With Repeat Limit priority-queue 2 2283 Check if Number Has Equal Digit Count and Digit Value hash-map-count 2284 Sender With Largest Word Count hash-map-count 2287 Rearrange Characters to Make Target String hash-map-count 2293 Min Max Game recursion, simulation 2294 Partition Array Such That Maximum Difference Is K array 2326 Spiral Matrix IV spiral-matrix 2348 Number of Zero-Filled Subarrays array, math 1 2389 Longest Subsequence With Limited Sum subset-sum, binary-search 1 2390 Removing Stars From a String stack 1 2404 Most Frequent Even Element hash-map-count 2405 Optimal Partition of String string, greedy 2 2413 Smallest Even Multiple math 2414 Length of the Longest Alphabetical Continuous Substring pointers, stack 2418 Sort the People hash-map 2423 Remove Letter To Equalize Frequency hash-map-count 2427 Number of Common Factors math 2432 The Employee That Worked on the Longest Task array 2433 Find The Original Array of Prefix Xor math 2437 Number of Valid Clock Times simulation 2441 Largest Positive Integer That Exists With Its Negative two-pointers 2446 Determine if Two Events Have Conflict interval 2451 Odd String Difference array, counting 2455 Average Value of Even Numbers That Are Divisible by Three math 2456 Most Popular Video Creator hash-map-count 2492 Minimum Score of a Path Between Two Cities dfs, bfs, union-find 1 2832 Maximal Range That Each Element Is Maximum in It monotonic-stack 1 2924 Find Champion II graph 1 2955 Number of Same-End Substrings math, binary-search, prefix-sum 2 3043 Find the Length of the Longest Common Prefix trie-prefix-tree 11 3110 Score of a String string 4 3263 Convert Doubly Linked List to Array I linked-list 0 3264 Final Array State After K Multiplication Operations I priority-queue 1 2460 Apply Operations to an Array two-pointers","tags":"pages","url":"https://tofucode.com/pages/interview-questions-premium.html","loc":"https://tofucode.com/pages/interview-questions-premium.html"},{"title":"Interview Questions","text":"# Question Tags Companies 0001 Two Sum hash-map 0002 Add Two Numbers linked-list, dummy-list-head 0003 Longest Substring Without Repeating Characters sliding-window 0005 Longest Palindromic Substring palindrome 0009 Palindrome Number palindrome, math 0011 Container With Most Water two-pointers 0015 3Sum k-sum 0019 Remove Nth Node From End of List linked-list, two-pointers, trailing-pointer 0020 Valid Parentheses stack, parentheses 0021 Merge Two Sorted Lists linked-list 0026 Remove Duplicates from Sorted Array array-shift, two-pointers 0027 Remove Element two-pointers 0033 Search in Rotated Sorted Array binary-search 0034 Find First and Last Position of Element in Sorted Array binary-search 0035 Search Insert Position binary-search 0039 Combination Sum backtracking 0042 Trapping Rain Water pointers, reverse-thinking 0048 Rotate Image matrix, math 0049 Group Anagrams hash-map, anagram 0053 Maximum Subarray subset-sum, dp 0054 Spiral Matrix matrix 0055 Jump Game dp, greedy 0056 Merge Intervals interval-merge 0057 Insert Interval interval-merge 0061 Rotate List linked-list, list-to-ring 0062 Unique Paths dp-2d 0064 Minimum Path Sum dp-2d, dp 0070 Climbing Stairs dp 0071 Simplify Path stack 0073 Set Matrix Zeroes matrix 0074 Search a 2D Matrix binary-search 0079 Word Search backtracking-with-matrix 0088 Merge Sorted Array pointers 0091 Decode Ways dp, backtracking 0093 Restore IP Addresses backtracking 0094 Binary Tree Inorder Traversal binary-tree-traversal-inorder 0098 Validate Binary Search Tree bst, recursion 0100 Same Tree binary-tree-traversal, recursion 0101 Symmetric Tree binary-tree-traversal 0102 Binary Tree Level Order Traversal binary-tree-traversal-level-order, bfs-layered, recursion 0104 Maximum Depth of Binary Tree binary-tree-traversal 0105 Construct Binary Tree from Preorder and Inorder Traversal binary-tree-traversal-inorder, binary-tree-traversal-preorder 0106 Construct Binary Tree from Inorder and Postorder Traversal binary-tree-manipulation 0108 Convert Sorted Array to Binary Search Tree bst 0111 Minimum Depth of Binary Tree bfs, binary-tree 0112 Path Sum binary-tree, recursion 0121 Best Time to Buy and Sell Stock dp-stock 0122 Best Time to Buy and Sell Stock II dp-stock, greedy 0123 Best Time to Buy and Sell Stock III dp-stock, state-machine 0124 Binary Tree Maximum Path Sum recursion, binary-tree 0125 Valid Palindrome palindrome 0128 Longest Consecutive Sequence set 0129 Sum Root to Leaf Numbers recursion, binary-tree 0133 Clone Graph dfs, bfs 0136 Single Number math 0138 Copy List with Random Pointer linked-list, dummy-list-head, recursion 0139 Word Break dfs, dp 0141 Linked List Cycle linked-list, fast-slow-pointer 0143 Reorder List linked-list 0144 Binary Tree Preorder Traversal binary-tree-traversal-preorder 0145 Binary Tree Postorder Traversal binary-tree-traversal-postorder 0146 LRU Cache lru-cache 0150 Evaluate Reverse Polish Notation stack 0152 Maximum Product Subarray dp, greedy, prefix-sum-subarray 0153 Find Minimum in Rotated Sorted Array binary-search 0160 Intersection of Two Linked Lists linked-list 0167 Two Sum II - Input Array Is Sorted k-sum 0169 Majority Element counting, boyer-moore-voting-algorithm 0173 Binary Search Tree Iterator bst 0188 Best Time to Buy and Sell Stock IV dp-stock, state-machine 0190 Reverse Bits bits 0191 Number of 1 Bits bits 0198 House Robber dp 0200 Number of Islands dfs-bfs-grid 0202 Happy Number set, fast-slow-pointer 0206 Reverse Linked List linked-list 0207 Course Schedule topological-sorting, bfs-layered 0208 Implement Trie (Prefix Tree) trie-prefix-tree 0211 Design Add and Search Words Data Structure trie-prefix-tree, dfs, recursion 0212 Word Search II backtracking-with-matrix, trie-prefix-tree 0213 House Robber II dp 0215 Kth Largest Element in an Array k-most-points, priority-queue, bubble-sort, quick-sort, counting-sort 0217 Contains Duplicate set 0221 Maximal Square dp-2d 0222 Count Complete Tree Nodes binary-tree 0223 Rectangle Area math 0224 Basic Calculator calculator, parentheses 0226 Invert Binary Tree binary-tree-manipulation 0227 Basic Calculator II calculator 0232 Implement Queue using Stacks stack, queue 0234 Palindrome Linked List palindrome-center-expansion, fast-slow-pointer 0235 Lowest Common Ancestor of a Binary Search Tree least-common-ancestor, bst 0236 Lowest Common Ancestor of a Binary Tree least-common-ancestor 0238 Product of Array Except Self math, subset-sum 0242 Valid Anagram string 0263 Ugly Number math 0268 Missing Number math 0273 Integer to English Words string, recursion 0278 First Bad Version binary-search 0283 Move Zeroes array-shift, two-pointers 0289 Game of Life simulation, state-changes 0297 Serialize and Deserialize Binary Tree binary-tree 0309 Best Time to Buy and Sell Stock with Cooldown state-machine 0322 Coin Change knapsack-unbounded, dp-2d 0328 Odd Even Linked List two-pointers 0334 Increasing Triplet Subsequence array 0338 Counting Bits bits, dp 0344 Reverse String string 0345 Reverse Vowels of a String two-pointers, string 0347 Top K Frequent Elements k-most-points, bucket-sort, hash-map 0374 Guess Number Higher or Lower binary-search 0380 Insert Delete GetRandom O(1) hash-map, array 0406 Queue Reconstruction by Height sort 0413 Arithmetic Slices dp 0415 Add Strings string 0416 Partition Equal Subset Sum knapsack-1-0 0417 Pacific Atlantic Water Flow bfs-grid, reverse-thinking 0424 Longest Repeating Character Replacement sliding-window 0435 Non-overlapping Intervals interval-merge, greedy 0451 Sort Characters By Frequency counting 0452 Minimum Number of Arrows to Burst Balloons interval-merge 0460 LFU Cache lfu-cache 0462 Minimum Moves to Equal Array Elements II math 0494 Target Sum backtracking, dp, knapsack-1-0 0495 Teemo Attacking greedy, interval-merge, simulation 0501 Find Mode in Binary Search Tree bst, binary-tree-traversal-inorder, dfs 0509 Fibonacci Number recursion 0543 Diameter of Binary Tree binary-tree-traversal 0572 Subtree of Another Tree tree-serialization, binary-tree 0605 Can Place Flowers array 0606 Construct String from Binary Tree recursion, binary-tree 0621 Task Scheduler greedy, math 0623 Add One Row to Tree binary-tree-manipulation, dfs 0647 Palindromic Substrings palindrome, string 0653 Two Sum IV - Input is a BST k-sum, dfs 0665 Non-decreasing Array monotonic-stack 0682 Baseball Game simulation 0695 Max Area of Island dfs-bfs-grid 0698 Partition to K Equal Sum Subsets subset-sum, backtracking 0700 Search in a Binary Search Tree bst 0704 Binary Search binary-search 0740 Delete and Earn dp 0746 Min Cost Climbing Stairs dp 0771 Jewels and Stones set 0799 Champagne Tower simulation 0872 Leaf-Similar Trees binary-tree-traversal 0876 Middle of the Linked List fast-slow-pointer 0881 Boats to Save People two-pointers, greedy 0897 Increasing Order Search Tree bst 0901 Online Stock Span monotonic-stack 0931 Minimum Falling Path Sum dp-2d 0938 Range Sum of BST bst, recursion 0946 Validate Stack Sequences stack, simulation, greedy 0953 Verifying an Alien Dictionary hash-map, topological-sorting 0958 Check Completeness of a Binary Tree binary-tree, bfs 0983 Minimum Cost For Tickets dp, knapsack-unbounded 0991 Broken Calculator reverse-thinking, puzzle 1020 Number of Enclaves dfs-bfs-grid 1046 Last Stone Weight priority-queue 1094 Car Pooling interval-overlap 1143 Longest Common Subsequence dp-2d 1162 As Far from Land as Possible bfs-layered, bfs-grid 1207 Unique Number of Occurrences counting 1249 Minimum Remove to Make Valid Parentheses stack, parentheses 1254 Number of Closed Islands dfs-bfs-grid 1339 Maximum Product of Splitted Binary Tree binary-tree 1423 Maximum Points You Can Obtain from Cards sliding-window, array 1431 Kids With the Greatest Number of Candies simulation 1466 Reorder Routes to Make All Paths Lead to the City Zero dfs, bfs 1470 Shuffle the Array array 1472 Design Browser History stack 1544 Make The String Great stack 1578 Minimum Time to Make Rope Colorful pointers, array 1647 Minimum Deletions to Make Character Frequencies Unique hash-map-count 1657 Determine if Two Strings Are Close counting 1662 Check If Two String Arrays are Equivalent string 1673 Find the Most Competitive Subsequence monotonic-stack 1704 Determine if String Halves Are Alike string 1710 Maximum Units on a Truck greedy 1757 Recyclable and Low Fat Products sql 1768 Merge Strings Alternately pointers 2095 Delete the Middle Node of a Linked List fast-slow-pointer 2131 Longest Palindrome by Concatenating Two Letter Words palindrome, string 2182 Construct String With Repeat Limit priority-queue 2283 Check if Number Has Equal Digit Count and Digit Value hash-map-count 2284 Sender With Largest Word Count hash-map-count 2287 Rearrange Characters to Make Target String hash-map-count 2293 Min Max Game recursion, simulation 2294 Partition Array Such That Maximum Difference Is K array 2326 Spiral Matrix IV spiral-matrix 2348 Number of Zero-Filled Subarrays array, math 2389 Longest Subsequence With Limited Sum subset-sum, binary-search 2390 Removing Stars From a String stack 2404 Most Frequent Even Element hash-map-count 2405 Optimal Partition of String string, greedy 2413 Smallest Even Multiple math 2414 Length of the Longest Alphabetical Continuous Substring pointers, stack 2418 Sort the People hash-map 2423 Remove Letter To Equalize Frequency hash-map-count 2427 Number of Common Factors math 2432 The Employee That Worked on the Longest Task array 2433 Find The Original Array of Prefix Xor math 2437 Number of Valid Clock Times simulation 2441 Largest Positive Integer That Exists With Its Negative two-pointers 2446 Determine if Two Events Have Conflict interval 2451 Odd String Difference array, counting 2455 Average Value of Even Numbers That Are Divisible by Three math 2456 Most Popular Video Creator hash-map-count 2492 Minimum Score of a Path Between Two Cities dfs, bfs, union-find 2924 Find Champion II graph 3043 Find the Length of the Longest Common Prefix trie-prefix-tree 3110 Score of a String string 3264 Final Array State After K Multiplication Operations I priority-queue 2460 Apply Operations to an Array two-pointers","tags":"pages","url":"https://tofucode.com/pages/interview-questions.html","loc":"https://tofucode.com/pages/interview-questions.html"},{"title":"Python Basics","text":"Python Basics: Essentials, Data Structure, Collections Essentials Math import math # when you need a infinite max min value: note that this returns floats math . inf - math . inf # log math . log () # random integer N such that a <= N <= b. random . randint ( a , b ) # random item from a list random . choice ( l ) # randomly shuffle a list of nums in place random . shuffle ( nums ) Exceptions try : int ( i ) except Exception as e : print ( e ) loops # you can't modify the i variable inside a for loop. eg. won't work: for i in range ( 6 ): i -= 1 lambda x = lambda a , b , c : a + b + c print ( x ( 5 , 6 , 2 )) # sort a 2d list by increasing of first number, and then increasing of second. eg. [7,0],[4,4],[7,1] sorted_list = sorted ( original_list , key = lambda x : ( x [ 0 ], x [ 1 ])) # filter final_list = list ( filter ( lambda x : ( x % 2 != 0 ) , li )) # filters out to get all odd nums in li # map final_list = list ( map ( lambda x : x * 2 , li )) # applie *2 to all the elements of the list # reduce from functools import reduce sum = reduce (( lambda x , y : x + y ), li ) # sum of the list Class class Dog: all_tricks = [] # class instance shared by all dogs def __init__ ( self , name ): self . name = name self . tricks = [] # creates a new empty list for each dog def add_trick ( self , trick ): self . tricks . append ( trick ) Enum from enum import Enum class Color ( Enum ): RED = 1 GREEN = 2 BLUE = 3 print ( Color . RED ) # Color.RED print ( Color . RED . name ) # RED print ( Color . RED . value ) # 1 Swapping a , b , c = d , e , f # note that order matters curr has to be last : # eg . when reversing a list in leetcode / leet_0206_reverse - linked - list . py # curr . next , prev , curr = prev , curr , curr . next Data structures Time: https://wiki.python.org/moin/TimeComplexity Char # char to ascii value ord ( c ) # ascii value to char chr ( x ) # ascii value offset from 'a' ord ( c ) - ord ( 'a' ) String Strings are immutable # initialize t = \"string\" t = 'string' # Operators t + t t * 3 # methods t . isdigit () # if made of digits only t . isalpha () # if made of alphabetics only t . isalnum () # if made of digits and alphabetics only t . isspace () # if made of spaces only t . isupper () # if made of upper case only t . upper () # returns an uppercased string t . islower () # if made of lower case only t . lower () # returns an lowercased string t . swapcase () # toggle between lower and upper case for each char # length t . count ( \"t\" ) # count the occurance of the character t len ( t ) #the length of the string # aligning t . center ( 20 ) # center the string in 20 chars t . ljust ( 20 ) # left align in 20 chars t . rjust ( 20 ) # right align in 20 chars # strip t . strirp () # strip trailing whitespaces t . lstrip () t . rstrip () # replace t . replace ( \"a\" , \"b\" ) # replace all occurances of a to b t . replace ( \"a\" , \"b\" , 2 ) # replace only the first 2 # split t . plit ( \"a\" ) # returns a list of strings split by the seperator # find t . startswith ( \"a\" ) # if the string starts with t . endswith ( \"a\" ) # is the string ends with t . find ( \"a\" ) # returns the index of the first occurance t . count ( 'a' ) # returns the occurance of this string # join ' ' . join ([ \"this\" , \"is\" , \"it\" ]) # reverse a string str [:: - 1 ] # [ <first element to include> : <first element to exclude> : <step> ] '' . join ( reversed ( str )) # casting a binary string to int int ( '110' , 2 ) # zfill with zeros txt = \"10\" x = txt . zfill ( 4 ) # 0010 # int to binary string - cut the first 2 chars bin ( 3 )[ 2 :] List same as arrays in java # initilizing l = [ 1 , 2 , 3 ] l = [ 1 ] * 4 # create a list of four 1s # insert and delete l . append ( 4 ) # appends one element to the end of the list l . extend ([ 4 , 5 ]) # This does not return another, but adds a list to l in place [Plus One](leetcode/leet_0066_plus-one.py) l += [ 4 , 5 ] # extends the list l . insert ( 2 , 99 ) # insert the element 99 before the given index 2 l . remove ( 99 ) # removes the first occorance of the given element l . pop ( 0 ) # pop the first element of the list l . pop () # pop the last element of the list l . clear () # clears the whole list # find l . index ( 1 ) # return the index of the given element: 0 l . count ( 2 ) # count the number of the element # sort l . sort () # in place sorting l . sort ( reverse = True ) # reverse sorting l . reverse () # reverse the list in place l [:: - 1 ] # reverse slice to return a reversed list sorted ( l , key = lambda x : len ( x )) # sort by length of string # which is: [ <first element to include> : <first element to exclude> : <step> ] # so is actually l[n-1:-1:-1] sorted ( l ) returns a sorted list of l # sublist l [ 1 :] # sublist from including index 1 to the end [2, 3] l [: 1 ] # sublist from the begining to and not include index 1 [1] l [ 1 : - 1 ] # sublist from including index 1 to the including 1 from the end [2] # list comprehension [ x * 2 for x in l ] # list processing [2, 4, 6] [ x for x in l if x < 2 ] # list filtering [1] # copy l2 = l [:] # shallow copy import copy l2 = copy . deepcopy ( l ) # deep copy l2 = l # reference only l2 [:] = l1 [:] # by value # insert into a sorted list import bisect bisext . insort ( l , 0 ) # inserts the element 0 into the list # enumerate both the index and the iterable for i , num in enumerate ( nums ): # zip : zips togeter multiple list by the element [ sum ( x ) for x in zip ( l1 , l2 )] # sums the 2 lists l1 and l2 element wise # initilizing a 2d list dp = [[ 0 ] * m for x in range ( n )] # dp = [[0] * m] * n # NOPE: This makes a list with five references to the same list Tuple Better way of mixing types in a collection Tuples are faster and consume less memory than list It is immutable Can be used as keys on a dictionary # initilize t = ( 1 , 2 , \"a\" ) t = ( 1 ,) # tuple with a single element t = ( 1 ,) * 3 # a tuple of five 1s # manipulation t += ( 9 ,) # append 9 to t t [ 2 :] # 2 index including to the end # indexing t . count ( 1 ) # count the number of occurances of 1 t . index ( 1 ) # find the first index of 1 # unpacking a , b , c = t # can also return a tuple in a method and unpack to variables # copy t2 = t # tuple is immutabe and this creates a copy # If a value within a tuple is mutable, then you can change it t = ( 1 , [ 9 , 8 ]) # you can change t[1][0] Dictionary Are not sorted Can not have duplicate elements # initilize d = { \"a\" : 1 , \"b\" : 2 } a = {} . fromkeys ([ \"a\" , \"b\" ]) # creat a empty dictionary of None with the keys # accessing d . keys () d . values () d . items () # a list of tuple (key, value) d [ \"a\" ] d . get ( \"a\" ) d . get ( \"a\" , - 1 ) # get -1 as a default value \"a\" in d # returns True or False # manipulation d . pop ( \"a\" ) # pop also removes the element d . clear () # clear the dictionary del d [ \"a\" ] # deletes just one element d2 . update ( d ) # add all key values pairs of d to d2 , duplicated keys will be overwritten # iterating for key , value in d . items (): # iterate all key value # counting items in list counts = dict () for i in items : counts [ i ] = counts . get ( i , 0 ) + 1 from collections import Counter counts = Counter ( items ) # sort by keys with highest first sorted_list = sorted ( freq . keys (), reverse = True ) Set unique elements ordering is arbitrary frozenset() is an immutable version of set # initilize a = set ([ 1 , 2 , 3 ]) b = set ([ 3 , 4 , 5 ]) # add a . add ( 4 ) # union a | b # union # intersection a & b a . intersection ( b ) # subset a < b a . issubset ( b ) a . issuperset ( b ) # difference a - b a . differnece ( b ) # symetric difference a &#94; b a . symmetric_difference ( b ) # copy c = a . copy () Heap priority queue # creating it import heapq l = [ 5 , 7 , 9 , 1 , 3 ] heapq . heapify ( l ) # min heap heapq . _heapify_max ( l ) # max heap # pushing heapq . heappush ( l , 4 ) # pop heapq . heappop ( l ) # min heap heapq . _heappop_max ( l ) # max heap # access heapq . nlargest ( 3 , l ) # returns a list of the 3 largest numbers heapq . nsmallest ( 3 , l ) # returns a list of the 3 smallest numbers # given counts which is a mup of num to counts: get the k most frequent numbers heapq . nlargest ( k , counts . keys (), key = counts . get ) PriorityQueue this is implemented as a wrapper around heap this is thread safe easier sytax from queue import PriorityQueue q = PriorityQueue () q . put ( 1 ) q . put ( 4 ) q . put ( 2 ) next_item = q . get () q . qsize () # get size # if want a reverse one as a max heap, use a tuple with the first one as the key: or use neg q . put (( - n , n )) # peek: q . queue [ 0 ] Collections Counter defaultdict OrderedDict deque ChainMap namedtuple() Counter give it a list and it will count occurances of each element and give dictionary of key => occurances from collections import Counter d = Counter ([ 1 , 1 , 1 , 2 ]) # Counter({1: 3, 2: 1}) d [ 1 ] # 3 # get the original list: list ( b . elements ()) # [1,1,1,2] # sort the counter dictionary and give a sorted list of key-value d . most_common () # [(1, 3), (2, 1)] # subtract another dictionary: it will match the keys and subtract the values d . subtract ( d2 ) defaultdict sets a default return value instead of throwing a KeyError when the key does not exist easier to use d.get('two', 0) instead from collections import defaultdict nums = defaultdict ( int ) nums [ 'two' ] = 2 print ( nums [ 'three' ]) # 0 OrderedDict a dictionary where keys maintain the order in which they are inserted from collections import OrderedDict d = OrderedDict () d [ 'a' ] = 1 d [ 'b' ] = 2 d [ 'c' ] = 3 print ( d ) # OrderedDict([('a', 1), ('b', 2), ('c', 3)]) deque list that append pop from either end in O(1) python list pop(0) would otherwise be O(n) from collections import deque list = [ \"a\" , \"b\" , \"c\" ] dq = deque ( list ) print ( dq ) # deque(['a', 'b', 'c']) # append dq . append ( \"d\" ) dq . appendleft ( \"z\" ) # pop dq . pop () dq . popleft () # other dq . clear () dq . count ( 'a' ) # counts the number of occurances: 1 ChainMap combine multiple dictionaries to be used as a single unit from collections import ChainMap dict1 = { 'a' : 1 , 'b' : 2 } dict2 = { 'c' : 3 , 'b' : 4 } chain_map = ChainMap ( dict1 , dict2 ) print ( chain_map . maps ) # [{'b': 2, 'a': 1}, {'c': 3, 'b': 4}] print ( list ( chain_map . keys ())) # ['b', 'a', 'c'] print ( list ( chain_map . values ())) # [2, 1, 3] chain_map . new_child ( dict3 ) # add another dictionary namedtuple() gives name to each object in tuple from collections import namedtuple Student = namedtuple ( 'Student' , 'fname, lname, age' ) s1 = Student ( 'John' , 'Clarke' , '13' ) print ( s1 . fname ) # Student(fname='John', lname='Clarke', age='13') s2 = Student . _make ([ 'Adam' , 'joe' , '18' ]) # creates new Student tuples s2 = s1 . _replace ( age = '14' ) # changes a field of the tuple: tuples are immutable so this returns new instance","tags":"pages","url":"https://tofucode.com/pages/python-basics.html","loc":"https://tofucode.com/pages/python-basics.html"},{"title":"Leetcode 0042. Trapping Rain Water","text":"Question Link : https://leetcode.com/problems/trapping-rain-water/ Difficulty: Hard Premium: False Question Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. Example 1: Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Example 2: Input: height = [4,2,0,3,2,5] Output: 9 Constraints: n == height.length 1 <= n <= 2 * 104 0 <= height[i] <= 105 Solution Walk through one example and try to see how this would be manually solved, then indentify that trapped water are bound by heights on both sides. If we can fix one side (a global max), we can tranverse towards this global max to find trapped water. The total result would need to be done from both left and right sides. Code ''' Leetcode 0042. Trapping Rain Water Question Link : https://leetcode.com/problems/trapping-rain-water/ Solution Link : https://tofucode.com/posts/leetcode_0042_trapping-rain-water.html ''' class Solution : def trap ( self , height : List [ int ]) -> int : \"\"\" [4,2,0,3,2,5] 2 4 1 2 water height as 4, total 9 Split by a global max height: find global max height 5 track last seen max height from l to r: 4 bound by min(4, 5) result += bound - current height pass x 2 from both direction Time : O(n) Space: O(n) \"\"\" max_idx = 0 for i in range ( len ( height )): if height [ i ] > height [ max_idx ]: max_idx = i l_to_r = self . getWater ( height [: max_idx + 1 ]) r_to_l = self . getWater ( height [ max_idx :][:: - 1 ]) return l_to_r + r_to_l def getWater ( self , height ): \"\"\" return water of one pass from left to right assume there is a global max height to the right edge \"\"\" last = 0 # mark last local max height index result = 0 for i in range ( len ( height )): h = height [ i ] if h < height [ last ]: result += height [ last ] - h else : last = i return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0042_trapping-rain-water.html","loc":"https://tofucode.com/posts/leetcode_0042_trapping-rain-water.html"},{"title":"Leetcode 0417. Pacific Atlantic Water Flow","text":"Question Link : https://leetcode.com/problems/pacific-atlantic-water-flow/ Difficulty: Medium Premium: False Question There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c). The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean. Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans. Example 1: Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]] Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]] Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below: [0,4]: [0,4] -> Pacific Ocean [0,4] -> Atlantic Ocean [1,3]: [1,3] -> [0,3] -> Pacific Ocean [1,3] -> [1,4] -> Atlantic Ocean [1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean [1,4] -> Atlantic Ocean [2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean [3,0]: [3,0] -> Pacific Ocean [3,0] -> [4,0] -> Atlantic Ocean [3,1]: [3,1] -> [3,0] -> Pacific Ocean [3,1] -> [4,1] -> Atlantic Ocean [4,0]: [4,0] -> Pacific Ocean [4,0] -> Atlantic Ocean Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans. Example 2: Input: heights = [[1]] Output: [[0,0]] Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans. Constraints: m == heights.length n == heights[r].length 1 <= m, n <= 200 0 <= heights[r][c] <= 105 Solution First we analyze the common way of approaching this with water landing on land and then flowing into ocean, when we see that it is efficient in that it would be hard to track path along the way, we can try reverse thinking here of running bfs from ocean to land, this way anything along the path can be tracked as can flow to the ocean. Code ''' Leetcode 0417. Pacific Atlantic Water Flow Question Link : https://leetcode.com/problems/pacific-atlantic-water-flow/ Solution Link : https://tofucode.com/posts/leetcode_0417_pacific-atlantic-water-flow.html ''' from collections import deque from typing import List class Solution : def pacificAtlantic ( self , heights : List [ List [ int ]]) -> List [ List [ int ]]: \"\"\" for each cell simulate flow (bfs) need to track path reverse: for each ocean cell bfs back to see where it passes all cells on the path are valid Time : O(mn) Space: O(mn) \"\"\" rows = len ( heights ) cols = len ( heights [ 0 ]) if rows else 0 pacific_cells = deque () atlantic_cells = deque () for i in range ( rows ): pacific_cells . append (( i , 0 )) atlantic_cells . append (( i , cols - 1 )) for i in range ( cols ): pacific_cells . append (( 0 , i )) atlantic_cells . append (( rows - 1 , i )) reached_pacific_set = self . bfs ( pacific_cells , heights , rows , cols ) reached_atlantic_set = self . bfs ( atlantic_cells , heights , rows , cols ) # Return intersection as a list of lists return [ list ( cell ) for cell in reached_pacific_set & reached_atlantic_set ] def bfs ( self , queue , heights , rows , cols ): result = set () direction = [( 1 , 0 ), ( 0 , 1 ), ( - 1 , 0 ), ( 0 , - 1 )] while queue : x , y = queue . popleft () if ( x , y ) in result : continue result . add (( x , y )) for dx , dy in direction : nx , ny = x + dx , y + dy if 0 <= nx < rows and 0 <= ny < cols : if ( nx , ny ) not in result and heights [ nx ][ ny ] >= heights [ x ][ y ]: queue . append (( nx , ny )) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0417_pacific-atlantic-water-flow.html","loc":"https://tofucode.com/posts/leetcode_0417_pacific-atlantic-water-flow.html"},{"title":"Leetcode 3043. Find the Length of the Longest Common Prefix","text":"Question Link : https://leetcode.com/problems/find-the-length-of-the-longest-common-prefix/ Difficulty: Medium Premium: False Question You are given two arrays with positive integers arr1 and arr2. A prefix of a positive integer is an integer formed by one or more of its digits, starting from its leftmost digit. For example, 123 is a prefix of the integer 12345, while 234 is not. A common prefix of two integers a and b is an integer c, such that c is a prefix of both a and b. For example, 5655359 and 56554 have common prefixes 565 and 5655 while 1223 and 43456 do not have a common prefix. You need to find the length of the longest common prefix between all pairs of integers (x, y) such that x belongs to arr1 and y belongs to arr2. Return the length of the longest common prefix among all pairs. If no common prefix exists among them, return 0. Example 1: Input: arr1 = [1,10,100], arr2 = [1000] Output: 3 Explanation: There are 3 pairs (arr1[i], arr2[j]): - The longest common prefix of (1, 1000) is 1. - The longest common prefix of (10, 1000) is 10. - The longest common prefix of (100, 1000) is 100. The longest common prefix is 100 with a length of 3. Example 2: Input: arr1 = [1,2,3], arr2 = [4,4,4] Output: 0 Explanation: There exists no common prefix for any pair (arr1[i], arr2[j]), hence we return 0. Note that common prefixes between elements of the same array do not count. Constraints: 1 <= arr1.length, arr2.length <= 5 * 104 1 <= arr1[i], arr2[i] <= 108 Solution Should be straight forward to identify as a trie problem given we can use one array to build a trie and the array to check against it. Code ''' Leetcode 3043. Find the Length of the Longest Common Prefix Question Link : https://leetcode.com/problems/find-the-length-of-the-longest-common-prefix/ Solution Link : https://tofucode.com/posts/leetcode_3043_find-the-length-of-the-longest-common-prefix.html ''' class TrieNode : def __init__ ( self , c ): self . c = c self . children = {} # char -> TrieNode class Trie : \"\"\" See question 208. Implement Trie (Prefix Tree) \"\"\" def __init__ ( self ): self . root = TrieNode ( '' ) def insert ( self , word : str ) -> None : current = self . root for c in word : if not c in current . children : current . children [ c ] = TrieNode ( c ) current = current . children [ c ] def find_prefix_length ( self , word : str ) -> int : \"\"\" given word, return length of longest prefix match \"\"\" current = self . root result = 0 for digit in word : if digit in current . children : result += 1 current = current . children [ digit ] else : break return result class Solution : def longestCommonPrefix ( self , arr1 : List [ int ], arr2 : List [ int ]) -> int : \"\"\" turn all number to strings got through array 1 build prefix tree go through array 2 check tree, find max possible length Time: O(n + m) n and m digits Space: O(n) \"\"\" trie = Trie () for num in arr1 : trie . insert ( str ( num )) result = 0 for num in arr2 : length = trie . find_prefix_length ( str ( num )) result = max ( result , length ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_3043_find-the-length-of-the-longest-common-prefix.html","loc":"https://tofucode.com/posts/leetcode_3043_find-the-length-of-the-longest-common-prefix.html"},{"title":"Leetcode 0273. Integer to English Words","text":"Question Link : https://leetcode.com/problems/integer-to-english-words/ Difficulty: Hard Premium: False Question Convert a non-negative integer num to its English words representation. Example 1: Input: num = 123 Output: \"One Hundred Twenty Three\" Example 2: Input: num = 12345 Output: \"Twelve Thousand Three Hundred Forty Five\" Example 3: Input: num = 1234567 Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\" Constraints: 0 <= num <= 231 - 1 Solution The cleanest solution to write is with recursion. Trying to process the string iteratively also works with extra care to check for edge cases. Code ''' Leetcode 0273. Integer to English Words Question Link : https://leetcode.com/problems/integer-to-english-words/ Solution Link : https://tofucode.com/posts/leetcode_0273_integer-to-english-words.html ''' class Solution : def numberToWords ( self , num : int ) -> str : ''' Use recursion, note the strip() for when the last one is an empty string Time : O(log n) Space: O(log n) ''' if num == 0 : return 'Zero' self . BILLION = 1000000000 self . MILLION = 1000000 self . THOUSAND = 1000 self . HUNDRED = 100 self . TWENTY = 20 self . tens = [ \"\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" ] self . ones = [ \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" ] return self . translate ( num ) . strip () def translate ( self , num ): if num >= self . BILLION : return self . translate ( num // self . BILLION ) + ' Billion ' + self . translate ( num % self . BILLION ) elif num >= self . MILLION : return self . translate ( num // self . MILLION ) + ' Million ' + self . translate ( num % self . MILLION ) elif num >= self . THOUSAND : return self . translate ( num // self . THOUSAND ) + ' Thousand ' + self . translate ( num % self . THOUSAND ) elif num >= self . HUNDRED : return ( self . translate ( num // self . HUNDRED ) + ' Hundred ' + self . translate ( num % self . HUNDRED )) . strip () elif num >= self . TWENTY : return ( self . tens [ num // 10 ] + \" \" + self . translate ( num % 10 )) . strip () return self . ones [ num ] class SolutionAlternative1 : def numberToWords ( self , num : int ) -> str : \"\"\" 1 234 567 One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven break into parts of 3: 567 234 1 translate eachand stick together Time : O(d) # number of digits in num Space: O(d) \"\"\" if num == 0 : return \"Zero\" self . suffix = [ '' , 'Thousand' , 'Million' , 'Billion' , 'Trillion' ] self . num_word_map = self . getNumMap () num_str = str ( num ) parts = [] for i in range ( len ( num_str ), 0 , - 3 ): parts . append ( num_str [ max ( i - 3 , 0 ): i ]) result = [] for i in range ( len ( parts )): num = self . getNumberWords ( parts [ i ]) suf = self . suffix [ i ] r = '' if num : r += num if num and suf : r += ' ' + suf result . append ( r ) result = result [:: - 1 ] return ' ' . join ([ x for x in result if x ]) def getNumberWords ( self , s ): result = [] if int ( s ) == 0 : return '' if len ( s ) == 1 : result . append ( self . num_word_map [ s ]) elif len ( s ) == 2 : result . extend ( self . translateTens ( s )) else : pre_hundred = self . num_word_map [ s [ 0 ]] result . append ( pre_hundred ) if pre_hundred : result . append ( 'Hundred' ) result . extend ( self . translateTens ( s [ 1 :])) return ' ' . join ([ x for x in result if x ]) def translateTens ( self , s ): result = [] num = int ( s ) if num <= 20 : result . append ( self . num_word_map [ str ( num )]) else : one = num % 10 result . append ( self . num_word_map [ str ( num - one )]) result . append ( self . num_word_map [ str ( one )]) return result def getNumMap ( self ): return { \"0\" : '' , \"1\" : 'One' , \"2\" : 'Two' , \"3\" : 'Three' , \"4\" : 'Four' , \"5\" : 'Five' , \"6\" : 'Six' , \"7\" : 'Seven' , \"8\" : 'Eight' , \"9\" : 'Nine' , \"10\" : 'Ten' , \"11\" : 'Eleven' , \"12\" : 'Twelve' , \"13\" : 'Thirteen' , \"14\" : 'Fourteen' , \"15\" : 'Fifteen' , \"16\" : 'Sixteen' , \"17\" : 'Seventeen' , \"18\" : 'Eighteen' , \"19\" : 'Nineteen' , \"20\" : 'Twenty' , \"30\" : 'Thirty' , \"40\" : 'Forty' , \"50\" : 'Fifty' , \"60\" : 'Sixty' , \"70\" : 'Seventy' , \"80\" : 'Eighty' , \"90\" : 'Ninety' }","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0273_integer-to-english-words.html","loc":"https://tofucode.com/posts/leetcode_0273_integer-to-english-words.html"},{"title":"Leetcode 0153. Find Minimum in Rotated Sorted Array","text":"Question Link : https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ Difficulty: Medium Premium: False Question Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time. Example 1: Input: nums = [3,4,5,1,2] Output: 1 Explanation: The original array was [1,2,3,4,5] rotated 3 times. Example 2: Input: nums = [4,5,6,7,0,1,2] Output: 0 Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times. Example 3: Input: nums = [11,13,15,17] Output: 11 Explanation: The original array was [11,13,15,17] and it was rotated 4 times. Constraints: n == nums.length 1 <= n <= 5000 -5000 <= nums[i] <= 5000 All the integers of nums are unique. nums is sorted and rotated between 1 and n times. Solution Binary search with taking care of which direction to go. Code ''' Leetcode 0153. Find Minimum in Rotated Sorted Array Question Link : https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ Solution Link : https://tofucode.com/posts/leetcode_0153_find-minimum-in-rotated-sorted-array.html ''' class Solution : def findMin ( self , nums : List [ int ]) -> int : \"\"\" rotate once: shift last to the front binary search l, r get mid compare mid agsint l and r [3,4,5,1,2] 3 5 2 go right Time : O(log n) Space: O(1) \"\"\" left = 0 right = len ( nums ) - 1 while left < right : mid = ( left + right ) // 2 if nums [ mid ] <= nums [ right ]: # min is to the left, right could be min so don't -1 right = mid else : left = mid + 1 return nums [ left ] class SolutionImproved1 : def findMin ( self , nums : List [ int ]) -> int : ''' Use the fact that to find the min we just keep trying to get closer to it For the last case when the mid is the min of the 3, move left up and retry Time : O(log n) Space: O(1) ''' l = 0 r = len ( nums ) - 1 while l < r : mid = ( l + r ) // 2 m = min ( nums [ l ], nums [ mid ], nums [ r ]) if m == nums [ l ]: r = mid - 1 elif m == nums [ r ]: l = mid + 1 else : l += 1 return nums [ l ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0153_find-minimum-in-rotated-sorted-array.html","loc":"https://tofucode.com/posts/leetcode_0153_find-minimum-in-rotated-sorted-array.html"},{"title":"Leetcode 0261. Graph Valid Tree","text":"Question Link : https://leetcode.com/problems/graph-valid-tree/ Difficulty: Medium Premium: True Question You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph. Return true if the edges of the given graph make up a valid tree, and false otherwise. Example 1: Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]] Output: true Example 2: Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]] Output: false Constraints: 1 <= n <= 2000 0 <= edges.length <= 5000 edges[i].length == 2 0 <= ai, bi < n ai != bi There are no self-loops or repeated edges. Solution It's Important to point out the conditions to return False for, then, we can do a dfs starting from any node, and make sure all nodes are connected with no cycle. can also be donw with unoin find. Code ''' Leetcode 0261. Graph Valid Tree Question Link : https://leetcode.com/problems/graph-valid-tree/ Solution Link : https://tofucode.com/posts/leetcode_0261_graph-valid-tree.html ''' class Solution : def validTree ( self , n : int , edges : List [ List [ int ]]) -> bool : \"\"\" tree: all nodes are connected no cycles build the graph = {} # nodes-> [] dfs the graph - any node can start as root need to track parent, to make sure we don't redo node->parent edge Time : O(n) Soace: O(n) \"\"\" if n - 1 != len ( edges ): return False graph = {} for a , b in edges : graph [ a ] = graph . get ( a , []) + [ b ] graph [ b ] = graph . get ( b , []) + [ a ] stack = [( 0 , - 1 )] # node and parent seen = set () while stack : node , parent = stack . pop () if node in seen : return False seen . add ( node ) for other in graph . get ( node ,[]): if other == parent : continue stack . append (( other , node )) return len ( seen ) == n class SolutionImproved1 : def validTree ( self , n : int , edges : List [ List [ int ]]) -> bool : \"\"\" cleaner code by tracking if graph is connected tree: all nodes are connected no cycles build the graph = {} # nodes-> [] dfs the graph - any node can start as root gaph has to be fully connected Time : O(n) Soace: O(n) \"\"\" if n - 1 != len ( edges ): return False graph = {} for a , b in edges : graph [ a ] = graph . get ( a , []) + [ b ] graph [ b ] = graph . get ( b , []) + [ a ] stack = [ 0 ] seen = set ([ 0 ]) while stack : node = stack . pop () for other in graph . get ( node ,[]): if other in seen : continue seen . add ( other ) stack . append ( other ) return len ( seen ) == n","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0261_graph-valid-tree.html","loc":"https://tofucode.com/posts/leetcode_0261_graph-valid-tree.html"},{"title":"Leetcode 0271. Encode and Decode Strings","text":"Question Link : https://leetcode.com/problems/encode-and-decode-strings/ Difficulty: Medium Premium: True Question Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Machine 1 (sender) has the function: string encode(vector strs) { // ... your code return encoded_string; } Machine 2 (receiver) has the function: vector decode(string s) { //... your code return strs; } So Machine 1 does: string encoded_string = encode(strs); and Machine 2 does: vector strs2 = decode(encoded_string); strs2 in Machine 2 should be the same as strs in Machine 1. Implement the encode and decode methods. You are not allowed to solve the problem using any serialize methods (such as eval). Example 1: Input: dummy_input = [\"Hello\",\"World\"] Output: [\"Hello\",\"World\"] Explanation: Machine 1: Codec encoder = new Codec(); String msg = encoder.encode(strs); Machine 1 ---msg---> Machine 2 Machine 2: Codec decoder = new Codec(); String[] strs = decoder.decode(msg); Example 2: Input: dummy_input = [\"\"] Output: [\"\"] Constraints: 1 <= strs.length <= 200 0 <= strs[i].length <= 200 strs[i] contains any possible characters out of 256 valid ASCII characters. Follow up: Could you write a generalized algorithm to work on any possible set of characters? Solution The most easy solution is to use a single delimiter that is not used in the input string. Otherwise we need to write extra into into the encoded string that can help with decoding - with this string length comes up as a piece of useful info to add. Code ''' Leetcode 0271. Encode and Decode Strings Question Link : https://leetcode.com/problems/encode-and-decode-strings/ Solution Link : https://tofucode.com/posts/leetcode_0271_encode-and-decode-strings.html ''' class Codec : \"\"\" pass along length info at the start of the string [\"Hello\",\"World\"] 5,5#HelloWorld Time : O(n) Space: O(n) \"\"\" def encode ( self , strs : List [ str ]) -> str : \"\"\"Encodes a list of strings to a single string. \"\"\" all_length = [ str ( len ( s )) for s in strs ] return ',' . join ( all_length ) + '#' + '' . join ( strs ) def decode ( self , s : str ) -> List [ str ]: \"\"\"Decodes a single string to a list of strings. \"\"\" idx = s . find ( '#' ) length_info = s [: idx ] . split ( ',' ) string_info = s [ idx + 1 :] result = [] i = 0 for length_str in length_info : l = int ( length_str ) result . append ( string_info [ i : i + l ]) i += l return result # Your Codec object will be instantiated and called as such: # codec = Codec() # codec.decode(codec.encode(strs))","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0271_encode-and-decode-strings.html","loc":"https://tofucode.com/posts/leetcode_0271_encode-and-decode-strings.html"},{"title":"Leetcode 0424. Longest Repeating Character Replacement","text":"Question Link : https://leetcode.com/problems/longest-repeating-character-replacement/ Difficulty: Medium Premium: False Question You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations. Example 1: Input: s = \"ABAB\", k = 2 Output: 4 Explanation: Replace the two 'A's with two 'B's or vice versa. Example 2: Input: s = \"AABABBA\", k = 1 Output: 4 Explanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\". The substring \"BBBB\" has the longest repeating letters, which is 4. There may exists other ways to achieve this answer too. Constraints: 1 <= s.length <= 105 s consists of only uppercase English letters. 0 <= k <= s.length Solution Since we are trying to find a max substring, we should consider sliding window. It is important to get the relationship between k and the window length and count of current most frequent char. Code ''' Leetcode 0424. Longest Repeating Character Replacement Question Link : https://leetcode.com/problems/longest-repeating-character-replacement/ Solution Link : https://tofucode.com/posts/leetcode_0424_longest-repeating-character-replacement.html ''' class Solution : def characterReplacement ( self , s : str , k : int ) -> int : \"\"\" k time change any char s = \"AA B ABBA\", k = 1 A longest repeating string allows k other chars Sliding window {} or [] # char -> count A: 3 B: 1 replacement needed = window length - most char count max k = window length - most char count shink window length when it's too big (shrink 1) Time : O(n) Space: O(n) \"\"\" l = 0 chars_count = [ 0 ] * 26 result = 0 for r in range ( len ( s )): c = s [ r ] self . updateCharCount ( chars_count , c , 1 ) need_replacement = ( r + 1 - l ) - self . getMostCharCount ( chars_count ) if need_replacement > k : last_char = s [ l ] self . updateCharCount ( chars_count , last_char , - 1 ) l += 1 result = max ( result , ( r + 1 - l )) return result def getMostCharCount ( self , chars_count ): current_max = 0 for count in chars_count : current_max = max ( current_max , count ) return current_max def updateCharCount ( self , chars_count , letter , delta ): idx = ord ( letter ) - ord ( 'A' ) chars_count [ idx ] += delta","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0424_longest-repeating-character-replacement.html","loc":"https://tofucode.com/posts/leetcode_0424_longest-repeating-character-replacement.html"},{"title":"Leetcode 0105. Construct Binary Tree from Preorder and Inorder Traversal","text":"Question Link : https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ Difficulty: Medium Premium: False Question Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree. Example 1: Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7] Example 2: Input: preorder = [-1], inorder = [-1] Output: [-1] Constraints: 1 <= preorder.length <= 3000 inorder.length == preorder.length -3000 <= preorder[i], inorder[i] <= 3000 preorder and inorder consist of unique values. Each value of inorder also appears in preorder. preorder is guaranteed to be the preorder traversal of the tree. inorder is guaranteed to be the inorder traversal of the tree. Solution Start by analyzing what information the preorder and inorder would tell us. Preorder gives us the order of all the nodes for us to build the tree, and inorder tells what the left and right tree is for a given node. We can use this to recursively buid a tree. Optimization would be to reduce the time spent in each recursive step. Code ''' Leetcode 0105. Construct Binary Tree from Preorder and Inorder Traversal Question Link : https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ Solution Link : https://tofucode.com/posts/leetcode_0105_construct-binary-tree-from-preorder-and-inorder-traversal.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def buildTree ( self , preorder : List [ int ], inorder : List [ int ]) -> Optional [ TreeNode ]: \"\"\" preorder = [3,9,20,15,7] node, left, right inorder = [9,3,15,20,7] left, node, right Time : O(n&#94;2) called n times, and inorder.index takes n Space: O(n&#94;2) \"\"\" if ( len ( inorder ) == 0 ): return None num = preorder . pop ( 0 ) idx = inorder . index ( num ) node = TreeNode ( num ) node . left = self . buildTree ( preorder , inorder [: idx ]) node . right = self . buildTree ( preorder , inorder [ idx + 1 :]) return node class SolutionImproved1 : def buildTree ( self , preorder : List [ int ], inorder : List [ int ]) -> Optional [ TreeNode ]: ''' map + recursion use a map to store num to idx Time : O(n) Space: O(n) ''' order_map = {} # num -> idx for i in range ( len ( inorder )): num = inorder [ i ] order_map [ num ] = i self . preorder_idx = 0 return self . build ( 0 , len ( preorder ) - 1 , preorder , order_map ) def build ( self , low , high , preorder , order_map ): ''' build Tree of the range (low, high) inclusive ''' if low > high : return None num = preorder [ self . preorder_idx ] node = TreeNode ( num ) idx = order_map [ num ] self . preorder_idx += 1 node . left = self . build ( low , idx - 1 , preorder , order_map ) node . right = self . build ( idx + 1 , high , preorder , order_map ) return node","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0105_construct-binary-tree-from-preorder-and-inorder-traversal.html","loc":"https://tofucode.com/posts/leetcode_0105_construct-binary-tree-from-preorder-and-inorder-traversal.html"},{"title":"Leetcode 0213. House Robber II","text":"Question Link : https://leetcode.com/problems/house-robber-ii/ Difficulty: Medium Premium: False Question You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: nums = [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2: Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 3: Input: nums = [1,2,3] Output: 3 Constraints: 1 <= nums.length <= 100 0 <= nums[i] <= 1000 Solution Given the extra restriction, turn that into two different cases that we would need to consider and find the max result between the two cases. Code ''' Leetcode 0213. House Robber II Question Link : https://leetcode.com/problems/house-robber-ii/ Solution Link : https://tofucode.com/posts/leetcode_0213_house-robber-ii.html ''' class Solution : def rob ( self , nums : List [ int ]) -> int : \"\"\" first and last one are adjacent: max(rob without first, rob without last) Time : O(n) Space: O(n) \"\"\" if len ( nums ) == 1 : return nums [ 0 ] return max ( self . robHouse1 ( nums [: - 1 ]), self . robHouse1 ( nums [ 1 :])) def robHouse1 ( self , nums : List [ int ]) -> int : \"\"\" nums = [1,2,3,1] 1 3 dp[i] = max amount of money at house i Time : O(n) Space: O(n) \"\"\" n = len ( nums ) dp = [ 0 ] * n for i in range ( n ): current = nums [ i ] if i == 0 : dp [ i ] = current elif i == 1 : dp [ i ] = max ( dp [ i - 1 ], current ) else : dp [ i ] = max ( dp [ i - 2 ] + current , dp [ i - 1 ]) return dp [ n - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0213_house-robber-ii.html","loc":"https://tofucode.com/posts/leetcode_0213_house-robber-ii.html"},{"title":"Leetcode 0062. Unique Paths","text":"Question Link : https://leetcode.com/problems/unique-paths/ Difficulty: Medium Premium: False Question There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Example 1: Input: m = 3, n = 7 Output: 28 Example 2: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -> Down -> Down 2. Down -> Down -> Right 3. Down -> Right -> Down Constraints: 1 <= m, n <= 100 Solution Since at ay point in the grid, the number of ways to get there depends on the getting to the last (up/left) position first and then making a move, this is a dp problem. the space complexity can be further reduced to a single row since we are only checking one row above. Code ''' Leetcode 0062. Unique Paths Question Link : https://leetcode.com/problems/unique-paths/ Solution Link : https://tofucode.com/posts/leetcode_0062_unique-paths.html ''' class Solution : def uniquePaths ( self , m : int , n : int ) -> int : \"\"\" 3 x 2 X _ _ _ _ Y dp[i][j] count of path up to i,j return dp[m-1][n-1] dp[i][j] = dp[i-1][j] + dp[i][j-1] # handle first row/col case Time : O(mn) Space: O(mn) \"\"\" dp = [[ 0 ] * n for x in range ( m )] for i in range ( m ): for j in range ( n ): if i == 0 or j == 0 : dp [ i ][ j ] = 1 else : dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] return dp [ m - 1 ][ n - 1 ] class SolutionImproved1 : def uniquePaths ( self , m : int , n : int ) -> int : \"\"\" 3 x 2 X _ _ _ _ Y flatten to a single row dp[j] count of path up to position j of current row return dp[n-1] dp[j] = dp[j] (last row) + dp[j-1] Time : O(mn) Space: O(n) \"\"\" dp = [ 0 ] * n for i in range ( m ): for j in range ( n ): if i == 0 or j == 0 : dp [ j ] = 1 else : dp [ j ] = dp [ j ] + dp [ j - 1 ] return dp [ n - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0062_unique-paths.html","loc":"https://tofucode.com/posts/leetcode_0062_unique-paths.html"},{"title":"Leetcode 0073. Set Matrix Zeroes","text":"Question Link : https://leetcode.com/problems/set-matrix-zeroes/ Difficulty: Medium Premium: False Question Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place. Example 1: Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2: Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] Constraints: m == matrix.length n == matrix[0].length 1 <= m, n <= 200 -231 <= matrix[i][j] <= 231 - 1 Follow up: A straightforward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? Solution Cleanest solution is to use two sets for row and col. To possibily save on space, one would need to store the information somewhere in the matrix itself: so for constant space solution, we can ues the first row and col to store which ones need to be set to zero. Code ''' Leetcode 0073. Set Matrix Zeroes Question Link : https://leetcode.com/problems/set-matrix-zeroes/ Solution Link : https://tofucode.com/posts/leetcode_0073_set-matrix-zeroes.html ''' class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : \"\"\" Do not return anything, modify matrix in-place instead. zero_rows = set() zero_cols = set() go through matrix, mark which rows and cols go through again, set those to zeros Time : O(mn) Space: O(m + n) \"\"\" rows = len ( matrix ) cols = len ( matrix [ 0 ]) if matrix else 0 zero_rows = set () zero_cols = set () for i in range ( rows ): for j in range ( cols ): if matrix [ i ][ j ] == 0 : zero_rows . add ( i ) zero_cols . add ( j ) continue for i in range ( rows ): for j in range ( cols ): if i in zero_rows or j in zero_cols : matrix [ i ][ j ] = 0 class SolutionImproved1 : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : \"\"\" Do not return anything, modify matrix in-place instead. first_row_all_zero = False first_col_all_zero = False use first row/col as storage, 2 bool to mark if they are also all zeros go through matrix, mark which rows and cols in first row/col go through, set to zero based on first row/col go through again for first_row_all_zero Time : O(mn) Space: O(1) \"\"\" rows = len ( matrix ) cols = len ( matrix [ 0 ]) if matrix else 0 first_row_all_zero = False first_col_all_zero = False # mark in fist row/col for i in range ( rows ): for j in range ( cols ): if matrix [ i ][ j ] == 0 : matrix [ 0 ][ j ] = 0 matrix [ i ][ 0 ] = 0 if i == 0 : first_row_all_zero = True if j == 0 : first_col_all_zero = True # set to zero for i in range ( rows ): for j in range ( cols ): if i == 0 or j == 0 : continue if matrix [ i ][ 0 ] == 0 or matrix [ 0 ][ j ] == 0 : matrix [ i ][ j ] = 0 # check if need to set all zeros for first row/col if first_row_all_zero : for j in range ( cols ): matrix [ 0 ][ j ] = 0 if first_col_all_zero : for i in range ( rows ): matrix [ i ][ 0 ] = 0","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0073_set-matrix-zeroes.html","loc":"https://tofucode.com/posts/leetcode_0073_set-matrix-zeroes.html"},{"title":"Leetcode 0091. Decode Ways","text":"Question Link : https://leetcode.com/problems/decode-ways/ Difficulty: Medium Premium: False Question You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping: \"1\" -> 'A' \"2\" -> 'B' ... \"25\" -> 'Y' \"26\" -> 'Z' However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\"). For example, \"11106\" can be decoded into: \"AAJF\" with the grouping (1, 1, 10, 6) \"KJF\" with the grouping (11, 10, 6) The grouping (1, 11, 06) is invalid because \"06\" is not a valid code (only \"6\" is valid). Note: there may be strings that are impossible to decode. Given a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0. The test cases are generated so that the answer fits in a 32-bit integer. Example 1: Input: s = \"12\" Output: 2 Explanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12). Example 2: Input: s = \"226\" Output: 3 Explanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Example 3: Input: s = \"06\" Output: 0 Explanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). In this case, the string is not a valid encoding, so return 0. Constraints: 1 <= s.length <= 100 s contains only digits and may contain leading zero(s). Solution The most apparent solution may be backtracking, need to take a bit of care to optimize space using index. Can also be solved iteratively with dp. Code ''' Leetcode 0091. Decode Ways Question Link : https://leetcode.com/problems/decode-ways/ Solution Link : https://tofucode.com/posts/leetcode_0091_decode-ways.html ''' class Solution : def numDecodings ( self , s : str ) -> int : ''' Use backtracking with memo to save on space: backtracking would need to return the number at that string instead of storing substring pass along index instead of string Time : O(n) Space: O(n) ''' self . seen = {} # string -> number return self . backtrack ( s , 0 ) def backtrack ( self , s , idx ): if idx >= len ( s ): return 1 if s [ idx ] == '0' : return 0 if idx in self . seen : return self . seen [ idx ] single = self . backtrack ( s , idx + 1 ) double = 0 if idx <= len ( s ) - 2 : if int ( s [ idx : idx + 2 ]) <= 26 : double = self . backtrack ( s , idx + 2 ) self . seen [ idx ] = single + double return single + double class SolutionAlternative1 : def numDecodings ( self , s : str ) -> int : \"\"\" backtracking, dp dp[i] ways upto and including index i 226 123 dp[i] = sum(dp[i-1] + dp[i-2]) check when valid Time : O(n) Space: O(n) \"\"\" n = len ( s ) dp = [ 0 ] * n for i in range ( n ): if i == 0 : dp [ i ] = 1 if self . isValid ( s [: 1 ]) else 0 else : if self . isValid ( s [ i : i + 1 ]): dp [ i ] = dp [ i - 1 ] if self . isValid ( s [ i - 1 : i + 1 ]): dp [ i ] += dp [ i - 2 ] if i >= 2 else 1 return dp [ n - 1 ] def isValid ( self , s : str ) -> bool : if not s or s [ 0 ] == '0' : return False num = int ( s ) return 1 <= num <= 26","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0091_decode-ways.html","loc":"https://tofucode.com/posts/leetcode_0091_decode-ways.html"},{"title":"Leetcode 0143. Reorder List","text":"Question Link : https://leetcode.com/problems/reorder-list/ Difficulty: Medium Premium: False Question You are given the head of a singly linked-list. The list can be represented as: L0 â L1 â â¦ â Ln - 1 â Ln Reorder the list to be on the following form: L0 â Ln â L1 â Ln - 1 â L2 â Ln - 2 â â¦ You may not modify the values in the list's nodes. Only nodes themselves may be changed. Example 1: Input: head = [1,2,3,4] Output: [1,4,2,3] Example 2: Input: head = [1,2,3,4,5] Output: [1,5,2,4,3] Constraints: The number of nodes in the list is in the range [1, 5 * 104]. 1 <= Node.val <= 1000 Solution A combination of finding middle of linked list + reversing a linked list + merging two lists. Code ''' Leetcode 0143. Reorder List Question Link : https://leetcode.com/problems/reorder-list/ Solution Link : https://tofucode.com/posts/leetcode_0143_reorder-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def reorderList ( self , head : Optional [ ListNode ]) -> None : \"\"\" Do not return anything, modify head in-place instead. split in half a,b (make a longer if odd number) reverse b re-merge a, b Time : O(n) Space: O(1) \"\"\" middle = self . getMiddle ( head ) second = self . reverse ( middle ) self . merge ( head , second ) def getMiddle ( self , head ): fast = head slow = head while fast and fast . next : fast = fast . next . next slow = slow . next return slow def reverse ( self , head ): \"\"\" last -> p -> p.next last <- p move last and p up \"\"\" p = head last = None while p : temp = p . next p . next = last last = p p = temp return last def merge ( self , first , second ): \"\"\" a1 a2 a3 b1 b2 a1 b1 a2 b2 \"\"\" while second . next : first . next , first = second , first . next second . next , second = first , second . next class SolutionAlternative1 : def reorderList ( self , head : Optional [ ListNode ]) -> None : \"\"\" Used a dict to help revere the list split in half a,b (make a longer if odd number) fast slow pointer reverse b re-merge a, b Time : O(n) Space: O(n) \"\"\" # find the middle fast = head slow = head while fast and fast . next : fast = fast . next . next slow = slow . next # reverse part b mid = slow parents = {} # node->parent last = None while slow : if slow . next : parents [ slow . next ] = slow else : last = slow slow = slow . next node = head # merge the two parts while last and node != mid : next_node = node . next node . next = last last . next = next_node last = parents . get ( last , None ) node = next_node # Break the last node's next pointer to prevent cycles if node : node . next = None","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0143_reorder-list.html","loc":"https://tofucode.com/posts/leetcode_0143_reorder-list.html"},{"title":"Leetcode 0152. Maximum Product Subarray","text":"Question Link : https://leetcode.com/problems/maximum-product-subarray/ Difficulty: Medium Premium: False Question Given an integer array nums, find a subarray that has the largest product, and return the product. The test cases are generated so that the answer will fit in a 32-bit integer. Example 1: Input: nums = [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2: Input: nums = [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Constraints: 1 <= nums.length <= 2 * 104 -10 <= nums[i] <= 10 The product of any subarray of nums is guaranteed to fit in a 32-bit integer. Solution The easier to think of solution is dp. This can also be done with a prefix-sum like way by calculating a running product: the important observation to make for this is that a subarray with max product would either start with the first or end with the last element, and zeros in the array would also be a start/end point. Code ''' Leetcode 0152. Maximum Product Subarray Question Link : https://leetcode.com/problems/maximum-product-subarray/ Solution Link : https://tofucode.com/posts/leetcode_0152_maximum-product-subarray.html ''' class Solution : def maxProduct ( self , nums : List [ int ]) -> int : \"\"\" positive: the more the better 0: would get 0 negative: even number get positive dp dp_max: max up to that number * current * last max * current (positives) * last min * current (2 negatives) dp_min: min up to that number * current * last min * current (negative x positive) * last max * current (negative x positive) Time : O(n) Space: O(1) \"\"\" n = len ( nums ) if n == 0 : return 0 # init dp_max dp_min dp_max = nums [ 0 ] dp_min = nums [ 0 ] result = nums [ 0 ] for i in range ( 1 , n ): num = nums [ i ] temp_max = max ( num , dp_max * num , dp_min * num ) dp_min = min ( num , dp_min * num , dp_max * num ) dp_max = temp_max result = max ( result , dp_max , dp_min ) return result class Solution : def maxProduct ( self , nums : List [ int ]) -> int : \"\"\" positive: the more the better 0: would get 0 - reset negative: even number get positive like prefix sum, if there are no 0: subarray with maximum product: start with the first element OR end with the last element So, do a running product from left-right and right-left left : left product right: right product if hit a 0, reset max product to current number Time : O(n) Space: O(1) \"\"\" n = len ( nums ) left = 0 right = 0 max_result = float ( '-inf' ) for i in range ( n ): if left == 0 : left = nums [ i ] else : left *= nums [ i ] if right == 0 : right = nums [ n - 1 - i ] else : right *= nums [ n - 1 - i ] max_result = max ( max_result , left , right ) return max_result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0152_maximum-product-subarray.html","loc":"https://tofucode.com/posts/leetcode_0152_maximum-product-subarray.html"},{"title":"Leetcode 0235. Lowest Common Ancestor of a Binary Search Tree","text":"Question Link : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ Difficulty: Medium Premium: False Question Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST. According to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\" Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Example 3: Input: root = [2,1], p = 2, q = 1 Output: 2 Constraints: The number of nodes in the tree is in the range [2, 105]. -109 <= Node.val <= 109 All Node.val are unique. p != q p and q will exist in the BST. Solution To simplify the solution of finding LCA of just a binary tree, we'd want to use the fact that this is a bst: the trick is to iterate through the tree and compare the current node value VS that of p/q, depending on that we can move current node left or right Code ''' Leetcode 0235. Lowest Common Ancestor of a Binary Search Tree Question Link : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ Solution Link : https://tofucode.com/posts/leetcode_0235_lowest-common-ancestor-of-a-binary-search-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution : def lowestCommonAncestor ( self , root : 'TreeNode' , p : 'TreeNode' , q : 'TreeNode' ) -> 'TreeNode' : \"\"\" BST traverse the tree. LCA of p and q: the LCA value would be between p value and q value if current value < p/q value: go right if current value > p/q value: go left Time : O(n) Space: O(1) \"\"\" p_val = p . val q_val = q . val node = root while node : current_val = node . val if current_val < p_val and current_val < q_val : # go right node = node . right elif current_val > p_val and current_val > q_val : # go left node = node . left else : # return LCA - first node where p/q is on left/right return node","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0235_lowest-common-ancestor-of-a-binary-search-tree.html","loc":"https://tofucode.com/posts/leetcode_0235_lowest-common-ancestor-of-a-binary-search-tree.html"},{"title":"Leetcode 0102. Binary Tree Level Order Traversal","text":"Question Link : https://leetcode.com/problems/binary-tree-level-order-traversal/ Difficulty: Medium Premium: False Question Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]] Example 2: Input: root = [1] Output: [[1]] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 <= Node.val <= 1000 Solution Since this is going layer by layer, the solution that stands out should be bfs Code ''' Leetcode 0102. Binary Tree Level Order Traversal Question Link : https://leetcode.com/problems/binary-tree-level-order-traversal/ Solution Link : https://tofucode.com/posts/leetcode_0102_binary-tree-level-order-traversal.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def levelOrder ( self , root : Optional [ TreeNode ]) -> List [ List [ int ]]: \"\"\" root root.l, root.r ll lr rl rr bfs by layer Time : O(n) Space: O(n) \"\"\" if not root : return [] layer = [ root ] result = [[ root . val ]] while layer : temp = [] for node in layer : if node . left : temp . append ( node . left ) if node . right : temp . append ( node . right ) layer = temp if layer : result . append ([ x . val for x in layer ]) return result # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class SolutionAlternative1 : def levelOrder ( self , root : Optional [ TreeNode ]) -> List [ List [ int ]]: ''' Use recursion and check if the list exists on that level Time : O(n) Space: O(n) ''' result = [] self . traverse ( root , 0 , result ) return result def traverse ( self , root , depth , result ): if root == None : return if depth <= len ( result ) - 1 : result [ depth ] = result [ depth ] + [ root . val ] else : result . append ([ root . val ]) self . traverse ( root . left , depth + 1 , result ) self . traverse ( root . right , depth + 1 , result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0102_binary-tree-level-order-traversal.html","loc":"https://tofucode.com/posts/leetcode_0102_binary-tree-level-order-traversal.html"},{"title":"Leetcode 0139. Word Break","text":"Question Link : https://leetcode.com/problems/word-break/ Difficulty: Medium Premium: False Question Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\". Example 2: Input: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"] Output: true Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] Output: false Constraints: 1 <= s.length <= 300 1 <= wordDict.length <= 1000 1 <= wordDict[i].length <= 20 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique. Solution Ideally solution is to use dfs where we track up to which index we can construct with words. An optimization to the word matching is to use a hashmap of first chat -> list of possible words, this makes it efficient to match a substring against a list of possible words. Code ''' Leetcode 0139. Word Break Question Link : https://leetcode.com/problems/word-break/ Solution Link : https://tofucode.com/posts/leetcode_0139_word-break.html ''' class Solution : def wordBreak ( self , s : str , wordDict : List [ str ]) -> bool : \"\"\" s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] cat sand og wordDict into a char -> [words] a -> and c -> cat, cats d -> dog s -> sand [0] cat: w_len = 3 next_idx = 3 [3] sandog cats: w_len = 4 next_idx = 4 [3,4] sandog, andog dfs starting with the fist char of s: check for cat, cats is at start of s: [idx 3 - sandog, idx 4 - andog] Time : O(nm + m) len(s) is n, len(wordDict) is m Space: O(n) \"\"\" words = {} # char -> [word list] for word in wordDict : c = word [ 0 ] words [ c ] = words . get ( c , []) + [ word ] stack = [ 0 ] seen = set () while stack : idx = stack . pop () if idx == len ( s ): return True substring = s [ idx :] if substring in seen : continue seen . add ( substring ) first_char = substring [ 0 ] possible_words = words . get ( first_char , []) for word in possible_words : w_len = len ( word ) next_idx = idx + w_len if next_idx <= len ( s ) and s [ idx : next_idx ] == word : stack . append ( next_idx ) return False class SolutionAlternative1 : def wordBreak ( self , s : str , wordDict : List [ str ]) -> bool : ''' Use dp dp[i] = if we can form s up to length of i dp[j] is True and s[j:i] is another word dp[i] is good Time : O(n&#94;2) Space: O(n) ''' n = len ( s ) words = set ( wordDict ) dp = [ False ] * ( n + 1 ) dp [ 0 ] = True for i in range ( 1 , n + 1 ): for j in range ( i ): if dp [ j ] and s [ j : i ] in words : dp [ i ] = True break return dp [ n ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0139_word-break.html","loc":"https://tofucode.com/posts/leetcode_0139_word-break.html"},{"title":"Leetcode 0207. Course Schedule","text":"Question Link : https://leetcode.com/problems/course-schedule/ Difficulty: Medium Premium: False Question There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return true if you can finish all courses. Otherwise, return false. Example 1: Input: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Example 2: Input: numCourses = 2, prerequisites = [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Constraints: 1 <= numCourses <= 2000 0 <= prerequisites.length <= 5000 prerequisites[i].length == 2 0 <= ai, bi < numCourses All the pairs prerequisites[i] are unique. Solution Identify this problem as a topological sorting problem and use bfs. Code ''' Leetcode 0207. Course Schedule Question Link : https://leetcode.com/problems/course-schedule/ Solution Link : https://tofucode.com/posts/leetcode_0207_course-schedule.html ''' class Solution : def canFinish ( self , numCourses : int , prerequisites : List [ List [ int ]]) -> bool : \"\"\" [0, 1], indicates that to take course 0 you have to first take course 1 1 -> 0 build a graph prerequisite -> next class topo sort - bfs Time : O(m + n) nodes + edges Space: O(m + n) \"\"\" # 1 init graph and in degrees graph = {} # node -> node in_degree = {} # node -> # of in coming edges for cla in range ( numCourses ): in_degree [ cla ] = 0 for cla , pre in prerequisites : graph [ pre ] = graph . get ( pre , []) + [ cla ] in_degree [ cla ] += 1 # 2 find the nodes with zero degree queue = deque ([ x for x in in_degree if in_degree [ x ] == 0 ]) # 3 bfs on the zero in degrees result = [] while queue : node = queue . popleft () result . append ( node ) for next_class in graph . get ( node , []): in_degree [ next_class ] -= 1 if in_degree [ next_class ] == 0 : queue . append ( next_class ) return len ( result ) == numCourses class SolutionAlternative1 : def canFinish ( self , numCourses : int , prerequisites : List [ List [ int ]]) -> bool : \"\"\" bfs processed per layer Time : O(m + n) nodes + edges Space: O(m + n) \"\"\" graph = {} # node -> [children] in_degree = {} # node -> number of in coming edges for c , p in prerequisites : graph [ p ] = graph . get ( p , []) + [ c ] in_degree [ c ] = in_degree . get ( c , 0 ) + 1 layer = [ i for i in range ( numCourses ) if not i in in_degree ] result = [] while layer : temp = [] for node in layer : result . append ( node ) for child in graph . get ( node , []): in_degree [ child ] -= 1 if in_degree [ child ] == 0 : temp . append ( child ) layer = temp return len ( result ) == numCourses","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0207_course-schedule.html","loc":"https://tofucode.com/posts/leetcode_0207_course-schedule.html"},{"title":"Leetcode 1162. As Far from Land as Possible","text":"Question Link : https://leetcode.com/problems/as-far-from-land-as-possible/ Difficulty: Medium Premium: False Question Given an n x n grid containing only values 0 and 1, where 0 represents water and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return -1. The distance used in this problem is the Manhattan distance: the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|. Example 1: Input: grid = [[1,0,1],[0,0,0],[1,0,1]] Output: 2 Explanation: The cell (1, 1) is as far as possible from all the land with distance 2. Example 2: Input: grid = [[1,0,0],[0,0,0],[0,0,0]] Output: 4 Explanation: The cell (2, 2) is as far as possible from all the land with distance 4. Constraints: n == grid.length n == grid[i].length 1 <= n <= 100 grid[i][j] is 0 or 1 Solution First instinct is that we would want to expand out from each land, then since different land may expand into the same cell, we'd want to use bfs to only record the min of each water cell to any land. then the result is to fin the max of all these recorded distances. Code ''' Leetcode 1162. As Far from Land as Possible Question Link : https://leetcode.com/problems/as-far-from-land-as-possible/ Solution Link : https://tofucode.com/posts/leetcode_1162_as-far-from-land-as-possible.html ''' class Solution : def maxDistance ( self , grid : List [ List [ int ]]) -> int : \"\"\" with a dequeue start at each land and bfs out all the 1s as the first layer distances 2d array to track distance to land init with -1 (all lands grid would return -1) per layer: if unvisited: set it up for next layer Time : O(n&#94;2) Space: O(n&#94;2) \"\"\" rows = len ( grid ) cols = len ( grid [ 0 ]) if rows else 0 distances = [[ - 1 ] * cols for x in range ( rows )] # distance to keep finding max direction = [( 1 , 0 ), ( - 1 , 0 ), ( 0 , 1 ), ( 0 , - 1 )] layer = [] for i in range ( rows ): for j in range ( cols ): if grid [ i ][ j ] == 1 : layer . append (( i , j , 1 )) queue = deque ( layer ) while queue : point = queue . popleft () x , y , d = point for offset in direction : nx = x + offset [ 0 ] ny = y + offset [ 1 ] if 0 <= nx < rows and 0 <= ny < cols : if grid [ nx ][ ny ] == 0 and distances [ nx ][ ny ] == - 1 : queue . append (( nx , ny , d + 1 )) distances [ nx ][ ny ] = d return max ([ max ( row ) for row in distances ]) class Solution : def maxDistance ( self , grid : List [ List [ int ]]) -> int : \"\"\" with a layered approach start at each land and bfs out all the 1s as the first layer distances 2d array to track distance to land init with -1 (all lands grid would return -1) per layer: if unvisited: set it up for next layer Time : O(n&#94;2) Space: O(n&#94;2) \"\"\" rows = len ( grid ) cols = len ( grid [ 0 ]) if rows else 0 distances = [[ - 1 ] * cols for x in range ( rows )] # distance to keep finding max direction = [( 1 , 0 ), ( - 1 , 0 ), ( 0 , 1 ), ( 0 , - 1 )] layer = [] for i in range ( rows ): for j in range ( cols ): if grid [ i ][ j ] == 1 : layer . append (( i , j )) current_distance = 1 while layer : temp = [] for point in layer : x , y = point for offset in direction : nx = x + offset [ 0 ] ny = y + offset [ 1 ] if 0 <= nx < rows and 0 <= ny < cols : if grid [ nx ][ ny ] == 0 and distances [ nx ][ ny ] == - 1 : temp . append (( nx , ny )) distances [ nx ][ ny ] = current_distance current_distance += 1 layer = temp return max ([ max ( row ) for row in distances ])","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1162_as-far-from-land-as-possible.html","loc":"https://tofucode.com/posts/leetcode_1162_as-far-from-land-as-possible.html"},{"title":"Leetcode 0238. Product of Array Except Self","text":"Question Link : https://leetcode.com/problems/product-of-array-except-self/ Difficulty: Medium Premium: False Question Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints: 2 <= nums.length <= 105 -30 <= nums[i] <= 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.) Solution Like subset sum where we maintain a trailling sum array here we want a trailling product array from both left and right in order to get the product of the two from both the left and right hand side of i. Code ''' Leetcode 0238. Product of Array Except Self Question Link : https://leetcode.com/problems/product-of-array-except-self/ Solution Link : https://tofucode.com/posts/leetcode_0238_product-of-array-except-self.html ''' class Solution : def productExceptSelf ( self , nums : List [ int ]) -> List [ int ]: \"\"\" Thought process: brute force solution would be n&#94;2 for each number go through all others for the product To save the information of products, we'd want to save the info start by writing out: continuous product from left to right and right to left the answer and how each is formed as a product from the 4 numbers abcd (a b c d) [1 2 3 4] [1 2 6 24] # left (a ab abc abcd) [24 24 12 4] # right (abcd bcd cd d) [24 12 8 6] # answer (bcd acd abd abc) The patten can be seen that everything needed to construct answer is already calculated in left and right array Time : O(n) Space: O(n) \"\"\" n = len ( nums ) left = [] right = [] for i in range ( n ): l = nums [ i ] r = nums [ n - 1 - i ] if i != 0 : l *= left [ - 1 ] r *= right [ - 1 ] left . append ( l ) right . append ( r ) right = right [:: - 1 ] # reverse right as it's added rom right to left result = [] for i in range ( n ): if i == 0 : result . append ( right [ 1 ]) elif i == n - 1 : result . append ( left [ n - 2 ]) else : result . append ( left [ i - 1 ] * right [ i + 1 ]) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0238_product-of-array-except-self.html","loc":"https://tofucode.com/posts/leetcode_0238_product-of-array-except-self.html"},{"title":"Leetcode 0055. Jump Game","text":"Question Link : https://leetcode.com/problems/jump-game/ Difficulty: Medium Premium: False Question You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Example 1: Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints: 1 <= nums.length <= 104 0 <= nums[i] <= 105 Solution Easiest solution is to greedily track the max index that can be jumped to. Code ''' Leetcode 0055. Jump Game Question Link : https://leetcode.com/problems/jump-game/ Solution Link : https://tofucode.com/posts/leetcode_0055_jump-game.html ''' class Solution : def canJump ( self , nums : List [ int ]) -> bool : \"\"\" greedy jump: maintain a single max reachable index Time : O(n) Space: O(1) \"\"\" jump = 0 # max reachable index so far for i in range ( len ( nums )): if jump < i : return False jump = max ( jump , i + nums [ i ]) return jump >= len ( nums ) - 1 class SolutionAlternative1 : def canJump ( self , nums : List [ int ]) -> bool : \"\"\" [2,3,1,1,4] * * dp = [False] * n [2,3,1,1,4] T F F F F T T T T T T T return dp[n-1] Time : O(n&#94;2) Space: O(n) \"\"\" n = len ( nums ) dp = [ False ] * n dp [ 0 ] = True for i in range ( n ): if not dp [ i ]: # never get to here return False jump = nums [ i ] for j in range ( i + 1 , i + 1 + jump ): if j >= n - 1 : return True dp [ j ] = True return dp [ n - 1 ] class SolutionAlternative2 : def canJump ( self , nums : List [ int ]) -> bool : ''' Use DFS pathh finding Time : O(n + m) m - the number of vertexes can get too big (jump is big) Space: O(n) ''' if len ( nums ) == 0 : return False stack = [ 0 ] # idx seen = set () while True : if len ( stack ) == 0 : return False idx = stack . pop () if idx == len ( nums ) - 1 : return True if idx in seen : continue jump = nums [ idx ] for i in range ( jump ): current = idx + i + 1 if current >= len ( nums ): break if current not in seen : stack . append ( current ) seen . add ( idx ) return False","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0055_jump-game.html","loc":"https://tofucode.com/posts/leetcode_0055_jump-game.html"},{"title":"Leetcode 0048. Rotate Image","text":"Question Link : https://leetcode.com/problems/rotate-image/ Difficulty: Medium Premium: False Question You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2: Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] Constraints: n == matrix.length == matrix[i].length 1 <= n <= 20 -1000 <= matrix[i][j] <= 1000 Solution The most aparent solution is to rotate the change 4 cells at a time, but this is hard to calculate the indexes and bounds. A trick is to reverse the whole matrix up tp down using reverse(), and then swap against the diagonal. Code ''' Leetcode 0048. Rotate Image Question Link : https://leetcode.com/problems/rotate-image/ Solution Link : https://tofucode.com/posts/leetcode_0048_rotate-image.html ''' class Solution : def rotate ( self , matrix : List [ List [ int ]]) -> None : \"\"\" Do not return anything, modify matrix in-place instead. in place matrix = [[1,2,3],[4,5,6],[7,8,9]] matrix = [ [5,1,9,11], [2,4,8,10], [13,3,6,7], [15,14,12,16] ] 1 -> 10 -> 12 -> 13 -> 1 up -> right -> down -> left -> up 1 (0, 1) (i, j) 10 (1, 3) (j, n-1-i) 12 (3, 2) (n-1-i, n-1-j) 13 (2, 0) (n-1-j , i) outer loop i: the first half innter loop j: layer by layer inwards Time : O(n&#94;2) Space: O(1) \"\"\" n = len ( matrix ) for i in range ( n // 2 ): for j in range ( i , n - 1 - i ): up = matrix [ i ][ j ] right = matrix [ j ][ n - 1 - i ] down = matrix [ n - 1 - i ][ n - 1 - j ] left = matrix [ n - 1 - j ][ i ] matrix [ i ][ j ] = left # left -> up matrix [ j ][ n - 1 - i ] = up # up -> right matrix [ n - 1 - i ][ n - 1 - j ] = right # right -> down matrix [ n - 1 - j ][ i ] = down # down -> left class SolutionImproved1 : def rotate ( self , matrix : List [ List [ int ]]) -> None : ''' clockwise rotate first reverse up to down, then swap the symmetry along the 7-5-3 1 2 3 7 8 9 7 4 1 4 5 6 => 4 5 6 => 8 5 2 7 8 9 1 2 3 9 6 3 anticlockwise rotate first reverse left to right, then swap the symmetry 1 2 3 3 2 1 3 6 9 4 5 6 => 6 5 4 => 2 5 8 7 8 9 9 8 7 1 4 7 Time : O(n&#94;2) Space: O(1) ''' matrix . reverse () for i in range ( len ( matrix )): for j in range ( i ): matrix [ i ][ j ], matrix [ j ][ i ] = matrix [ j ][ i ], matrix [ i ][ j ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0048_rotate-image.html","loc":"https://tofucode.com/posts/leetcode_0048_rotate-image.html"},{"title":"Leetcode 0128. Longest Consecutive Sequence","text":"Question Link : https://leetcode.com/problems/longest-consecutive-sequence/ Difficulty: Medium Premium: False Question Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time. Example 1: Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2: Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 Constraints: 0 <= nums.length <= 105 -109 <= nums[i] <= 109 Solution This first solution that comes to mind may be sorting. A better alternative is to first transform the nums into a set, and then use each number in the set as a possible start of sequence and check. Code ''' Leetcode 0128. Longest Consecutive Sequence Question Link : https://leetcode.com/problems/longest-consecutive-sequence/ Solution Link : https://tofucode.com/posts/leetcode_0128_longest-consecutive-sequence.html ''' class Solution : def longestConsecutive ( self , nums : List [ int ]) -> int : \"\"\" build a set, and then only do counting up for each number Time : O(n) Space: O(n) \"\"\" num_set = set ( nums ) result = 0 for num in num_set : if num - 1 in num_set : # not start of a sequence continue count = 1 current = num while current + 1 in num_set : current += 1 count += 1 result = max ( result , count ) return result class SolutionAlternative1 : def longestConsecutive ( self , nums : List [ int ]) -> int : \"\"\" [100,4,200,1,3,2] sort 1, 2, 3 ,4 , go through and check Time : O(n log n) Space: O(n) \"\"\" if not nums : return 0 sorted_nums = sorted ( nums ) count = 1 result = 1 for i in range ( 1 , len ( sorted_nums )): if sorted_nums [ i ] == sorted_nums [ i - 1 ]: continue if sorted_nums [ i ] - 1 == sorted_nums [ i - 1 ]: count += 1 else : result = max ( result , count ) count = 1 # do one last check if it ends with consecuive result = max ( result , count ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0128_longest-consecutive-sequence.html","loc":"https://tofucode.com/posts/leetcode_0128_longest-consecutive-sequence.html"},{"title":"Leetcode 0053. Maximum Subarray","text":"Question Link : https://leetcode.com/problems/maximum-subarray/ Difficulty: Medium Premium: False Question Given an integer array nums, find the subarray with the largest sum, and return its sum. Example 1: Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: The subarray [4,-1,2,1] has the largest sum 6. Example 2: Input: nums = [1] Output: 1 Explanation: The subarray [1] has the largest sum 1. Example 3: Input: nums = [5,4,-1,7,8] Output: 23 Explanation: The subarray [5,4,-1,7,8] has the largest sum 23. Constraints: 1 <= nums.length <= 105 -104 <= nums[i] <= 104 Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Solution Can eaither use subset-sum or more cleanly just a single var dp to keep track of current sub array sum. Code ''' Leetcode 0053. Maximum Subarray Question Link : https://leetcode.com/problems/maximum-subarray/ Solution Link : https://tofucode.com/posts/leetcode_0053_maximum-subarray.html ''' class Solution : def maxSubArray ( self , nums : List [ int ]) -> int : \"\"\" subset sum [-2, 1, -3, 4, -1, 2, 1, -5, 4] -2 -1 -4 0 -1 1 2 -3 1 2 - -4 = 6 look for: num - previous min not mono stack Time : O(n) Space: O(n) \"\"\" running = [] for num in nums : if len ( running ) == 0 : running . append ( num ) else : running . append ( num + running [ - 1 ]) result = - math . inf seen_min = 0 for num in running : result = max ( result , num - seen_min ) seen_min = min ( seen_min , num ) return result class SolutionImproved1 : def maxSubArray ( self , nums : List [ int ]) -> int : \"\"\" # Kadane Algorithm [-2, 1, -3, 4, -1, 2, 1, -5, 4] -2 -1 -4 0 -1 1 2 -3 1 2 - -4 = 6 dp: current sub array sum continue adding OR start fromm current num Time : O(n) Space: O(1) \"\"\" dp = 0 result = - math . inf for num in nums : dp = max ( num , dp + num ) result = max ( result , dp ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0053_maximum-subarray.html","loc":"https://tofucode.com/posts/leetcode_0053_maximum-subarray.html"},{"title":"Leetcode 0003. Longest Substring Without Repeating Characters","text":"Question Link : https://leetcode.com/problems/longest-substring-without-repeating-characters/ Difficulty: Medium Premium: False Question Given a string s, find the length of the longest substring without repeating characters. Example 1: Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Constraints: 0 <= s.length <= 5 * 104 s consists of English letters, digits, symbols and spaces. Solution Typical sliding window problem, where the window here maintains the longest substring. Code ''' Leetcode 0003. Longest Substring Without Repeating Characters Question Link : https://leetcode.com/problems/longest-substring-without-repeating-characters/ Solution Link : https://tofucode.com/posts/leetcode_0003_longest-substring-without-repeating-characters.html ''' class Solution : def lengthOfLongestSubstring ( self , s : str ) -> int : \"\"\" abcabcbb abc sliding window set() in it each char apears once result = len of sliding window l = 0 r = 1 move right to set up window if repeat: move left up continue move right till the end Time : O(n) Space: O(1) max is alphabet \"\"\" l = 0 seen = set () result = 0 for r in range ( len ( s )): r_char = s [ r ] while seen and r_char in seen : l_char = s [ l ] seen . remove ( l_char ) l += 1 seen . add ( r_char ) result = max ( result , len ( seen )) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0003_longest-substring-without-repeating-characters.html","loc":"https://tofucode.com/posts/leetcode_0003_longest-substring-without-repeating-characters.html"},{"title":"Leetcode 0054. Spiral Matrix","text":"Question Link : https://leetcode.com/problems/spiral-matrix/ Difficulty: Medium Premium: False Question Given an m x n matrix, return all elements of the matrix in spiral order. Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 10 -100 <= matrix[i][j] <= 100 Solution Can either go cell by cell or row / col by row / col. Code ''' Leetcode 0054. Spiral Matrix Question Link : https://leetcode.com/problems/spiral-matrix/ Solution Link : https://tofucode.com/posts/leetcode_0054_spiral-matrix.html ''' class Solution : def spiralOrder ( self , matrix : List [ List [ int ]]) -> List [ int ]: \"\"\" start at 0, 0 go same as last direction if can't go, change direction state: right, down, left, up change direction if next tile is already visited Time : O(mn) Space: O(mn) \"\"\" rows = len ( matrix ) cols = len ( matrix [ 0 ]) if matrix else 0 seen = set () result = [] r = 0 c = 0 # right direction = ( 0 , 1 ) while len ( seen ) < rows * cols : result . append ( matrix [ r ][ c ]) seen . add (( r , c )) next_move = self . move ( r , c , direction , rows , cols , seen ) if next_move : r , c , direction = next_move return result def move ( self , r , c , direction , rows , cols , seen ): # try to move one step in current direction dr , dc = direction next_r = r + dr next_c = c + dc if self . isValid ( next_r , next_c , rows , cols , seen ): return next_r , next_c , direction # change direction next_direction = self . getDirection ( direction ) dr , dc = next_direction next_r = r + dr next_c = c + dc if self . isValid ( next_r , next_c , rows , cols , seen ): return next_r , next_c , next_direction def isValid ( self , r , c , rows , cols , seen ): return 0 <= r < rows and 0 <= c < cols and ( r , c ) not in seen def getDirection ( self , direction ): mapping = { ( 0 , 1 ): ( 1 , 0 ), ( 1 , 0 ): ( 0 , - 1 ), ( 0 , - 1 ): ( - 1 , 0 ), ( - 1 , 0 ): ( 0 , 1 ) } return mapping [ direction ] class SolutionImproved1 : def spiralOrder ( self , matrix : List [ List [ int ]]) -> List [ int ]: \"\"\" process per row / col at a time instead of cell by cell use 4 inclusive marks to mark Time : O(mn) Space: O(mn) \"\"\" if not matrix : return [] rows = len ( matrix ) cols = len ( matrix [ 0 ]) if rows != 0 else 0 result = [] left = 0 right = cols - 1 up = 0 down = rows - 1 while True : # row -> result . extend ( matrix [ up ][ left : right + 1 ]) up += 1 if up == down + 1 : break # col down result . extend ([ row [ right ] for row in matrix ][ up : down + 1 ]) right -= 1 if left == right + 1 : break # row <- result . extend ( matrix [ down ][ left : right + 1 ][:: - 1 ]) down -= 1 if up == down + 1 : break # col up result . extend ([ row [ left ] for row in matrix ][ up : down + 1 ][:: - 1 ]) left += 1 if left == right + 1 : break return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0054_spiral-matrix.html","loc":"https://tofucode.com/posts/leetcode_0054_spiral-matrix.html"},{"title":"Leetcode 0253. Meeting Rooms II","text":"Question Link : https://leetcode.com/problems/meeting-rooms-ii/ Difficulty: Medium Premium: True Question Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required. Example 1: Input: intervals = [[0,30],[5,10],[15,20]] Output: 2 Example 2: Input: intervals = [[7,10],[2,4]] Output: 1 Constraints: 1 <= intervals.length <= 104 0 <= starti < endi <= 106 Solution Can be done with doing interval merge with a pq or heap, or can be seen as a interval overlap problem. Code ''' Leetcode 0253. Meeting Rooms II Question Link : https://leetcode.com/problems/meeting-rooms-ii/ Solution Link : https://tofucode.com/posts/leetcode_0253_meeting-rooms-ii.html ''' from queue import PriorityQueue class Solution : def minMeetingRooms ( self , intervals : List [ List [ int ]]) -> int : \"\"\" [0,30],[5,10],[15,20] 2 rooms: [0,30] [5,10],[15,20] first sort by starting time keep a list of a rooms in a pq with end time, merge end time add [0,30] [30] add [5,10] [10, 30] add [15,20] [20, 30] return len(rooms) only need to check first of pq if can merge: update end time else: add a new room Time : O(n log n) Space: O(n) \"\"\" if not intervals : return 0 intervals = sorted ( intervals ) q = PriorityQueue () q . put ( 0 ) # init with 0 end time for i in range ( len ( intervals )): start , end = intervals [ i ] last_end = q . get () if start >= last_end : q . put ( end ) else : q . put ( last_end ) q . put ( end ) return q . qsize () class SolutionAlternative1 : def minMeetingRooms ( self , intervals : List [ List [ int ]]) -> int : \"\"\" stacking the intervals on x axis of: 0 -> infinity check overlap [0,30],[5,10],[15,20] [0, 30] [5,10],[15,20] +. +. - +. - - 0: 1 5: 1 10: -1 15: 1 20: -1 30: -1 we want to count max vertical overlap: track changes at time go through and set up: changes = {} # time -> (+1 for start, -1 for end) go through changes from 0 -> infinity record max overlap Time : O(n log n) Space: O(n) \"\"\" changes = {} # time -> (+1 , -1) for start , end in intervals : changes [ start ] = changes . get ( start , 0 ) + 1 changes [ end ] = changes . get ( end , 0 ) - 1 result = 0 count = 0 for k in sorted ( changes . keys ()): count += changes [ k ] result = max ( result , count ) return result","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0253_meeting-rooms-ii.html","loc":"https://tofucode.com/posts/leetcode_0253_meeting-rooms-ii.html"},{"title":"Leetcode 0121. Best Time to Buy and Sell Stock","text":"Question Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ Difficulty: Easy Premium: False Question You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Constraints: 1 <= prices.length <= 105 0 <= prices[i] <= 104 Solution The basic template / origin of buy and sell stock dp questions. Can use this as a template. Space can be compressed to a single var as we only use the last. Code ''' Leetcode 0121. Best Time to Buy and Sell Stock Question Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ Solution Link : https://tofucode.com/posts/leetcode_0121_best-time-to-buy-and-sell-stock.html ''' class Solution : def maxProfit ( self , prices : List [ int ]) -> int : ''' [Template] 1 buy and 1 sell dp[i] = max profit on/passed index i of prices return dp[n-1] [7,1,5,3,6,4] buy 1 sell 6 profit is 5 Time : O(n) Space: O(n) ''' n = len ( prices ) dp = [ 0 ] * n buy = math . inf for i in range ( n ): p = prices [ i ] buy = min ( buy , p ) last = dp [ i - 1 ] if i > 0 else 0 if p > buy : dp [ i ] = max ( last , p - buy ) else : dp [ i ] = last return dp [ n - 1 ] class SolutionImproved1 : def maxProfit ( self , prices : List [ int ]) -> int : ''' 1 buy and 1 sell last = highest profit so far compress to a single var, since we only care about last Time : O(n) Space: O(1) ''' n = len ( prices ) last = 0 buy = math . inf for i in range ( n ): p = prices [ i ] buy = min ( buy , p ) last = max ( last , p - buy ) return last","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0121_best-time-to-buy-and-sell-stock.html","loc":"https://tofucode.com/posts/leetcode_0121_best-time-to-buy-and-sell-stock.html"},{"title":"Leetcode 0122. Best Time to Buy and Sell Stock II","text":"Question Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ Difficulty: Medium Premium: False Question You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve. Example 1: Input: prices = [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Total profit is 4 + 3 = 7. Example 2: Input: prices = [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Total profit is 4. Example 3: Input: prices = [7,6,4,3,1] Output: 0 Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0. Constraints: 1 <= prices.length <= 3 * 104 0 <= prices[i] <= 104 Solution Same as stock 1 with another greedy solution which is also efficient. Code ''' Leetcode 0122. Best Time to Buy and Sell Stock II Question Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ Solution Link : https://tofucode.com/posts/leetcode_0122_best-time-to-buy-and-sell-stock-ii.html ''' class Solution : def maxProfit ( self , prices : List [ int ]) -> int : \"\"\" multiple buy and sell - hold 1 dp[i] = max profit at idx i of prices return dp[n-1] Time : O(n) Space: O(n) \"\"\" n = len ( prices ) dp = [ 0 ] * n buy = math . inf for i in range ( n ): p = prices [ i ] buy = min ( buy , p ) last = dp [ i - 1 ] if i > 0 else 0 if p > buy : dp [ i ] = last + ( p - buy ) buy = p else : dp [ i ] = last return dp [ n - 1 ] class SolutionImproved1 : def maxProfit ( self , prices : List [ int ]) -> int : \"\"\" multiple buy and sell - hold 1 last = highest profit so far Time : O(n) Space: O(1) \"\"\" n = len ( prices ) last = 0 buy = math . inf for i in range ( n ): p = prices [ i ] buy = min ( buy , p ) if p > buy : last += ( p - buy ) buy = p return last class SolutionImproved2 : def maxProfit ( self , prices : List [ int ]) -> int : \"\"\" multiple buy and sell - hold 1 greedy: always buy and sell if the prices goes up Time : O(n) Space: O(1) \"\"\" n = len ( prices ) total = 0 for i in range ( n - 1 ): p1 = prices [ i ] p2 = prices [ i + 1 ] if p2 > p1 : total += p2 - p1 return total","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0122_best-time-to-buy-and-sell-stock-ii.html","loc":"https://tofucode.com/posts/leetcode_0122_best-time-to-buy-and-sell-stock-ii.html"},{"title":"Leetcode 0123. Best Time to Buy and Sell Stock III","text":"Question Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ Difficulty: Hard Premium: False Question You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete at most two transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: Input: prices = [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: prices = [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Constraints: 1 <= prices.length <= 105 0 <= prices[i] <= 105 Solution The fastest solution to write can been built using stock 1. Improvements inlucde the same space compression and a new state machine method. Code ''' Leetcode 0123. Best Time to Buy and Sell Stock III Question Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ Solution Link : https://tofucode.com/posts/leetcode_0123_best-time-to-buy-and-sell-stock-iii.html ''' class Solution : def maxProfit ( self , prices : List [ int ]) -> int : \"\"\" 1: buy1, sell1 2: buy2, sell2 for buy2: account for previous profit buy2 = min( buy2, p - previous_profit ) previous_profit: profit from the first transaction p - previous_profit: using the first profit to lower the cost of the second [3, 3, 5, 0, 0, 3, 1, 4] p [0, 0, 2, 2, 2, 3, 3, 4] dp1 (profit: 4) [0, 0, 2, 2, 2, 5, 5, 6] dp2 (profit: 2 + 4) buy2. -2 profit2. 2 -2 2 -2 5 (3 - -2) -2 5 -2 6 Time : O(n) Space: O(n) \"\"\" n = len ( prices ) dp1 = self . maxProfitFromOneBuy ( prices , n , None ) dp2 = self . maxProfitFromOneBuy ( prices , n , dp1 ) return dp2 [ n - 1 ] def maxProfitFromOneBuy ( self , prices , n , previous ): dp = [ 0 ] * n buy = math . inf for i in range ( n ): p = prices [ i ] previous_profit = previous [ i ] if previous else 0 buy = min ( buy , p - previous_profit ) last = dp [ i - 1 ] if i > 0 else 0 if p > buy : dp [ i ] = max ( last , p - buy ) else : dp [ i ] = last return dp class SolutionImproved1 : def maxProfit ( self , prices : List [ int ]) -> int : \"\"\" cut to one loop and single var Time : O(n) Space: O(n) \"\"\" last1 = 0 last2 = 0 buy1 = math . inf buy2 = math . inf for i in range ( len ( prices )): p = prices [ i ] buy1 = min ( buy1 , p ) last1 = max ( last1 , p - buy1 ) buy2 = min ( buy2 , p - last1 ) last2 = max ( last2 , p - buy2 ) return last2 class SolutionImproved2 : def maxProfit ( self , prices : List [ int ]) -> int : \"\"\" state machine 4 states: buy1 -> sell1 -> buy2 -> sell2 record profit buy1: after first buy sell1: after first sell buy2: after second buy sell2: after second sell init: buy: -infinity sell: 0 profit transition: buy1: buy or keep previous bought state sell1: sell or keep state buy2: buy or keep state sell2: sell or keep state Time : O(n) Space: O(1) \"\"\" buy1 = - math . inf buy2 = - math . inf sell1 = 0 sell2 = 0 for i in range ( len ( prices )): p = prices [ i ] buy1 = max ( buy1 , - p ); sell1 = max ( sell1 , buy1 + p ); buy2 = max ( buy2 , sell1 - p ); sell2 = max ( sell2 , buy2 + p ); return sell2","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0123_best-time-to-buy-and-sell-stock-iii.html","loc":"https://tofucode.com/posts/leetcode_0123_best-time-to-buy-and-sell-stock-iii.html"},{"title":"Leetcode 0188. Best Time to Buy and Sell Stock IV","text":"Question Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ Difficulty: Hard Premium: False Question You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: Input: k = 2, prices = [2,4,1] Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: Input: k = 2, prices = [3,2,6,5,0,3] Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Constraints: 1 <= k <= 100 1 <= prices.length <= 1000 0 <= prices[i] <= 1000 Solution Can be extended from stock 3, where stock 3 only does two transactions, and here we do k. Code ''' Leetcode 0188. Best Time to Buy and Sell Stock IV Question Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ Solution Link : https://tofucode.com/posts/leetcode_0188_best-time-to-buy-and-sell-stock-iv.html ''' class Solution : def maxProfit ( self , k : int , prices : List [ int ]) -> int : \"\"\" Extend stock-iii two loop approach Time : O(nk) Space : O(nk) \"\"\" if not prices or k == 0 : return 0 n = len ( prices ) dp = [ self . maxProfitFromOneBuy ( prices , n , None ) for _ in range ( k )] for j in range ( 1 , k ): dp [ j ] = self . maxProfitFromOneBuy ( prices , n , dp [ j - 1 ]) return dp [ k - 1 ][ n - 1 ] def maxProfitFromOneBuy ( self , prices , n , previous ): dp = [ 0 ] * n buy = math . inf for i in range ( n ): p = prices [ i ] previous_profit = previous [ i ] if previous else 0 buy = min ( buy , p - previous_profit ) last = dp [ i - 1 ] if i > 0 else 0 if p > buy : dp [ i ] = max ( last , p - buy ) else : dp [ i ] = last return dp class SolutionImproved1 : def maxProfit ( self , k : int , prices : List [ int ]) -> int : \"\"\" Extend stock-iii one loop and single var Time : O(n) Space: O(n) \"\"\" last = [ 0 ] * k buy = [ math . inf ] * k for i in range ( len ( prices )): p = prices [ i ] for j in range ( k ): previous_last = last [ j - 1 ] if j > 0 else 0 buy [ j ] = min ( buy [ j ], p - previous_last ) last [ j ] = max ( last [ j ], p - buy [ j ]) return last [ k - 1 ] class SolutionImproved2 : def maxProfit ( self , k : int , prices : List [ int ]) -> int : \"\"\" Extend stock-iii State machine buy1 -> sell1 -> ... Time : O(nk) Space: O(k) \"\"\" buy = [ - math . inf ] * k sell = [ 0 ] * k for i in range ( len ( prices )): for j in range ( k ): p = prices [ i ] last_sell = sell [ j - 1 ] if j > 0 else 0 buy [ j ] = max ( buy [ j ], last_sell - p ); sell [ j ] = max ( sell [ j ], buy [ j ] + p ); return sell [ k - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0188_best-time-to-buy-and-sell-stock-iv.html","loc":"https://tofucode.com/posts/leetcode_0188_best-time-to-buy-and-sell-stock-iv.html"},{"title":"Leetcode 0309. Best Time to Buy and Sell Stock with Cooldown","text":"Question Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ Difficulty: Medium Premium: False Question You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions: After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day). Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Example 1: Input: prices = [1,2,3,0,2] Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] Example 2: Input: prices = [1] Output: 0 Constraints: 1 <= prices.length <= 5000 0 <= prices[i] <= 1000 Solution Similiar to other stock problems, state machine approach is a good way to solve this. Code ''' Leetcode 0309. Best Time to Buy and Sell Stock with Cooldown Question Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ Solution Link : https://tofucode.com/posts/leetcode_0309_best-time-to-buy-and-sell-stock-with-cooldown.html ''' class Solution : def maxProfit ( self , prices : List [ int ]) -> int : \"\"\" state machine hold (max profit of keep holding OR buying) sell (max profit of sellign) cooldown (max profit of staying in cooldown OR from previous sell) Time : O(n) Space: O(1) \"\"\" n = len ( prices ) hold = - math . inf sell = 0 cooldown = 0 for i in range ( n ): prev_hold = hold prev_sell = sell hold = max ( hold , cooldown - prices [ i ]) sell = prev_hold + prices [ i ] cooldown = max ( cooldown , prev_sell ) return max ( sell , cooldown )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0309_best-time-to-buy-and-sell-stock-with-cooldown.html","loc":"https://tofucode.com/posts/leetcode_0309_best-time-to-buy-and-sell-stock-with-cooldown.html"},{"title":"Leetcode 0338. Counting Bits","text":"Question Link : https://leetcode.com/problems/counting-bits/ Difficulty: Easy Premium: False Question Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i. Example 1: Input: n = 2 Output: [0,1,1] Explanation: 0 --> 0 1 --> 1 2 --> 10 Example 2: Input: n = 5 Output: [0,1,1,2,1,2] Explanation: 0 --> 0 1 --> 1 2 --> 10 3 --> 11 4 --> 100 5 --> 101 Constraints: 0 <= n <= 105 Follow up: It is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass? Can you do it without using any built-in function (i.e., like __builtin_popcount in C++)? Solution The brute force solution can be written with bin() function in python to get the string representation of the binary. On observation we need to identify how one numbers 1 count can be calculated from previous number's 1 counts - and use dp to help improve runtime. Code ''' Leetcode 0338. Counting Bits Question Link : https://leetcode.com/problems/counting-bits/ Solution Link : https://tofucode.com/posts/leetcode_0338_counting-bits.html ''' class Solution : def countBits ( self , n : int ) -> List [ int ]: \"\"\" length of array: n + 1 idx binary number of 1 0 0 0 1 01 1 2 10 1 3 11 2 4 100 1 5 101 2 Use bin() and count the 1s Time : O(n * bin()) Space: O(n) \"\"\" result = [] for i in range ( n + 1 ): count = 0 for c in str ( bin ( i )): if c == '1' : count += 1 result . append ( count ) return result class SolutionImproved1 : def countBits ( self , n : int ) -> List [ int ]: \"\"\" length of array: n + 1 idx binary number of 1 0 0 0 1 01 1 2 10 1 3 11 2 4 100 1 5 101 2 dp depending on how many 1s on the last number dp[i] = for i: even: last bit is 0, dp[i >> 1] right shift i to use previous recorded dp odd: last number i-1 is odd: just + 1 base: dp[0] = 0 Time : O(n) Space: O(n) \"\"\" dp = [ 0 ] * ( n + 1 ) for i in range ( 1 , n + 1 ): if i % 2 == 0 : dp [ i ] = dp [ i >> 1 ] else : dp [ i ] = dp [ i - 1 ] + 1 return dp","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0338_counting-bits.html","loc":"https://tofucode.com/posts/leetcode_0338_counting-bits.html"},{"title":"Leetcode 2832. Maximal Range That Each Element Is Maximum in It","text":"Question Link : https://leetcode.com/problems/maximal-range-that-each-element-is-maximum-in-it/ Difficulty: Medium Premium: True Question You are given a 0-indexed array nums of distinct integers. Let us define a 0-indexed array ans of the same length as nums in the following way: ans[i] is the maximum length of a subarray nums[l..r], such that the maximum element in that subarray is equal to nums[i]. Return the array ans. Note that a subarray is a contiguous part of the array. Example 1: Input: nums = [1,5,4,3,6] Output: [1,4,2,1,5] Explanation: For nums[0] the longest subarray in which 1 is the maximum is nums[0..0] so ans[0] = 1. For nums[1] the longest subarray in which 5 is the maximum is nums[0..3] so ans[1] = 4. For nums[2] the longest subarray in which 4 is the maximum is nums[2..3] so ans[2] = 2. For nums[3] the longest subarray in which 3 is the maximum is nums[3..3] so ans[3] = 1. For nums[4] the longest subarray in which 6 is the maximum is nums[0..4] so ans[4] = 5. Example 2: Input: nums = [1,2,3,4,5] Output: [1,2,3,4,5] Explanation: For nums[i] the longest subarray in which it's the maximum is nums[0..i] so ans[i] = i + 1. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 105 All elements in nums are distinct. Solution Given that we are trying to find the next larger element than the current, one should identify this as a monotonic stack problem. Can be further simplifed into a sinle for loop. Code ''' Leetcode 2832. Maximal Range That Each Element Is Maximum in It Question Link : https://leetcode.com/problems/maximal-range-that-each-element-is-maximum-in-it/ Solution Link : https://tofucode.com/posts/leetcode_2832_maximal-range-that-each-element-is-maximum-in-it.html ''' class Solution : def maximumLengthOfRanges ( self , nums : List [ int ]) -> List [ int ]: \"\"\" [1,5,4,3,6] [1,4,2,1,5] 0: 1 [1] 1: 4 [1,5,4,3] 2: 2 [4,3] brute force: for each number go left and right till hit a bigger number or the end record length preprocess with a mono stack for each number: want the higher of it to the left / right range = right - left - 1 Time : O(n) Space: O(n) \"\"\" n = len ( nums ) # index of the highest to the left / right left = [ 0 ] * n right = [ 0 ] * n stack = [] # index # left for i in range ( n ): while stack and nums [ stack [ - 1 ]] < nums [ i ]: stack . pop () left [ i ] = stack [ - 1 ] if stack else - 1 stack . append ( i ) stack = [] # clear the stack # right for i in range ( n - 1 , - 1 , - 1 ): while stack and nums [ stack [ - 1 ]] < nums [ i ]: stack . pop () right [ i ] = stack [ - 1 ] if stack else n stack . append ( i ) # Calculate for each element result = [ 0 ] * n for i in range ( n ): result [ i ] = right [ i ] - left [ i ] - 1 return result class SolutionImproved1 : def maximumLengthOfRanges ( self , nums : List [ int ]) -> List [ int ]: \"\"\" [1,5,4,3,6] [1,4,2,1,5] 0: 1 [1] 1: 4 [1,5,4,3] 2: 2 [4,3] brute force: for each number go left and right till hit a bigger number or the end record length preprocess with a mono stack pop whenever we hit a right hand bound for i: right = i left = keep poping the stack untill it's smaller range = right - left - 1 Time : O(n) Space: O(n) \"\"\" stack = [] n = len ( nums ) result = [ 0 ] * n for i in range ( n + 1 ): # add a inf to the end to make sure to clear the stack num = nums [ i ] if i < n else math . inf while stack and nums [ stack [ - 1 ]] < num : idx = stack . pop () val = nums [ idx ] left = stack [ - 1 ] if stack else - 1 right = i result [ idx ] = right - left - 1 stack . append ( i ) return result","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_2832_maximal-range-that-each-element-is-maximum-in-it.html","loc":"https://tofucode.com/posts/leetcode_2832_maximal-range-that-each-element-is-maximum-in-it.html"},{"title":"Leetcode 0125. Valid Palindrome","text":"Question Link : https://leetcode.com/problems/valid-palindrome/ Difficulty: Easy Premium: False Question A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise. Example 1: Input: s = \"A man, a plan, a canal: Panama\" Output: true Explanation: \"amanaplanacanalpanama\" is a palindrome. Example 2: Input: s = \"race a car\" Output: false Explanation: \"raceacar\" is not a palindrome. Example 3: Input: s = \" \" Output: true Explanation: s is an empty string \"\" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome. Constraints: 1 <= s.length <= 2 * 105 s consists only of printable ASCII characters. Solution A cleaner to read solution would be to preprocess the string and then check with left and right pointers. To save space, we can also do the check on the original string. Code ''' Leetcode 0125. Valid Palindrome Question Link : https://leetcode.com/problems/valid-palindrome/ Solution Link : https://tofucode.com/posts/leetcode_0125_valid-palindrome.html ''' class Solution : def isPalindrome ( self , s : str ) -> bool : \"\"\" 1. preprocess string: lower case, remove non chars 2. two poointers from front and end Time : O(n) Space: O(n) \"\"\" chars = [ c . lower () for c in s if c . isalnum ()] # simple reverse check # return chars == chars[::-1] l = 0 r = len ( chars ) - 1 while l <= r : c1 = chars [ l ] c2 = chars [ r ] if c1 != c2 : return False l += 1 r -= 1 return True class SolutionImproved1 : def isPalindrome ( self , s : str ) -> bool : ''' in place with while loops Time : O(n) Space: O(1) ''' l = 0 r = len ( s ) - 1 while l < r : while l < r and not s [ l ] . isalnum (): l += 1 while l < r and not s [ r ] . isalnum (): r -= 1 if s [ l ] . lower () != s [ r ] . lower (): return False l += 1 r -= 1 return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0125_valid-palindrome.html","loc":"https://tofucode.com/posts/leetcode_0125_valid-palindrome.html"},{"title":"Leetcode 0191. Number of 1 Bits","text":"Question Link : https://leetcode.com/problems/number-of-1-bits/ Difficulty: Easy Premium: False Question Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight). Example 1: Input: n = 11 Output: 3 Explanation: The input binary string 1011 has a total of three set bits. Example 2: Input: n = 128 Output: 1 Explanation: The input binary string 10000000 has a total of one set bit. Example 3: Input: n = 2147483645 Output: 30 Explanation: The input binary string 1111111111111111111111111111101 has a total of thirty set bits. Constraints: 1 <= n <= 231 - 1 Follow up: If this function is called many times, how would you optimize it? Solution Keep checking the right most bit if it's a 1. Code ''' Leetcode 0191. Number of 1 Bits Question Link : https://leetcode.com/problems/number-of-1-bits/ Solution Link : https://tofucode.com/posts/leetcode_0191_number-of-1-bits.html ''' class Solution : def hammingWeight ( self , n : int ) -> int : ''' check if right most least sig bit is 1: n & 1 Right shift n by 1 bit to process the next bit: n = n >> 1 Time : O(n) Space: O(1) ''' result = 0 while n > 0 : if n & 1 : result += 1 n = n >> 1 return result class SolutionAlternative1 : def hammingWeight ( self , n : int ) -> int : ''' Turn into a binary string with bin() and count the 1s Time : O(n) Space: O(1) ''' return bin ( n ) . count ( '1' )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0191_number-of-1-bits.html","loc":"https://tofucode.com/posts/leetcode_0191_number-of-1-bits.html"},{"title":"Leetcode 0242. Valid Anagram","text":"Question Link : https://leetcode.com/problems/valid-anagram/ Difficulty: Easy Premium: False Question Given two strings s and t, return true if t is an anagram of s, and false otherwise. Example 1: Input: s = \"anagram\", t = \"nagaram\" Output: true Example 2: Input: s = \"rat\", t = \"car\" Output: false Constraints: 1 <= s.length, t.length <= 5 * 104 s and t consist of lowercase English letters. Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case? Solution Use a dict to couunt the frequency of chars in the strings. Code ''' Leetcode 0242. Valid Anagram Question Link : https://leetcode.com/problems/valid-anagram/ Solution Link : https://tofucode.com/posts/leetcode_0242_valid-anagram.html ''' class Solution : def isAnagram ( self , s : str , t : str ) -> bool : \"\"\" have a counts = {} # letter -> count go through s: add to counts go through t: remove from counts at the end counts should be empty Time : O(n) n is max length of s and t Space: O(1) \"\"\" counts = {} for c in s : counts [ c ] = counts . get ( c , 0 ) + 1 for c in t : counts [ c ] = counts . get ( c , 0 ) - 1 if counts [ c ] < 0 : return False if counts [ c ] == 0 : del counts [ c ] return len ( counts ) == 0","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0242_valid-anagram.html","loc":"https://tofucode.com/posts/leetcode_0242_valid-anagram.html"},{"title":"Leetcode 2182. Construct String With Repeat Limit","text":"Question Link : https://leetcode.com/problems/construct-string-with-repeat-limit/ Difficulty: Medium Premium: False Question You are given a string s and an integer repeatLimit. Construct a new string repeatLimitedString using the characters of s such that no letter appears more than repeatLimit times in a row. You do not have to use all characters from s. Return the lexicographically largest repeatLimitedString possible. A string a is lexicographically larger than a string b if in the first position where a and b differ, string a has a letter that appears later in the alphabet than the corresponding letter in b. If the first min(a.length, b.length) characters do not differ, then the longer string is the lexicographically larger one. Example 1: Input: s = \"cczazcc\", repeatLimit = 3 Output: \"zzcccac\" Explanation: We use all of the characters from s to construct the repeatLimitedString \"zzcccac\". The letter 'a' appears at most 1 time in a row. The letter 'c' appears at most 3 times in a row. The letter 'z' appears at most 2 times in a row. Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString. The string is the lexicographically largest repeatLimitedString possible so we return \"zzcccac\". Note that the string \"zzcccca\" is lexicographically larger but the letter 'c' appears more than 3 times in a row, so it is not a valid repeatLimitedString. Example 2: Input: s = \"aababab\", repeatLimit = 2 Output: \"bbabaa\" Explanation: We use only some of the characters from s to construct the repeatLimitedString \"bbabaa\". The letter 'a' appears at most 2 times in a row. The letter 'b' appears at most 2 times in a row. Hence, no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString. The string is the lexicographically largest repeatLimitedString possible so we return \"bbabaa\". Note that the string \"bbabaaa\" is lexicographically larger but the letter 'a' appears more than 2 times in a row, so it is not a valid repeatLimitedString. Constraints: 1 <= repeatLimit <= s.length <= 105 s consists of lowercase English letters. Solution Since we want to greedily pick out the bigest chars, we can use a priority queue for this - which is a maxHeap. For the maxHeap - use a negative to achieve it with python's min heap implementation. Code ''' Leetcode 2182. Construct String With Repeat Limit Question Link : https://leetcode.com/problems/construct-string-with-repeat-limit/ Solution Link : https://tofucode.com/posts/leetcode_2182_construct-string-with-repeat-limit.html ''' class Solution : def repeatLimitedString ( self , s : str , repeatLimit : int ) -> str : \"\"\" no letter appears more than repeatLimit times in a row as long as possible s = \"cczazcc\", repeatLimit = 3 a: 1 c: 4 z: 2 zz ccc a c s = \"aababab\", repeatLimit = 2 a: 4 b: 3 bb a b aa 1. count chars in c: counts = [0] # char(0: 1, 25:z) -> count. 2. greedy: z - a take max repeatLimit, start at idx = 25 take max char[idx] take a single idx-1 if hit limit take max char[idx] priority queue to always take the biggest chars Time : O(n * log m) m unique chars Space: O(n) space for resulting string \"\"\" counts = {} # char -> count pq = MaxHeap () # store (offset, count, char) for c in s : counts [ c ] = counts . get ( c , 0 ) + 1 for c , count in counts . items (): pq . push ( c , count ) result = [] while pq . isNotEmpty (): offset , count , c = pq . pop () take = min ( count , repeatLimit ) remain = count - take result . append ( c * take ) # if there are more and can keep going, take a filler if remain > 0 and pq . isNotEmpty (): next_offset , next_count , next_c = pq . pop () result . append ( next_c ) if next_count > 1 : pq . push ( next_c , next_count - 1 ) pq . push ( c , remain ) return '' . join ( result ) class MaxHeap : def __init__ ( self ): self . pq = [] def push ( self , c , count ): offset = ord ( c ) - ord ( 'a' ) heapq . heappush ( self . pq , ( - offset , - count , c )) def pop ( self ): offset , count , c = heapq . heappop ( self . pq ) return ( - offset , - count , c ) def isNotEmpty ( self ): return len ( self . pq ) > 0","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2182_construct-string-with-repeat-limit.html","loc":"https://tofucode.com/posts/leetcode_2182_construct-string-with-repeat-limit.html"},{"title":"Leetcode 0572. Subtree of Another Tree","text":"Question Link : https://leetcode.com/problems/subtree-of-another-tree/ Difficulty: Easy Premium: False Question Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself. Example 1: Input: root = [3,4,5,1,2], subRoot = [4,1,2] Output: true Example 2: Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] Output: false Constraints: The number of nodes in the root tree is in the range [1, 2000]. The number of nodes in the subRoot tree is in the range [1, 1000]. -104 <= root.val <= 104 -104 <= subRoot.val <= 104 Solution The easiest way to solve this is probably to solve it as a serialization problem with having to think about the edge cases of how to deal with null nodes or starting of a node. Code ''' Leetcode 0572. Subtree of Another Tree Question Link : https://leetcode.com/problems/subtree-of-another-tree/ Solution Link : https://tofucode.com/posts/leetcode_0572_subtree-of-another-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def isSubtree ( self , root : Optional [ TreeNode ], subRoot : Optional [ TreeNode ]) -> bool : \"\"\" traverse and write root to a string check subRoot in root edge case: 12## vs 2## 2## would be in 12## use another char to specify node start @12## vs @2## #: Null node @: node start Time : O(m+n) Time : O(m+n) \"\"\" s_root = self . traverse ( root ) s_sub = self . traverse ( subRoot ) return s_sub in s_root def traverse ( self , node ): if not node : return \"#\" return '@' + str ( node . val ) + self . traverse ( node . left ) + self . traverse ( node . right ) class SolutionAlternative1 : def isSubtree ( self , root : Optional [ TreeNode ], subRoot : Optional [ TreeNode ]) -> bool : \"\"\" check if root is subRoot OR recursively check: root.right, root.left brute force Time : O(mn) n in root, m in subRoot Time : O(m+n) \"\"\" if not root : return False return self . isEqual ( root , subRoot ) or self . isSubtree ( root . left , subRoot ) or self . isSubtree ( root . right , subRoot ) def isEqual ( self , a , b ): if a is None and b is None : return True if ( a is None ) &#94; ( b is None ): return False if a . val != b . val : return False return self . isEqual ( a . left , b . left ) and self . isEqual ( a . right , b . right )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0572_subtree-of-another-tree.html","loc":"https://tofucode.com/posts/leetcode_0572_subtree-of-another-tree.html"},{"title":"Leetcode 3264. Final Array State After K Multiplication Operations I","text":"Question Link : https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-i/ Difficulty: Easy Premium: False Question You are given an integer array nums, an integer k, and an integer multiplier. You need to perform k operations on nums. In each operation: Find the minimum value x in nums. If there are multiple occurrences of the minimum value, select the one that appears first. Replace the selected minimum value x with x * multiplier. Return an integer array denoting the final state of nums after performing all k operations. Example 1: Input: nums = [2,1,3,5,6], k = 5, multiplier = 2 Output: [8,4,6,5,6] Explanation: Operation Result After operation 1 [2, 2, 3, 5, 6] After operation 2 [4, 2, 3, 5, 6] After operation 3 [4, 4, 3, 5, 6] After operation 4 [4, 4, 6, 5, 6] After operation 5 [8, 4, 6, 5, 6] Example 2: Input: nums = [1,2], k = 3, multiplier = 4 Output: [16,8] Explanation: Operation Result After operation 1 [4, 2] After operation 2 [4, 8] After operation 3 [16, 8] Constraints: 1 <= nums.length <= 100 1 <= nums[i] <= 100 1 <= k <= 10 1 <= multiplier <= 5 Solution Can use a priority queue to improve the runtime. Code ''' Leetcode 3264. Final Array State After K Multiplication Operations I Question Link : https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-i/ Solution Link : https://tofucode.com/posts/leetcode_3264_final-array-state-after-k-multiplication-operations-i.html ''' class Solution : def getFinalState ( self , nums : List [ int ], k : int , multiplier : int ) -> List [ int ]: \"\"\" Time : O(kn) Space: O(1) \"\"\" for i in range ( k ): min_idx = 0 for j in range ( len ( nums )): if nums [ j ] < nums [ min_idx ]: min_idx = j nums [ min_idx ] *= multiplier return nums class SolutionImproved1 : def getFinalState ( self , nums : List [ int ], k : int , multiplier : int ) -> List [ int ]: \"\"\" Since we are always looking for the min in each loop, use a priority queue instead Time : O(n + klogn) Space: O(n) \"\"\" pq = [( nums [ i ], i ) for i in range ( len ( nums ))] heapify ( pq ) for _ in range ( k ): _ , i = heappop ( pq ) nums [ i ] *= multiplier heappush ( pq , ( nums [ i ], i )) return nums","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_3264_final-array-state-after-k-multiplication-operations-i.html","loc":"https://tofucode.com/posts/leetcode_3264_final-array-state-after-k-multiplication-operations-i.html"},{"title":"Leetcode 1673. Find the Most Competitive Subsequence","text":"Question Link : https://leetcode.com/problems/find-the-most-competitive-subsequence/ Difficulty: Medium Premium: False Question Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k. An array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array. We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b. For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number, and 4 is less than 5. Example 1: Input: nums = [3,5,2,6], k = 2 Output: [2,6] Explanation: Among the set of every possible subsequence: {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]}, [2,6] is the most competitive. Example 2: Input: nums = [2,4,3,3,5,4,9,6], k = 4 Output: [2,3,3,4] Constraints: 1 <= nums.length <= 105 0 <= nums[i] <= 109 1 <= k <= nums.length Solution Since a subsequence does not need to be connected here, we want to use a monotonic stack that is incresing to try front load the smaller numbers. Code ''' Leetcode 1673. Find the Most Competitive Subsequence Question Link : https://leetcode.com/problems/find-the-most-competitive-subsequence/ Solution Link : https://tofucode.com/posts/leetcode_1673_find-the-most-competitive-subsequence.html ''' class Solution : def mostCompetitive ( self , nums : List [ int ], k : int ) -> List [ int ]: \"\"\" nums: k elements subsequence : competitive: smaller first nums = [2,4,3,3,5,4,9,6], k = 4 2. 3 3 4 if 1 4 9 6 2 if 1 9 6 maintain the first 2 mono stack: go through nums and add num to stack we want smaller up front if increasing: add it if not increasing: keep poping till: can add num to maintain mono stack OR can maintain at least k size stack till the end Time : O(n) Space: O(n) \"\"\" if not nums : return [] stack = [] for i in range ( len ( nums )): num = nums [ i ] if not stack or num > stack [ - 1 ]: stack . append ( num ) else : remaining_count = len ( nums ) - i - 1 # -1 for current num while stack and num < stack [ - 1 ]: if len ( stack ) + remaining_count < k : break stack . pop () stack . append ( num ) return stack [: k ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1673_find-the-most-competitive-subsequence.html","loc":"https://tofucode.com/posts/leetcode_1673_find-the-most-competitive-subsequence.html"},{"title":"Leetcode 0015. 3Sum","text":"Question Link : https://leetcode.com/problems/3sum/ Difficulty: Medium Premium: False Question Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. Example 1: Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter. Example 2: Input: nums = [0,1,1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3: Input: nums = [0,0,0] Output: [[0,0,0]] Explanation: The only possible triplet sums up to 0. Constraints: 3 <= nums.length <= 3000 -105 <= nums[i] <= 105 Solution Break this down to a two sum problem + an extra number. Where that extra number means an extra for loop where we can fix a number each loop. Code ''' Leetcode 0015. 3Sum Question Link : https://leetcode.com/problems/3sum/ Solution Link : https://tofucode.com/posts/leetcode_0015_3sum.html ''' class Solution : def threeSum ( self , nums : List [ int ]) -> List [ List [ int ]]: \"\"\" 3 different numbers sum == 0 a, b, c for every number as a: solve two sum(b, c) - get all possible two sums sorted(a, b, c) check for dups: 1. skip dups for a 2. sorted(a, b , c) when adding to result Time : O(n&#94;2) Space: O(n) \"\"\" result = set () # set of duples ((a, b,c)) dups = set () for i in range ( len ( nums )): a = nums [ i ] if a in dups : continue dups . add ( a ) target = 0 - a two_sum = self . getAllTwoSums ( nums , i + 1 , target ) if two_sum : for b , c in two_sum : r = tuple ( sorted ([ a , b , c ])) result . add ( r ) return [ list ( x ) for x in result ] def getAllTwoSums ( self , nums , start , target ): seen = {} # number -> index result = [] for i in range ( start , len ( nums )): num = nums [ i ] remain = target - num if remain in seen : result . append (( num , remain )) seen [ num ] = i return result class SolutionAlternative1 : def threeSum ( self , nums : List [ int ]) -> List [ List [ int ]]: ''' Basically for each number go through the rest and look for it's target with 2 pointers Checking for consecutive same number prevents duplicates using two pointers prevents duplicate reuse of the same instance of a number Time: O(n&#94;2) Space: O(1) just for result ''' if len ( nums ) < 3 : return [] nums = sorted ( nums ) result = [] for i in range ( len ( nums )): # skip duplicates for i if i > 0 and nums [ i ] == nums [ i - 1 ]: continue self . findTwoSum ( nums , i , result ) return result def findTwoSum ( self , nums , i , result ): target = - 1 * nums [ i ] l = i + 1 r = len ( nums ) - 1 while l < r : s = nums [ l ] + nums [ r ] if s == target : result . append ([ nums [ i ], nums [ l ], nums [ r ]]) l += 1 r -= 1 # skip duplicates for l and r after it's used while l < r and nums [ l ] == nums [ l - 1 ]: l += 1 while l < r and nums [ r ] == nums [ r + 1 ]: r -= 1 elif s < target : l += 1 else : r -= 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0015_3sum.html","loc":"https://tofucode.com/posts/leetcode_0015_3sum.html"},{"title":"Leetcode 0297. Serialize and Deserialize Binary Tree","text":"Question Link : https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ Difficulty: Hard Premium: False Question Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Example 1: Input: root = [1,2,3,null,null,4,5] Output: [1,2,3,null,null,4,5] Example 2: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 104]. -1000 <= Node.val <= 1000 Solution use preorder traversal with a queue as we want to pop from the front. Use a special symbol for Null cases. Code ''' Leetcode 0297. Serialize and Deserialize Binary Tree Question Link : https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0297_serialize-and-deserialize-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Codec : \"\"\" Use preorder traversal Note: * take care of the None when going to a string and back * you don't need another inorder traversal as long as the deserizlization is constrcted the same way \"\"\" def serialize ( self , root ): \"\"\"Encodes a tree to a single string. :type root: TreeNode :rtype: str \"\"\" result = [] self . traversePreorder ( root , result ) return str ( result ) def deserialize ( self , data ): \"\"\"Decodes your encoded data to tree. :type data: str :rtype: TreeNode \"\"\" info = data . strip () . replace ( '[' , '' ) . replace ( ']' , '' ) preorder = [ x . strip () for x in info . split ( ',' )] queue = collections . deque ( preorder ) return self . buildPreorder ( queue ) def traversePreorder ( self , node , result ): if node == None : result . append ( '#' ) return result . append ( node . val ) self . traversePreorder ( node . left , result ) self . traversePreorder ( node . right , result ) def buildPreorder ( self , queue ): # Use preorder array to find the root and then preorder to build the tree # ['1', '2', \"'#'\", \"'#'\", '3', '4', \"'#'\", \"'#'\", '5', \"'#'\", \"'#'\"] # '#' has the extra quote cause it was initially a string and got serialized with them val = queue . popleft () if val == \"'#'\" : return None node = TreeNode ( int ( val )) node . left = self . buildPreorder ( queue ) node . right = self . buildPreorder ( queue ) return node # Your Codec object will be instantiated and called as such: # ser = Codec() # deser = Codec() # ans = deser.deserialize(ser.serialize(root))","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0297_serialize-and-deserialize-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0297_serialize-and-deserialize-binary-tree.html"},{"title":"Leetcode 0426. Convert Binary Search Tree to Sorted Doubly Linked List","text":"Question Link : https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/ Difficulty: Medium Premium: True Question Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place. You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element. We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list. Example 1: Input: root = [4,2,5,1,3] Output: [1,2,3,4,5] Explanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship. Example 2: Input: root = [2,1,3] Output: [1,2,3] Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 <= Node.val <= 1000 All the values of the tree are unique. Solution Find the traversal that fits the case here: in order traversal. We traverse the list and then link all the nodes together. Code ''' Leetcode 0426. Convert Binary Search Tree to Sorted Doubly Linked List Question Link : https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/ Solution Link : https://tofucode.com/posts/leetcode_0426_convert-binary-search-tree-to-sorted-doubly-linked-list.html ''' \"\"\" # Definition for a Node. class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right \"\"\" class Solution : def treeToDoublyList ( self , root : 'Optional[Node]' ) -> 'Optional[Node]' : \"\"\" in order traversal: left, node, right go through and link everything up Time : O(n) Space: O(n) \"\"\" if not root : return root self . nodes = [] self . traverse ( root ) for i in range ( 1 , len ( self . nodes )): self . nodes [ i - 1 ] . right = self . nodes [ i ] self . nodes [ i ] . left = self . nodes [ i - 1 ] # last one link with the first self . nodes [ - 1 ] . right = self . nodes [ 0 ] self . nodes [ 0 ] . left = self . nodes [ - 1 ] return self . nodes [ 0 ] def traverse ( self , node ): if not node : return self . traverse ( node . left ) self . nodes . append ( node ) self . traverse ( node . right )","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0426_convert-binary-search-tree-to-sorted-doubly-linked-list.html","loc":"https://tofucode.com/posts/leetcode_0426_convert-binary-search-tree-to-sorted-doubly-linked-list.html"},{"title":"Leetcode 0033. Search in Rotated Sorted Array","text":"Question Link : https://leetcode.com/problems/search-in-rotated-sorted-array/ Difficulty: Medium Premium: False Question There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity. Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 Example 3: Input: nums = [1], target = 0 Output: -1 Constraints: 1 <= nums.length <= 5000 -104 <= nums[i] <= 104 All values of nums are unique. nums is an ascending array that is possibly rotated. -104 <= target <= 104 Solution This can be done with one binary search with modified conditions to account for the rotation. Alternatively one can use 3 binary searches: one to find the rotation point and one each on each side. Code ''' Leetcode 0033. Search in Rotated Sorted Array Question Link : https://leetcode.com/problems/search-in-rotated-sorted-array/ Solution Link : https://tofucode.com/posts/leetcode_0033_search-in-rotated-sorted-array.html ''' class Solution : def search ( self , nums : List [ int ], target : int ) -> int : \"\"\" [0,1,2|4,5,6,7] [4,5,6,7|0,1,2] binary search accouting for the rotation [4,5,6,7|0,1,2] l. r l m r l m r [5,1,3] l m r l r Time : O(log n) Space: O(1) \"\"\" if not nums : return - 1 left = 0 right = len ( nums ) - 1 while left < right : mid = ( left + right ) // 2 if nums [ mid ] == target : return mid if nums [ left ] <= nums [ mid ]: # right order if nums [ left ] <= target < nums [ mid ]: right = mid else : left = mid + 1 else : # flipped order if nums [ mid ] <= target <= nums [ right ]: left = mid + 1 else : right = mid return left if nums [ left ] == target else - 1 class SolutionAlternative1 : def search ( self , nums : List [ int ], target : int ) -> int : \"\"\" [0,1,2|4,5,6,7] [4,5,6,7|0,1,2] binary search twice 1. find the index of rotation: the right part is ordered correctly: compare mid against nums[-1] 2.3. run on the left / right of rotation (0, idx) or (idx, n) need to check both eg: [3,1] target = 3 Time : O(log n) Space: O(1) \"\"\" idx = self . findSmallest ( nums ) i = self . binarySearch ( nums , 0 , idx - 1 , target ) if i != - 1 : return i return self . binarySearch ( nums , idx , len ( nums ) - 1 , target ) def binarySearch ( self , nums , l , r , target ): left = l right = r while left < right : mid = ( left + right ) // 2 if nums [ mid ] < target : left = mid + 1 else : right = mid return left if nums [ left ] == target else - 1 def findSmallest ( self , nums ): left = 0 right = len ( nums ) - 1 target = nums [ - 1 ] while left < right : mid = ( left + right ) // 2 if nums [ mid ] > target : left = mid + 1 else : right = mid return left","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0033_search-in-rotated-sorted-array.html","loc":"https://tofucode.com/posts/leetcode_0033_search-in-rotated-sorted-array.html"},{"title":"Leetcode 0034. Find First and Last Position of Element in Sorted Array","text":"Question Link : https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ Difficulty: Medium Premium: False Question Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Example 3: Input: nums = [], target = 0 Output: [-1,-1] Constraints: 0 <= nums.length <= 105 -109 <= nums[i] <= 109 nums is a non-decreasing array. -109 <= target <= 109 Solution A trick is for finding the right bound: we can look for target + 1 and then take -1 off of the index. With this we can just use the same normal binary search. Otherwise we 'd need to construct a binary sarch with considering different conditions. Code ''' Leetcode 0034. Find First and Last Position of Element in Sorted Array Question Link : https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ Solution Link : https://tofucode.com/posts/leetcode_0034_find-first-and-last-position-of-element-in-sorted-array.html ''' class Solution : def searchRange ( self , nums : List [ int ], target : int ) -> List [ int ]: \"\"\" normal binary search 1. search for target 2. search for target + 1 : get position and then -1 for the index Time : O(log n) Space: O(1) \"\"\" if not nums : return [ - 1 , - 1 ] left = self . binarySearch ( nums , target ) right = self . binarySearch ( nums , target + 1 ) - 1 if left <= right : return [ left , right ] return [ - 1 , - 1 ] def binarySearch ( self , nums , target ): left = 0 right = len ( nums ) while left < right : mid = ( left + right ) // 2 if nums [ mid ] < target : left = mid + 1 else : right = mid return left class SolutionAlternative1 : def searchRange ( self , nums : List [ int ], target : int ) -> List [ int ]: \"\"\" binary search [5,7,7,8,8,10], target = 8 l m r l m r go_left: l r l not go_left: l m r 1 search to find left bound, 1 for right bound Time : O(log n) Space: O(1) \"\"\" if not nums : return [ - 1 , - 1 ] l = self . get_insert_index ( nums , target , True ) if l == - 1 : return [ - 1 , - 1 ] r = self . get_insert_index ( nums , target , False ) return [ l , r ] def get_insert_index ( self , nums , target , go_left ): left = 0 right = len ( nums ) - 1 while left < right : mid = ( left + right ) // 2 if target == nums [ mid ]: if go_left : # found left bound if nums [ mid - 1 ] < target : return mid # search left right = mid - 1 else : # found right bound if nums [ mid + 1 ] > target : return mid # Search right left = mid + 1 elif nums [ mid ] < target : left = mid + 1 else : right = mid return left if nums [ left ] == target else - 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0034_find-first-and-last-position-of-element-in-sorted-array.html","loc":"https://tofucode.com/posts/leetcode_0034_find-first-and-last-position-of-element-in-sorted-array.html"},{"title":"Leetcode 0035. Search Insert Position","text":"Question Link : https://leetcode.com/problems/search-insert-position/ Difficulty: Easy Premium: False Question Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. Example 1: Input: nums = [1,3,5,6], target = 5 Output: 2 Example 2: Input: nums = [1,3,5,6], target = 2 Output: 1 Example 3: Input: nums = [1,3,5,6], target = 7 Output: 4 Constraints: 1 <= nums.length <= 104 -104 <= nums[i] <= 104 nums contains distinct values sorted in ascending order. -104 <= target <= 104 Solution Binary search. Need to note when not found, we want to return the insert position Code ''' Leetcode 0035. Search Insert Position Question Link : https://leetcode.com/problems/search-insert-position/ Solution Link : https://tofucode.com/posts/leetcode_0035_search-insert-position.html ''' class Solution : def searchInsert ( self , nums : List [ int ], target : int ) -> int : \"\"\" Binary search: consider edge cases at the end nums = [1,3,5,6], target = 7 [1,3,5,6] l r l m r l r l Time : O(log n) Space: O(1) \"\"\" left = 0 right = len ( nums ) while left < right : mid = ( left + right ) // 2 if nums [ mid ] < target : left = mid + 1 else : right = mid return left","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0035_search-insert-position.html","loc":"https://tofucode.com/posts/leetcode_0035_search-insert-position.html"},{"title":"Leetcode 0278. First Bad Version","text":"Question Link : https://leetcode.com/problems/first-bad-version/ Difficulty: Easy Premium: False Question You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example 1: Input: n = 5, bad = 4 Output: 4 Explanation: call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true Then 4 is the first bad version. Example 2: Input: n = 1, bad = 1 Output: 1 Constraints: 1 <= bad <= n <= 231 - 1 Solution Use Binary Search, return left as the first bad version Code ''' Leetcode 0278. First Bad Version Question Link : https://leetcode.com/problems/first-bad-version/ Solution Link : https://tofucode.com/posts/leetcode_0278_first-bad-version.html ''' # The isBadVersion API is already defined for you. # def isBadVersion(version: int) -> bool: class Solution : def firstBadVersion ( self , n : int ) -> int : ''' Binary Search n = 5, bad = 4 1 2 3 4 5 F F F T T l r l r * Time : O(log n) Space: O(1) ''' left = 1 right = n while left < right : mid = ( left + right ) // 2 is_bad = isBadVersion ( mid ) if not is_bad : left = mid + 1 else : right = mid return left","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0278_first-bad-version.html","loc":"https://tofucode.com/posts/leetcode_0278_first-bad-version.html"},{"title":"Leetcode 0704. Binary Search","text":"Question Link : https://leetcode.com/problems/binary-search/ Difficulty: Easy Premium: False Question Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 Constraints: 1 <= nums.length <= 104 -104 < nums[i], target < 104 All the integers in nums are unique. nums is sorted in ascending order. Solution Use Binary Search and reutnr -1 if not found. Code ''' Leetcode 0704. Binary Search Question Link : https://leetcode.com/problems/binary-search/ Solution Link : https://tofucode.com/posts/leetcode_0704_binary-search.html ''' class Solution : def search ( self , nums : List [ int ], target : int ) -> int : \"\"\" Binary search But if nothing is found, we return -1 [-1,0,3,5,9,12], target = 9 l r l m r l r l m r Time : O(log n) Space: O(1) \"\"\" left = 0 right = len ( nums ) - 1 while left < right : mid = ( left + right ) // 2 if nums [ mid ] < target : left = mid + 1 else : right = mid return left if nums [ left ] == target else - 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0704_binary-search.html","loc":"https://tofucode.com/posts/leetcode_0704_binary-search.html"},{"title":"Leetcode 0215. Kth Largest Element in an Array","text":"Question Link : https://leetcode.com/problems/kth-largest-element-in-an-array/ Difficulty: Medium Premium: False Question Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting? Example 1: Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Example 2: Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 Constraints: 1 <= k <= nums.length <= 105 -104 <= nums[i] <= 104 Solution The first solution that comes to mind should be a priority queue. Other sorting algorithms can also be used. Code ''' Leetcode 0215. Kth Largest Element in an Array Question Link : https://leetcode.com/problems/kth-largest-element-in-an-array/ Solution Link : https://tofucode.com/posts/leetcode_0215_kth-largest-element-in-an-array.html ''' class Solution : def findKthLargest ( self , nums : List [ int ], k : int ) -> int : \"\"\" nums = [3,2,3,1,2,4,5,5,6], k = 4 6, 5, 5, 4 Priority queue (heap) of size k: k largest elements in a min heap go through and add to pq: pop when over flowing and pop till the kth Time : O(n log k) each heap insert is log k Space: O(k) \"\"\" pq = [] for num in nums : heapq . heappush ( pq , num ) if len ( pq ) > k : heapq . heappop ( pq ) return pq [ 0 ] class SolutionImproved1 : def findKthLargest ( self , nums : List [ int ], k : int ) -> int : \"\"\" counting sort nums = [3,2,1,5,6,4], k = 2 we only care about the top k take min - max range min 1 max 6 1 2. 3 4. 5 6 [0, 0, 0, 0, 0, 0] [1, 1, 1, 1, 1, 1] start from the max side and count out k m as max - min Time : O(n + m) Space: O(m) \"\"\" min_value = min ( nums ) max_value = max ( nums ) counts = [ 0 ] * ( max_value - min_value + 1 ) for num in nums : counts [ num - min_value ] += 1 remain = k for num in range ( len ( counts ) - 1 , - 1 , - 1 ): remain -= counts [ num ] if remain <= 0 : return num + min_value return - 1 class SolutionAlternative1 : def findKthLargest ( self , nums : List [ int ], k : int ) -> int : ''' TLE Use bubble sort to bubble k times to the end swap the larger to the end nums = [3,2,1,5,6,4], k = 2 n = 6 i = 0 j = 0 [3,2,1,5,6,4] [2,3,1,5,6,4] [2,1,3,5,6,4] [2,1,3,5,4,6] j = 1 [2,1,3,5,4,6] [2,1,3,4,5,6] Time : O(nk) Space: O(1) ''' for i in range ( k ): for j in range ( len ( nums ) - 1 - i ): if nums [ j ] > nums [ j + 1 ]: nums [ j ], nums [ j + 1 ] = nums [ j + 1 ], nums [ j ] return nums [ - k ] class SolutionAlternative2 : def findKthLargest ( self , nums : List [ int ], k : int ) -> int : ''' TLE Use selection sort to find the biggest k times and swap them to the end Time : O(nk) Space: O(1) ''' n = len ( nums ) for i in range ( n , n - k , - 1 ): temp = 0 # to find the biggest for j in range ( i ): if nums [ j ] > nums [ temp ]: temp = j nums [ temp ], nums [ i - 1 ] = nums [ i - 1 ], nums [ temp ] return nums [ - k ] class SolutionAlternative3 : def findKthLargest ( self , nums : List [ int ], k : int ) -> int : ''' TLE Use quick sort: convert the kth largest to smallest Same as https://leetcode.com/problems/k-closest-points-to-origin/ except here we sort by putting the largest to the start Time : O(n) average Space: O(1) ''' l = 0 r = len ( nums ) - 1 self . quicksort ( nums , l , r , k ) return nums [ k - 1 ] def quicksort ( self , nums , l , r , k ): if l < r : p = self . partition ( nums , l , r ) # check which part good = p - l + 1 if k == good : return elif k < good : return self . quicksort ( nums , l , p - 1 , k ) else : return self . quicksort ( nums , p + 1 , r , k - good ) def partition ( self , nums , l , r ): pivotNum = nums [ r ] p = l for i in range ( l , r ): if nums [ i ] > pivotNum : nums [ i ], nums [ p ] = nums [ p ] , nums [ i ] p += 1 # put the pivot in nums [ r ], nums [ p ] = nums [ p ], nums [ r ] return p","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0215_kth-largest-element-in-an-array.html","loc":"https://tofucode.com/posts/leetcode_0215_kth-largest-element-in-an-array.html"},{"title":"Leetcode 0698. Partition to K Equal Sum Subsets","text":"Question Link : https://leetcode.com/problems/partition-to-k-equal-sum-subsets/ Difficulty: Medium Premium: False Question Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal. Example 1: Input: nums = [4,3,2,3,5,2,1], k = 4 Output: true Explanation: It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. Example 2: Input: nums = [1,2,3,4], k = 3 Output: false Constraints: 1 <= k <= nums.length <= 16 1 <= nums[i] <= 104 The frequency of each element is in the range [1, 4]. Solution Backtracking problem with different checks and optimmizations for possible early termination along the way. Code ''' Leetcode 0698. Partition to K Equal Sum Subsets Question Link : https://leetcode.com/problems/partition-to-k-equal-sum-subsets/ Solution Link : https://tofucode.com/posts/leetcode_0698_partition-to-k-equal-sum-subsets.html ''' class Solution : def canPartitionKSubsets ( self , nums : List [ int ], k : int ) -> bool : \"\"\" target: sum(nums) // k target has to be an int form groups that sum to target backtracking step: for each number place it in each group Time : O(k&#94;n) all possible ways of placing n into k subsets Space: O(n) \"\"\" if not nums : return False total = sum ( nums ) if total % k != 0 : return False target = total // k nums = sorted ( nums , reverse = True ) groups = [ 0 ] * k return self . dfs ( nums , 0 , groups , k , target ) def dfs ( self , nums , idx , groups , k , target ): if idx == len ( nums ): return True for i in range ( k ): if groups [ i ] + nums [ idx ] <= target : groups [ i ] += nums [ idx ] if self . dfs ( nums , idx + 1 , groups , k , target ): return True groups [ i ] -= nums [ idx ] # early terminate did not fill this group if groups [ i ] == 0 : break return False","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0698_partition-to-k-equal-sum-subsets.html","loc":"https://tofucode.com/posts/leetcode_0698_partition-to-k-equal-sum-subsets.html"},{"title":"Leetcode 0268. Missing Number","text":"Question Link : https://leetcode.com/problems/missing-number/ Difficulty: Easy Premium: False Question Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example 1: Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2: Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3: Input: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. Constraints: n == nums.length 1 <= n <= 104 0 <= nums[i] <= n All the numbers of nums are unique. Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity? Solution Use Gauss' formula to get expect sum of a the numbers and subtract the current sum from it. Code ''' Leetcode 0268. Missing Number Question Link : https://leetcode.com/problems/missing-number/ Solution Link : https://tofucode.com/posts/leetcode_0268_missing-number.html ''' class Solution : def missingNumber ( self , nums : List [ int ]) -> int : \"\"\" set go through nums and add to set. go through 0 ... len(nums) and return missing Time : O(n) Space: O(n) Sort and go through Time : O(n log n) Space: O(1) sum of the first n number (0 + n)(n+1) / 2 go through and subtract Time : O(n) Space: O(1) \"\"\" n = len ( nums ) expected_total = n * ( n + 1 ) // 2 current = sum ( nums ) return expected_total - current","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0268_missing-number.html","loc":"https://tofucode.com/posts/leetcode_0268_missing-number.html"},{"title":"Leetcode 0252. Meeting Rooms","text":"Question Link : https://leetcode.com/problems/meeting-rooms/ Difficulty: Easy Premium: True Question Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings. Example 1: Input: intervals = [[0,30],[5,10],[15,20]] Output: false Example 2: Input: intervals = [[7,10],[2,4]] Output: true Constraints: 0 <= intervals.length <= 104 intervals[i].length == 2 0 <= starti < endi <= 106 Solution Sort by starting time and go throught the intervals list. Code ''' Leetcode 0252. Meeting Rooms Question Link : https://leetcode.com/problems/meeting-rooms/ Solution Link : https://tofucode.com/posts/leetcode_0252_meeting-rooms.html ''' class Solution : def canAttendMeetings ( self , intervals : List [ List [ int ]]) -> bool : \"\"\" [[7,10],[2,4]] sort by starting time [2,4], [7,10] go through and check: i item start time >= i-1 end time Time : O(n log n) Space: O(n) \"\"\" if not intervals : return True times = sorted ( intervals ) for i in range ( 1 , len ( times )): _ , last_end = times [ i - 1 ] current_start , _ = times [ i ] if current_start < last_end : return False return True","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0252_meeting-rooms.html","loc":"https://tofucode.com/posts/leetcode_0252_meeting-rooms.html"},{"title":"Leetcode 0621. Task Scheduler","text":"Question Link : https://leetcode.com/problems/task-scheduler/ Difficulty: Medium Premium: False Question You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label. Return the minimum number of CPU intervals required to complete all tasks. Example 1: Input: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2 Output: 8 Explanation: A possible sequence is: A -> B -> idle -> A -> B -> idle -> A -> B. After completing task A, you must wait two intervals before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th interval, you can do A again as 2 intervals have passed. Example 2: Input: tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1 Output: 6 Explanation: A possible sequence is: A -> B -> C -> D -> A -> B. With a cooling interval of 1, you can repeat a task after just one other task. Example 3: Input: tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3 Output: 10 Explanation: A possible sequence is: A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B. There are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks. Constraints: 1 <= tasks.length <= 104 tasks[i] is an uppercase English letter. 0 <= n <= 100 Solution Identify that the number of idles is bound by the task(s) with the most count, so we want to find that, and use that to calculate the total time needed. Code ''' Leetcode 0621. Task Scheduler Question Link : https://leetcode.com/problems/task-scheduler/ Solution Link : https://tofucode.com/posts/leetcode_0621_task-scheduler.html ''' class Solution : def leastInterval ( self , tasks : List [ str ], n : int ) -> int : \"\"\" Greedy: min length is bounded by the task that appears the most tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2 A: 3 B: 3 AB_ AB_ AB AB_ AB_ apears (most_count - 1) times each is n+1 long AB How many total that have the same max count - add on as leftovers (n + 1) * (most_count - 1) + tasks that have max count Time : O(n) Space: O(1) \"\"\" # count each type of task counts = {} most_count = 0 # get the most count for t in tasks : counts [ t ] = counts . get ( t , 0 ) + 1 most_count = max ( most_count , counts [ t ]) tasks_with_max_count = 0 for k , v in counts . items (): if v == most_count : tasks_with_max_count += 1 min_length = ( n + 1 ) * ( most_count - 1 ) + tasks_with_max_count min_length = max ( len ( tasks ), min_length ) return min_length","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0621_task-scheduler.html","loc":"https://tofucode.com/posts/leetcode_0621_task-scheduler.html"},{"title":"Leetcode 1891. Cutting Ribbons","text":"Question Link : https://leetcode.com/problems/cutting-ribbons/ Difficulty: Medium Premium: True Question You are given an integer array ribbons, where ribbons[i] represents the length of the ith ribbon, and an integer k. You may cut any of the ribbons into any number of segments of positive integer lengths, or perform no cuts at all. For example, if you have a ribbon of length 4, you can: Keep the ribbon of length 4, Cut it into one ribbon of length 3 and one ribbon of length 1, Cut it into two ribbons of length 2, Cut it into one ribbon of length 2 and two ribbons of length 1, or Cut it into four ribbons of length 1. Your task is to determine the maximum length of ribbon, x, that allows you to cut at least k ribbons, each of length x. You can discard any leftover ribbon from the cuts. If it is impossible to cut k ribbons of the same length, return 0. Example 1: Input: ribbons = [9,7,5], k = 3 Output: 5 Explanation: - Cut the first ribbon to two ribbons, one of length 5 and one of length 4. - Cut the second ribbon to two ribbons, one of length 5 and one of length 2. - Keep the third ribbon as it is. Now you have 3 ribbons of length 5. Example 2: Input: ribbons = [7,5,9], k = 4 Output: 4 Explanation: - Cut the first ribbon to two ribbons, one of length 4 and one of length 3. - Cut the second ribbon to two ribbons, one of length 4 and one of length 1. - Cut the third ribbon to three ribbons, two of length 4 and one of length 1. Now you have 4 ribbons of length 4. Example 3: Input: ribbons = [5,7,9], k = 22 Output: 0 Explanation: You cannot obtain k ribbons of the same positive integer length. Constraints: 1 <= ribbons.length <= 105 1 <= ribbons[i] <= 105 1 <= k <= 109 Solution The questions is really asking us to find a length x between 1 to max length that can provide k counts of that. An iterative approach can be improved with binary search. Code ''' Leetcode 1891. Cutting Ribbons Question Link : https://leetcode.com/problems/cutting-ribbons/ Solution Link : https://tofucode.com/posts/leetcode_1891_cutting-ribbons.html ''' class Solution : def maxLength ( self , ribbons : List [ int ], k : int ) -> int : \"\"\" ribbons: ribbon length, cut out >= k ribbons of same max length return max length ribbons = [9,7,5], k = 3 x = 5, k = 3 find max length ribbon try x, x-1 Time : O(xn) Space: O(1) \"\"\" x = max ( ribbons ) while x > 0 : count = 0 for ribbon in ribbons : count += ribbon // x if count >= k : return x x -= 1 return 0 class SolutionImproved1 : def maxLength ( self , ribbons : List [ int ], k : int ) -> int : \"\"\" ribbons: ribbon length, cut out >= k ribbons of same max length return max length ribbons = [9,7,5], k = 3 x = 5, k = 3 find max length ribbon binary search x with [1, max length ribbon] Time : O(n log x) Space: O(1) \"\"\" left = 1 right = max ( ribbons ) while left <= right : mid = ( left + right ) // 2 if self . can_cut ( ribbons , mid , k ): left = mid + 1 else : right = mid - 1 return right def can_cut ( self , ribbons , x , k ): count = 0 for ribbon in ribbons : count += ribbon // x if count >= k : return True return False","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_1891_cutting-ribbons.html","loc":"https://tofucode.com/posts/leetcode_1891_cutting-ribbons.html"},{"title":"Leetcode 0269. Alien Dictionary","text":"Question Link : https://leetcode.com/problems/alien-dictionary/ Difficulty: Hard Premium: True Question There is a new alien language that uses the English alphabet. However, the order of the letters is unknown to you. You are given a list of strings words from the alien language's dictionary. Now it is claimed that the strings in words are sorted lexicographically by the rules of this new language. If this claim is incorrect, and the given arrangement of string in words cannot correspond to any order of letters, return \"\". Otherwise, return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there are multiple solutions, return any of them. Example 1: Input: words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"] Output: \"wertf\" Example 2: Input: words = [\"z\",\"x\"] Output: \"zx\" Example 3: Input: words = [\"z\",\"x\",\"z\"] Output: \"\" Explanation: The order is invalid, so return \"\". Constraints: 1 <= words.length <= 100 1 <= words[i].length <= 100 words[i] consists of only lowercase English letters. Solution First try to solve an example and find that this is an graph probelem where for each two words we may gain a bit of ordering information to connect 2 char nodes with an edge. The questions can been then seen as asking for topological sort of the graph which can be solved with khan's algorithm with bfs. The tricky part is to account for the different valid and invalid edge cases. Code ''' Leetcode 0269. Alien Dictionary Question Link : https://leetcode.com/problems/alien-dictionary/ Solution Link : https://tofucode.com/posts/leetcode_0269_alien-dictionary.html ''' class Solution : def alienOrder ( self , words : List [ str ]) -> str : \"\"\" Ask: words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"] t -> f w -> e r -> t e -> r wertf start at zero in_degree, topo ordering of all nodes with bfs build in_degree with all unique chars build graph run bfs starting at 0 in_degree (Kahn's algorithm) edge cases: invalid: [abc, ab] valid: [z, z] Time : O(C) C is all chars in all the words Sapce: O(1) given 26 chars \"\"\" graph = {} # char node -> [children] in_degree = {} # char node -> in degree number # init in_defree to track in degree of all uniqe chars for word in words : for c in word : in_degree [ c ] = 0 # build the graph and in_degree for i in range ( 1 , len ( words )): word1 = words [ i - 1 ] word2 = words [ i ] is_valid , a , b = self . getOrderInfo ( word1 , word2 ) if not is_valid : return \"\" if a and b : graph [ a ] = graph . get ( a , []) + [ b ] in_degree [ b ] += 1 result = self . bfs ( graph , in_degree ) if len ( result ) < len ( in_degree ): return \"\" return \"\" . join ( result ) def getOrderInfo ( self , word1 , word2 ) -> ( bool , str , str ): max_len = min ( len ( word1 ), len ( word2 )) for i in range ( max_len ): if word1 [ i ] != word2 [ i ]: return ( True , word1 [ i ], word2 [ i ]) # no info gained: check invalid ordering: [abc, ab] if len ( word1 ) > len ( word2 ): return ( False , None , None ) # no info gained: but valid: [z, z] return ( True , None , None ) def bfs ( self , graph , in_degree ): queue = deque ([ c for c in in_degree if in_degree [ c ] == 0 ]) result = [] while queue : c = queue . popleft () result . append ( c ) for child in graph . get ( c , []): in_degree [ child ] -= 1 if in_degree [ child ] == 0 : queue . append ( child ) return result","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0269_alien-dictionary.html","loc":"https://tofucode.com/posts/leetcode_0269_alien-dictionary.html"},{"title":"Leetcode 0953. Verifying an Alien Dictionary","text":"Question Link : https://leetcode.com/problems/verifying-an-alien-dictionary/ Difficulty: Easy Premium: False Question In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language. Example 1: Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted. Example 2: Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted. Example 3: Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" Output: false Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > 'â', where 'â' is defined as the blank character which is less than any other character (More info). Constraints: 1 <= words.length <= 100 1 <= words[i].length <= 20 order.length == 26 All characters in words[i] and order are English lowercase letters. Solution Related to Alien dictionary where we asked to find the topological sort, but here we just need to verify the given words list which can be done with a dictionary. Code ''' Leetcode 0953. Verifying an Alien Dictionary Question Link : https://leetcode.com/problems/verifying-an-alien-dictionary/ Solution Link : https://tofucode.com/posts/leetcode_0953_verifying-an-alien-dictionary.html ''' class Solution : def isAlienSorted ( self , words : List [ str ], order : str ) -> bool : \"\"\" order -> rank rank = {} # char -> int rank smaller in front Go through every two words and check against order check prefix case: [\"apple\",\"app\"] Time : O(C) C is all chars in words Space: O(1) \"\"\" if len ( words ) == 1 : return True rank = {} # char -> int rank for i in range ( len ( order )): c = order [ i ] rank [ c ] = i for i in range ( 1 , len ( words )): word1 = words [ i - 1 ] word2 = words [ i ] r = self . check ( word1 , word2 , rank ) if not r : return False return True def check ( self , word1 , word2 , rank ): min_length = min ( len ( word1 ), len ( word2 )) for i in range ( min_length ): a = word1 [ i ] b = word2 [ i ] if a != b : return rank [ a ] < rank [ b ] # equal but check prefix case: [\"apple\",\"app\"] if len ( word1 ) > len ( word2 ): return False # all equal return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0953_verifying-an-alien-dictionary.html","loc":"https://tofucode.com/posts/leetcode_0953_verifying-an-alien-dictionary.html"},{"title":"Leetcode 0348. Design Tic-Tac-Toe","text":"Question Link : https://leetcode.com/problems/design-tic-tac-toe/ Difficulty: Medium Premium: True Question Assume the following rules are for the tic-tac-toe game on an n x n board between two players: A move is guaranteed to be valid and is placed on an empty block. Once a winning condition is reached, no more moves are allowed. A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game. Implement the TicTacToe class: TicTacToe(int n) Initializes the object the size of the board n. int move(int row, int col, int player) Indicates that the player with id player plays at the cell (row, col) of the board. The move is guaranteed to be a valid move, and the two players alternate in making moves. Return 0 if there is no winner after the move, 1 if player 1 is the winner after the move, or 2 if player 2 is the winner after the move. Example 1: Input [\"TicTacToe\", \"move\", \"move\", \"move\", \"move\", \"move\", \"move\", \"move\"] [[3], [0, 0, 1], [0, 2, 2], [2, 2, 1], [1, 1, 2], [2, 0, 1], [1, 0, 2], [2, 1, 1]] Output [null, 0, 0, 0, 0, 0, 0, 1] Explanation TicTacToe ticTacToe = new TicTacToe(3); Assume that player 1 is \"X\" and player 2 is \"O\" in the board. ticTacToe.move(0, 0, 1); // return 0 (no one wins) |X| | | | | | | // Player 1 makes a move at (0, 0). | | | | ticTacToe.move(0, 2, 2); // return 0 (no one wins) |X| |O| | | | | // Player 2 makes a move at (0, 2). | | | | ticTacToe.move(2, 2, 1); // return 0 (no one wins) |X| |O| | | | | // Player 1 makes a move at (2, 2). | | |X| ticTacToe.move(1, 1, 2); // return 0 (no one wins) |X| |O| | |O| | // Player 2 makes a move at (1, 1). | | |X| ticTacToe.move(2, 0, 1); // return 0 (no one wins) |X| |O| | |O| | // Player 1 makes a move at (2, 0). |X| |X| ticTacToe.move(1, 0, 2); // return 0 (no one wins) |X| |O| |O|O| | // Player 2 makes a move at (1, 0). |X| |X| ticTacToe.move(2, 1, 1); // return 1 (player 1 wins) |X| |O| |O|O| | // Player 1 makes a move at (2, 1). |X|X|X| Constraints: 2 <= n <= 100 player is 1 or 2. 0 <= row, col < n (row, col) are unique for each different call to move. At most n2 calls will be made to move. Follow-up: Could you do better than O(n2) per move() operation? Solution The naive solution is to simulate the board and check all directions for a possible win on a move. To improve on this runtime, we need to identify the fact that we only care about the win condition and that a win is only triggered when the entire row or col or diagonal is the same. With this info, we want to compress the informatineeded to track per win of a single row/col/diagonal to 1d. Namely a count number where we +1 for player 1 and alternatively -1 for player 2. Code ''' Leetcode 0348. Design Tic-Tac-Toe Question Link : https://leetcode.com/problems/design-tic-tac-toe/ Solution Link : https://tofucode.com/posts/leetcode_0348_design-tic-tac-toe.html ''' class TicTacToe : \"\"\" 2d grid as the board on move() check if the current player is the winner, check: horizontal vertical 2 x diangonal \"\"\" def __init__ ( self , n : int ): \"\"\" Space: O(n&#94;2) \"\"\" self . board = [[ 0 ] * n for _ in range ( n )] self . n = n def move ( self , row : int , col : int , player : int ) -> int : \"\"\" return 0: no winner or 1 or 2 diagonal: (1, -1) down, left - up, right (1, 1) down, right - up, left Time : O(n) \"\"\" self . board [ row ][ col ] = player direction = [( 0 , 1 ), ( 1 , 0 ), ( 1 , - 1 ), ( 1 , 1 )] for dx , dy in direction : won = self . check ( row , col , dx , dy , player ) if won : return player return 0 def check ( self , row , col , dx , dy , player ): count = 1 x = row + dx y = col + dy while 0 <= x < self . n and 0 <= y < self . n : if self . board [ x ][ y ] != player : return False else : count += 1 x += dx y += dy x = row - dx y = col - dy while 0 <= x < self . n and 0 <= y < self . n : if self . board [ x ][ y ] != player : return False else : count += 1 x -= dx y -= dy return count == self . n # Your TicTacToe object will be instantiated and called as such: # obj = TicTacToe(n) # param_1 = obj.move(row,col,player) class TicTacToeImproved1 : \"\"\" only care about win conditions Track: row win col win diagonal win 2 ways Track row or col: each row -> +1 if player 1, -1 if player 2 each col -> +1 if player 1, -1 if player 2 Track diagonal: only two ways of winner down left - up right (0, 2) (1, 1) (2, 0) down right - up left (2, 2) (1, 1) (0, 0) +1 if player 1, -1 if player 2 Win when a abs(tracking state) is n positive: player 1 win negative: player 2 win \"\"\" def __init__ ( self , n : int ): \"\"\" Space: O(n) \"\"\" self . rows_tracker = [ 0 ] * n self . cols_tracker = [ 0 ] * n self . diagonal_down_left_tracker = 0 self . diabonal_down_right_tracker = 0 self . n = n def move ( self , row : int , col : int , player : int ) -> int : \"\"\" return 0: no winner or 1 or 2 Time : O(1) \"\"\" self . rows_tracker [ row ] += 1 if player == 1 else - 1 self . cols_tracker [ col ] += 1 if player == 1 else - 1 if row + col == self . n - 1 : self . diagonal_down_left_tracker += 1 if player == 1 else - 1 if row == col : self . diabonal_down_right_tracker += 1 if player == 1 else - 1 if ( abs ( self . rows_tracker [ row ]) == self . n or abs ( self . cols_tracker [ col ]) == self . n or abs ( self . diagonal_down_left_tracker ) == self . n or abs ( self . diabonal_down_right_tracker ) == self . n ): return 1 if player == 1 else 2 return 0 # Your TicTacToe object will be instantiated and called as such: # obj = TicTacToe(n) # param_1 = obj.move(row,col,player)","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0348_design-tic-tac-toe.html","loc":"https://tofucode.com/posts/leetcode_0348_design-tic-tac-toe.html"},{"title":"Leetcode 0221. Maximal Square","text":"Question Link : https://leetcode.com/problems/maximal-square/ Difficulty: Medium Premium: False Question Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. Example 1: Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 4 Example 2: Input: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]] Output: 1 Example 3: Input: matrix = [[\"0\"]] Output: 0 Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 300 matrix[i][j] is '0' or '1'. Solution Brute force solution is messy to write. To identify this is dp: think about the fact that a bigger square is formed based on smaller inner square: find the dp relationship here. Code ''' Leetcode 0221. Maximal Square Question Link : https://leetcode.com/problems/maximal-square/ Solution Link : https://tofucode.com/posts/leetcode_0221_maximal-square.html ''' class Solution : def maximalSquare ( self , matrix : List [ List [ str ]]) -> int : \"\"\" dp[i][j] = biggest square with lower right cornoer ending at i,j matrix: [1, 0, 1, 0, 0] [1, 0, 1, 1, 1] [1, 1, 1, 1, 1] [1, 0, 0, 1, 0] dp: [1, 0, 1, 0, 0] [1, 0, 1, 1, 1] [1, 1, 1, 2, 2] [1, 0, 0, 1, 0] look up and left, and up-left 1 1 1 0 1 2 2 0 1 2 3 1 dp[i][j] = 1 if is 1 in matrix then if there is a bigger square: take the min + 1 Time : O(mn) Space: O(mn) \"\"\" rows = len ( matrix ) cols = len ( matrix [ 0 ]) if matrix else 0 dp = [[ \"0\" ] * cols for x in range ( rows )] result = 0 for i in range ( rows ): for j in range ( cols ): dp [ i ][ j ] = matrix [ i ][ j ] if i > 0 and j > 0 and dp [ i ][ j ] == \"1\" : up = int ( dp [ i - 1 ][ j ]) left = int ( dp [ i ][ j - 1 ]) up_left = int ( dp [ i - 1 ][ j - 1 ]) if up > 0 and left > 0 and up_left > 0 : current = min ( up , left , up_left ) + 1 dp [ i ][ j ] = str ( current ) result = max ( result , int ( dp [ i ][ j ])) return result ** 2","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0221_maximal-square.html","loc":"https://tofucode.com/posts/leetcode_0221_maximal-square.html"},{"title":"Leetcode 0277. Find the Celebrity","text":"Question Link : https://leetcode.com/problems/find-the-celebrity/ Difficulty: Medium Premium: True Question Suppose you are at a party with n people labeled from 0 to n - 1 and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know the celebrity, but the celebrity does not know any of them. Now you want to find out who the celebrity is or verify that there is not one. You are only allowed to ask questions like: \"Hi, A. Do you know B?\" to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense). You are given an integer n and a helper function bool knows(a, b) that tells you whether a knows b. Implement a function int findCelebrity(n). There will be exactly one celebrity if they are at the party. Return the celebrity's label if there is a celebrity at the party. If there is no celebrity, return -1. Note that the n x n 2D array graph given as input is not directly available to you, and instead only accessible through the helper function knows. graph[i][j] == 1 represents person i knows person j, wherease graph[i][j] == 0 represents person j does not know person i. Example 1: Input: graph = [[1,1,0],[0,1,0],[1,1,1]] Output: 1 Explanation: There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody. Example 2: Input: graph = [[1,0,1],[1,1,0],[0,1,1]] Output: -1 Explanation: There is no celebrity. Constraints: n == graph.length == graph[i].length 2 <= n <= 100 graph[i][j] is 0 or 1. graph[i][i] == 1 Follow up: If the maximum number of allowed calls to the API knows is 3 * n, could you find a solution without exceeding the maximum number of calls? Solution The brute force solution is easy to find. After that think about the information gain from a single knows() call and how to select the next pair of (a,b) for the next knows() call. greedily go through the list to find a potential candidate, and run another loop to verify. Code ''' Leetcode 0277. Find the Celebrity Question Link : https://leetcode.com/problems/find-the-celebrity/ Solution Link : https://tofucode.com/posts/leetcode_0277_find-the-celebrity.html ''' # The knows API is already defined for you. # return a bool, whether a knows b # def knows(a: int, b: int) -> bool: class Solution : def findCelebrity ( self , n : int ) -> int : \"\"\" Ask: n people: 0 ... n-1 knows(a, b): true a knows b celebrity: 1. all others konw celebrity 2. celebrity knows no one return that celebrity, else -1 knows(): a->b: true: a is not celebrity, b don't know false: b is not celebrity, a don't know Proposal 1: brute force build a graph from 0 to n-1 check all possibility: n x n a knows b: a -> b 1. all other nodes have an edge to celebrity 2. celebrity node has zero out going edges Time : O(n&#94;2) Space: O(1) Proposal 2: Greedy: a -> b true: b->someone false: a->someone loop 1. start with one candidate, depending on a -> b: update the candidate loop 2. check that candidate is valid against all others Time : O(n) Space: O(1) \"\"\" candidate = 0 for i in range ( 1 , n ): if knows ( candidate , i ): candidate = i for i in range ( n ): if i == candidate : continue if knows ( candidate , i ): return - 1 if not knows ( i , candidate ): return - 1 return candidate","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0277_find-the-celebrity.html","loc":"https://tofucode.com/posts/leetcode_0277_find-the-celebrity.html"},{"title":"Leetcode 0019. Remove Nth Node From End of List","text":"Question Link : https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Difficulty: Medium Premium: False Question Given the head of a linked list, remove the nth node from the end of the list and return its head. Example 1: Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2: Input: head = [1], n = 1 Output: [] Example 3: Input: head = [1,2], n = 1 Output: [1] Constraints: The number of nodes in the list is sz. 1 <= sz <= 30 0 <= Node.val <= 100 1 <= n <= sz Follow up: Could you do this in one pass? Solution It's much easier to use a dummery head so any pointers can start on the dummy head instead of the actual head as there are edge cases where we'd want to remove the head. Main idea for using a single loop is to have the marking pointer trail behind by n+1 Code ''' Leetcode 0019. Remove Nth Node From End of List Question Link : https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Solution Link : https://tofucode.com/posts/leetcode_0019_remove-nth-node-from-end-of-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def removeNthFromEnd ( self , head : Optional [ ListNode ], n : int ) -> Optional [ ListNode ]: \"\"\" end pointer mark pointer target state: when end is at the end, mark is just before the removal point remove the next node of mark n remove node mark mark - end 1 last node second from last 1 2 second from last node third from last 2 [1,2,3,4,5], n = 2 move end to position (3 moves dummy -> 3) e move end to the end (3 moves) e m remove next of m Time : O(n) Space: O(1) \"\"\" if not head : return None dummy = ListNode ( 0 ) # Create a dummy node dummy . next = head end = dummy mark = dummy # Move end n + 1 steps ahead for i in range ( n + 1 ): end = end . next # move both end and mark while end : end = end . next mark = mark . next # Remove next of marked node mark . next = mark . next . next return dummy . next class SolutionAlternative1 : def removeNthFromEnd ( self , head : Optional [ ListNode ], n : int ) -> Optional [ ListNode ]: \"\"\" two loops: 1 to count the length 2 to stop at length - n Time : O(n) Space: O(1) \"\"\" # edge case of no head if not head : return None temp = head count = 1 # start at 1 to include head while temp . next : temp = temp . next count += 1 # edge case to remove head if count == n : return head . next mark = head # -1 below to include head for i in range ( count - n - 1 ): mark = mark . next mark . next = mark . next . next return head class SolutionAlternative1Improved1 : def removeNthFromEnd ( self , head : Optional [ ListNode ], n : int ) -> Optional [ ListNode ]: \"\"\" fold two loops into one Time : O(n) Space: O(1) \"\"\" # edge case of no head if not head : return None temp = head count = 1 # start at 1 to include head mark = head # -1 below to include head while temp . next : temp = temp . next count += 1 if count - 1 > n : mark = mark . next # edge case to remove head if count == n : return head . next mark . next = mark . next . next return head","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0019_remove-nth-node-from-end-of-list.html","loc":"https://tofucode.com/posts/leetcode_0019_remove-nth-node-from-end-of-list.html"},{"title":"Leetcode 0020. Valid Parentheses","text":"Question Link : https://leetcode.com/problems/valid-parentheses/ Difficulty: Easy Premium: False Question Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1: Input: s = \"()\" Output: true Example 2: Input: s = \"()[]{}\" Output: true Example 3: Input: s = \"(]\" Output: false Example 4: Input: s = \"([])\" Output: true Constraints: 1 <= s.length <= 104 s consists of parentheses only '()[]{}'. Solution Use a stack to match the parentheses Code ''' Leetcode 0020. Valid Parentheses Question Link : https://leetcode.com/problems/valid-parentheses/ Solution Link : https://tofucode.com/posts/leetcode_0020_valid-parentheses.html ''' class Solution : def isValid ( self , s : str ) -> bool : ''' Use a stack: only store parentheses go through s check current char c against first element on the stack if match than take the first element out valid if stack is empty: all parentheses are closed Time : O(n) Space: O(n) ''' stack = [] matches = { '(' : ')' , '{' : '}' , '[' : ']' } for c in s : if not stack : stack . append ( c ) elif matches . get ( stack [ - 1 ]) == c : stack . pop () else : stack . append ( c ) return len ( stack ) == 0","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0020_valid-parentheses.html","loc":"https://tofucode.com/posts/leetcode_0020_valid-parentheses.html"},{"title":"Leetcode 0200. Number of Islands","text":"Question Link : https://leetcode.com/problems/number-of-islands/ Difficulty: Medium Premium: False Question Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: grid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"] ] Output: 1 Example 2: Input: grid = [ [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"1\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"1\",\"1\"] ] Output: 3 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 300 grid[i][j] is '0' or '1'. Solution When hitting a land, start a dfs to find the whole island, use a global seet set() to track what has been visited. Code ''' Leetcode 0200. Number of Islands Question Link : https://leetcode.com/problems/number-of-islands/ Solution Link : https://tofucode.com/posts/leetcode_0200_number-of-islands.html ''' class Solution : def numIslands ( self , grid : List [ List [ str ]]) -> int : ''' Use dfs seen set(): record globally what's been seen when there is a 1 and not seen: start dfs, record what's seen result += 1 Time : O(mn) Space: O(mn) ''' rows = len ( grid ) cols = len ( grid [ 0 ]) if rows else 0 seen = set () count = 0 for i in range ( rows ): for j in range ( cols ): if grid [ i ][ j ] == \"1\" and not ( i , j ) in seen : found = self . dfs ( grid , i , j , rows , cols ) seen = seen | found count += 1 return count def dfs ( self , grid , i , j , rows , cols ): stack = [( i , j )] seen = set () while stack : current = stack . pop () if current in seen : continue seen . add ( current ) for offset in [( - 1 , 0 ), ( 1 , 0 ), ( 0 , - 1 ), ( 0 , 1 )]: x = current [ 0 ] + offset [ 0 ] y = current [ 1 ] + offset [ 1 ] if 0 <= x < rows and 0 <= y < cols and grid [ x ][ y ] == \"1\" : stack . append (( x , y )) return seen","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0200_number-of-islands.html","loc":"https://tofucode.com/posts/leetcode_0200_number-of-islands.html"},{"title":"Leetcode 0695. Max Area of Island","text":"Question Link : https://leetcode.com/problems/max-area-of-island/ Difficulty: Medium Premium: False Question You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0. Example 1: Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] Output: 6 Explanation: The answer is not 11, because the island must be connected 4-directionally. Example 2: Input: grid = [[0,0,0,0,0,0,0,0]] Output: 0 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 50 grid[i][j] is either 0 or 1. Solution Use dfs to find each island with a global seen set() to track what has been visited already. Code ''' Leetcode 0695. Max Area of Island Question Link : https://leetcode.com/problems/max-area-of-island/ Solution Link : https://tofucode.com/posts/leetcode_0695_max-area-of-island.html ''' class Solution : def maxAreaOfIsland ( self , grid : List [ List [ int ]]) -> int : \"\"\" Similiar to leetcode 200 number of islands Use a set() to track visited cells when there is a 1: run a dfs to find the island the 1 belongs to Time : O(mn) Space: O(mn) \"\"\" rows = len ( grid ) cols = len ( grid [ 0 ]) if grid else 0 seen = set () result = 0 for i in range ( rows ): for j in range ( cols ): if grid [ i ][ j ] == 1 and not ( i , j ) in seen : found = self . findIsland ( grid , rows , cols , i , j ) seen |= found result = max ( result , len ( found )) return result def findIsland ( self , grid , rows , cols , i , j ): \"\"\" dfs to find island starting at i,j, return set of island locations \"\"\" seen = set () stack = [( i , j )] while stack : current = stack . pop () if current in seen : continue seen . add ( current ) for offset in [( - 1 , 0 ), ( 1 , 0 ), ( 0 , - 1 ), ( 0 , 1 )]: x = current [ 0 ] + offset [ 0 ] y = current [ 1 ] + offset [ 1 ] if 0 <= x < rows and 0 <= y < cols and grid [ x ][ y ] == 1 : stack . append (( x , y )) return seen","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0695_max-area-of-island.html","loc":"https://tofucode.com/posts/leetcode_0695_max-area-of-island.html"},{"title":"Leetcode 0755. Pour Water","text":"Question Link : https://leetcode.com/problems/pour-water/ Difficulty: Medium Premium: True Question You are given an elevation map represents as an integer array heights where heights[i] representing the height of the terrain at index i. The width at each index is 1. You are also given two integers volume and k. volume units of water will fall at index k. Water first drops at the index k and rests on top of the highest terrain or water at that index. Then, it flows according to the following rules: If the droplet would eventually fall by moving left, then move left. Otherwise, if the droplet would eventually fall by moving right, then move right. Otherwise, rise to its current position. Here, \"eventually fall\" means that the droplet will eventually be at a lower level if it moves in that direction. Also, level means the height of the terrain plus any water in that column. We can assume there is infinitely high terrain on the two sides out of bounds of the array. Also, there could not be partial water being spread out evenly on more than one grid block, and each unit of water has to be in exactly one block. Example 1: Input: heights = [2,1,1,2,1,2,2], volume = 4, k = 3 Output: [2,2,2,3,2,2,2] Explanation: The first drop of water lands at index k = 3. When moving left or right, the water can only move to the same level or a lower level. (By level, we mean the total height of the terrain plus any water in that column.) Since moving left will eventually make it fall, it moves left. (A droplet \"made to fall\" means go to a lower height than it was at previously.) Since moving left will not make it fall, it stays in place. The next droplet falls at index k = 3. Since the new droplet moving left will eventually make it fall, it moves left. Notice that the droplet still preferred to move left, even though it could move right (and moving right makes it fall quicker.) The third droplet falls at index k = 3. Since moving left would not eventually make it fall, it tries to move right. Since moving right would eventually make it fall, it moves right. Finally, the fourth droplet falls at index k = 3. Since moving left would not eventually make it fall, it tries to move right. Since moving right would not eventually make it fall, it stays in place. Example 2: Input: heights = [1,2,3,4], volume = 2, k = 2 Output: [2,3,3,4] Explanation: The last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height. Example 3: Input: heights = [3,1,3], volume = 5, k = 1 Output: [4,4,4] Constraints: 1 <= heights.length <= 100 0 <= heights[i] <= 99 0 <= volume <= 2000 0 <= k < heights.length Solution Identify that we always want to try to find the min point for each drop of water. Code ''' Leetcode 0755. Pour Water Question Link : https://leetcode.com/problems/pour-water/ Solution Link : https://tofucode.com/posts/leetcode_0755_pour-water.html ''' class Solution : def pourWater ( self , heights : List [ int ], volume : int , k : int ) -> List [ int ]: \"\"\" given heights \"eventually fall\" means that the droplet will eventually be at a lower level for every drop in volume: go all the way left: track min point go all the way right: track min point else stays in k loop over volume as simulation Time : O(vn) Space: O(n) \"\"\" # counts = {} # usable index -> height map # for i in range(len(heights)): # h = heights[i] # if h < k: # counts[i] = h # for for _ in range ( volume ): idx = k min_point = k # try to go all the way left while idx > 0 and heights [ idx - 1 ] <= heights [ idx ]: idx -= 1 if heights [ idx ] < heights [ min_point ]: min_point = idx # try to go all the way right while idx < len ( heights ) - 1 and heights [ idx ] >= heights [ idx + 1 ]: idx += 1 if heights [ idx ] < heights [ min_point ]: min_point = idx heights [ min_point ] += 1 return heights","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0755_pour-water.html","loc":"https://tofucode.com/posts/leetcode_0755_pour-water.html"},{"title":"Leetcode 2924. Find Champion II","text":"Question Link : https://leetcode.com/problems/find-champion-ii/ Difficulty: Medium Premium: False Question There are n teams numbered from 0 to n - 1 in a tournament; each team is also a node in a DAG. You are given the integer n and a 0-indexed 2D integer array edges of length m representing the DAG, where edges[i] = [ui, vi] indicates that there is a directed edge from team ui to team vi in the graph. A directed edge from a to b in the graph means that team a is stronger than team b and team b is weaker than team a. Team a will be the champion of the tournament if there is no team b that is stronger than team a. Return the team that will be the champion of the tournament if there is a unique champion, otherwise, return -1. Notes A cycle is a series of nodes a1, a2, ..., an, an+1 such that node a1 is the same node as node an+1, the nodes a1, a2, ..., an are distinct, and there is a directed edge from the node ai to node ai+1 for every i in the range [1, n]. A DAG is a directed graph that does not have any cycle. Example 1: Input: n = 3, edges = [[0,1],[1,2]] Output: 0 Explanation: Team 1 is weaker than team 0. Team 2 is weaker than team 1. So the champion is team 0. Example 2: Input: n = 4, edges = [[0,2],[1,3],[1,2]] Output: -1 Explanation: Team 2 is weaker than team 0 and team 1. Team 3 is weaker than team 1. But team 1 and team 0 are not weaker than any other teams. So the answer is -1. Constraints: 1 <= n <= 100 m == edges.length 0 <= m <= n * (n - 1) / 2 edges[i].length == 2 0 <= edge[i][j] <= n - 1 edges[i][0] != edges[i][1] The input is generated such that if team a is stronger than team b, team b is not stronger than team a. The input is generated such that if team a is stronger than team b and team b is stronger than team c, then team a is stronger than team c. Solution Identify that the problem only requires tracking the number of in bound edges for each team. If there is a sole team with 0 in bound edges - that is the champion Code ''' Leetcode 2924. Find Champion II Question Link : https://leetcode.com/problems/find-champion-ii/ Solution Link : https://tofucode.com/posts/leetcode_2924_find-champion-ii.html ''' class Solution : def findChampion ( self , n : int , edges : List [ List [ int ]]) -> int : \"\"\" For a given team X: count how many other teams point to X find in_edge_count == 0 if just one team: champion else: return -1 counts = {} # team -> in_edge_count go through edges, write to counts go through counts, find in_edge_count == 0 edges = [[0,1],[1,2]] 0: 0 1: 1 2: 1 Time : O(n + m) n nodes, m edges Space: O(n) \"\"\" counts = {} # team -> in edge count for i in range ( n ): counts [ i ] = 0 # init to 0 for _ , b in edges : counts [ b ] += 1 result = - 1 for team , in_edge_count in counts . items (): if in_edge_count == 0 : if result == - 1 : result = team else : return - 1 # found multiple teams with 0 in_edge_count return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2924_find-champion-ii.html","loc":"https://tofucode.com/posts/leetcode_2924_find-champion-ii.html"},{"title":"Leetcode 0416. Partition Equal Subset Sum","text":"Question Link : https://leetcode.com/problems/partition-equal-subset-sum/ Difficulty: Medium Premium: False Question Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise. Example 1: Input: nums = [1,5,11,5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: nums = [1,2,3,5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. Constraints: 1 <= nums.length <= 200 1 <= nums[i] <= 100 Solution Identify that this is a knapsack-1-0 problem that can be solved with a 2d dp array. the 2d dp array can also be flattened to 1d. Code ''' Leetcode 0416. Partition Equal Subset Sum Question Link : https://leetcode.com/problems/partition-equal-subset-sum/ Solution Link : https://tofucode.com/posts/leetcode_0416_partition-equal-subset-sum.html ''' class Solution : def canPartition ( self , nums : List [ int ]) -> bool : \"\"\" knapsack 1 / 0, target: half of total dp dp[i][j] = true / false can use element 0 to i to form subset sum j pad + 1 so we can return dp[len(nums)][target] 0 1 2 3 4 5 6 ... 11 _ T F 1 T F F F F F F F 5 T T F F F T T F 11 T T 5 T T Time : O(mn) Space: O(mn) \"\"\" total = sum ( nums ) if total % 2 != 0 : return False target = total // 2 # dp[i][j] = using nums[0] ... nums[i] we can form subset sum j dp = [[ False ] * ( target + 1 ) for x in range ( len ( nums ) + 1 )] for i in range ( len ( nums ) + 1 ): num = nums [ i - 1 ] for j in range ( target + 1 ): if j == 0 : dp [ i ][ j ] = True continue elif i == 0 : continue dp [ i ][ j ] = dp [ i - 1 ][ j ] # don't take i if j >= num : dp [ i ][ j ] = dp [ i ][ j ] or dp [ i - 1 ][ j - num ] # take i return dp [ len ( nums )][ target ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0416_partition-equal-subset-sum.html","loc":"https://tofucode.com/posts/leetcode_0416_partition-equal-subset-sum.html"},{"title":"Leetcode 0494. Target Sum","text":"Question Link : https://leetcode.com/problems/target-sum/ Difficulty: Medium Premium: False Question You are given an integer array nums and an integer target. You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers. For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\". Return the number of different expressions that you can build, which evaluates to target. Example 1: Input: nums = [1,1,1,1,1], target = 3 Output: 5 Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3. -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 Example 2: Input: nums = [1], target = 1 Output: 1 Constraints: 1 <= nums.length <= 20 0 <= nums[i] <= 1000 0 <= sum(nums[i]) <= 1000 -1000 <= target <= 1000 Solution Use backtracking with memoization. Which is basically dp. Code ''' Leetcode 0494. Target Sum Question Link : https://leetcode.com/problems/target-sum/ Solution Link : https://tofucode.com/posts/leetcode_0494_target-sum.html ''' class Solution : def findTargetSumWays ( self , nums : List [ int ], target : int ) -> int : \"\"\" nums = [1,1,1,1,1], target = 3 add either + or - to reach target Proposal 1: backtracking this and test all combo n nodes in the tree 1 1 2 4 ... Optimization with Memoization Time : O(2&#94;n) Space: O(n) depth of tree \"\"\" self . result = 0 self . backtrack ( nums , target , 0 , 0 ) return self . result def backtrack ( self , nums , target , idx , current ): if idx == len ( nums ): if current == target : self . result += 1 return num = nums [ idx ] self . backtrack ( nums , target , idx + 1 , current + num ) self . backtrack ( nums , target , idx + 1 , current - num ) class SolutionImproved1 : def findTargetSumWays ( self , nums : List [ int ], target : int ) -> int : \"\"\" backtracking with memo (dp) Change backtracking func to return number of counts for a given current sum and index Use Memo to return that Time : O(ln) l is the range of sum Space: O(n) \"\"\" self . memo = {} # (current sum, idx) -> count return self . backtrack ( nums , target , 0 , 0 ) def backtrack ( self , nums , target , idx , current ): if ( current , idx ) in self . memo : return self . memo [( current , idx )] if idx == len ( nums ): if current == target : self . memo [( current , idx )] = 1 else : self . memo [( current , idx )] = 0 return self . memo [( current , idx )] num = nums [ idx ] a = self . backtrack ( nums , target , idx + 1 , current + num ) b = self . backtrack ( nums , target , idx + 1 , current - num ) total = a + b self . memo [( current , idx )] = total return total class SolutionImproved2 : def findTargetSumWays ( self , nums : List [ int ], target : int ) -> int : ''' DP iteratively Do num by num (layer by layer) so can drop tracking the index Time : O(ln) Space: O(n) ''' counts = { 0 : 1 } # current sum -> count for num in nums : temp = {} # temp updated counts, cause need to iterate for current , count in counts . items (): current_add = current + num current_sub = current - num temp [ current_add ] = temp . get ( current_add , 0 ) + count temp [ current_sub ] = temp . get ( current_sub , 0 ) + count counts = temp return counts . get ( target , 0 )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0494_target-sum.html","loc":"https://tofucode.com/posts/leetcode_0494_target-sum.html"},{"title":"Leetcode 0163. Missing Ranges","text":"Question Link : https://leetcode.com/problems/missing-ranges/ Difficulty: Easy Premium: True Question You are given an inclusive range [lower, upper] and a sorted unique integer array nums, where all elements are within the inclusive range. A number x is considered missing if x is in the range [lower, upper] and x is not in nums. Return the shortest sorted list of ranges that exactly covers all the missing numbers. That is, no element of nums is included in any of the ranges, and each missing number is covered by one of the ranges. Example 1: Input: nums = [0,1,3,50,75], lower = 0, upper = 99 Output: [[2,2],[4,49],[51,74],[76,99]] Explanation: The ranges are: [2,2] [4,49] [51,74] [76,99] Example 2: Input: nums = [-1], lower = -1, upper = -1 Output: [] Explanation: There are no missing ranges since there are no missing numbers. Constraints: -109 <= lower <= upper <= 109 0 <= nums.length <= 100 lower <= nums[i] <= upper All the values of nums are unique. Solution Add the lower and upper to nums and go though it to find the missing ranges. Code ''' Leetcode 0163. Missing Ranges Question Link : https://leetcode.com/problems/missing-ranges/ Solution Link : https://tofucode.com/posts/leetcode_0163_missing-ranges.html ''' class Solution : def findMissingRanges ( self , nums : List [ int ], lower : int , upper : int ) -> List [ str ]: ''' Put the lower and upper in with -+1 since it's inclusive and go through nums check every 2 number [1, 3] case, diff of 2 we add single number Time : O(n) Space: O(n) ''' nums = [ lower - 1 ] + nums + [ upper + 1 ] result = [] for i in range ( 1 , len ( nums )): a = nums [ i - 1 ] b = nums [ i ] if b - a == 2 : result . append ( str ( a + 1 )) elif b - a > 2 : result . append ( str ( a + 1 ) + '->' + str ( b - 1 )) return result class SolutionNope1 : def findMissingRanges ( self , nums : List [ int ], lower : int , upper : int ) -> List [ str ]: ''' go through lower to upper when not in nums: set as start keep going, when in nums: set i-1 as end store start->end in result include lower and upper as it's inclusive more complicated and worse run time as lower and upper are always bigger than len of nums ''' pass","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0163_missing-ranges.html","loc":"https://tofucode.com/posts/leetcode_0163_missing-ranges.html"},{"title":"Leetcode 0251. Flatten 2D Vector","text":"Question Link : https://leetcode.com/problems/flatten-2d-vector/ Difficulty: Medium Premium: True Question Design an iterator to flatten a 2D vector. It should support the next and hasNext operations. Implement the Vector2D class: Vector2D(int[][] vec) initializes the object with the 2D vector vec. next() returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to next are valid. hasNext() returns true if there are still some elements in the vector, and false otherwise. Example 1: Input [\"Vector2D\", \"next\", \"next\", \"next\", \"hasNext\", \"hasNext\", \"next\", \"hasNext\"] [[[[1, 2], [3], [4]]], [], [], [], [], [], [], []] Output [null, 1, 2, 3, true, true, 4, false] Explanation Vector2D vector2D = new Vector2D([[1, 2], [3], [4]]); vector2D.next(); // return 1 vector2D.next(); // return 2 vector2D.next(); // return 3 vector2D.hasNext(); // return True vector2D.hasNext(); // return True vector2D.next(); // return 4 vector2D.hasNext(); // return False Constraints: 0 <= vec.length <= 200 0 <= vec[i].length <= 500 -500 <= vec[i][j] <= 500 At most 105 calls will be made to next and hasNext. Follow up: As an added challenge, try to code it using only iterators in C++ or iterators in Java. Solution Consider the design choices of pre-flattening the vector or maintaining pointers for it. Code ''' Leetcode 0251. Flatten 2D Vector Question Link : https://leetcode.com/problems/flatten-2d-vector/ Solution Link : https://tofucode.com/posts/leetcode_0251_flatten-2d-vector.html ''' class Vector2D : \"\"\" vec: [ [1, 2], [3], [4] ] vec is of length <= 200 each list in vec can be length <= 500 Proposal 1: store as is and maintain two pointers init: just store the vec as is, i points to element in vec j point to element in vec[i] maybe also maintain length of vec[i] Pro: no extra space Con: maintain extra pointers Proposal 2: flattern it in init, and use one pointer Pro: cleaner Con: need extra space given n total elements Time : O(n) Space: O(1) \"\"\" def __init__ ( self , vec : List [ List [ int ]]): self . vec = vec self . i = 0 # 1d self . j = 0 # 2d self . moveToValidI () # if self.i is not valid, keep moving self.i def next ( self ) -> int : result = self . vec [ self . i ][ self . j ] self . j += 1 # if j reaches the end of vec[i] and move i if self . j == len ( self . vec [ self . i ]): self . i += 1 self . moveToValidI () self . j = 0 return result def hasNext ( self ) -> bool : return self . i < len ( self . vec ) and self . j < len ( self . vec [ self . i ]) def moveToValidI ( self ): \"\"\" keep moving i until it's a vec[i] that has elements \"\"\" while self . i < len ( self . vec ) and not self . vec [ self . i ]: self . i += 1 # Your Vector2D object will be instantiated and called as such: # obj = Vector2D(vec) # param_1 = obj.next() # param_2 = obj.hasNext()","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0251_flatten-2d-vector.html","loc":"https://tofucode.com/posts/leetcode_0251_flatten-2d-vector.html"},{"title":"Leetcode 0270. Closest Binary Search Tree Value","text":"Question Link : https://leetcode.com/problems/closest-binary-search-tree-value/ Difficulty: Easy Premium: True Question Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target. If there are multiple answers, print the smallest. Example 1: Input: root = [4,2,5,1,3], target = 3.714286 Output: 4 Example 2: Input: root = [1], target = 4.428571 Output: 1 Constraints: The number of nodes in the tree is in the range [1, 104]. 0 <= Node.val <= 109 -109 <= target <= 109 Solution traverse the tree and either go left or right after comparing the current node. Remember to hangle the ask that we want the smallest answer when there are equal distance answers. Code ''' Leetcode 0270. Closest Binary Search Tree Value Question Link : https://leetcode.com/problems/closest-binary-search-tree-value/ Solution Link : https://tofucode.com/posts/leetcode_0270_closest-binary-search-tree-value.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def closestValue ( self , root : Optional [ TreeNode ], target : float ) -> int : \"\"\" compare with node val: if target <= node: go left else: go right - binary search record the last seen check if current seen is closer Time : O(log n) Space: O(1) \"\"\" self . result = math . inf self . traverse ( root , target ) return self . result def traverse ( self , node , target ): if not node : return previous_distance = abs ( self . result - target ) current_distance = abs ( node . val - target ) if current_distance == previous_distance : if node . val < self . result : self . result = node . val if current_distance < previous_distance : self . result = node . val if node . val == target : return elif target < node . val : self . traverse ( node . left , target ) else : self . traverse ( node . right , target )","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_0270_closest-binary-search-tree-value.html","loc":"https://tofucode.com/posts/leetcode_0270_closest-binary-search-tree-value.html"},{"title":"Leetcode 1213. Intersection of Three Sorted Arrays","text":"Question Link : https://leetcode.com/problems/intersection-of-three-sorted-arrays/ Difficulty: Easy Premium: True Question Given three integer arrays arr1, arr2 and arr3 sorted in strictly increasing order, return a sorted array of only the integers that appeared in all three arrays. Example 1: Input: arr1 = [1,2,3,4,5], arr2 = [1,2,5,7,9], arr3 = [1,3,4,5,8] Output: [1,5] Explanation: Only 1 and 5 appeared in the three arrays. Example 2: Input: arr1 = [197,418,523,876,1356], arr2 = [501,880,1593,1710,1870], arr3 = [521,682,1337,1395,1764] Output: [] Constraints: 1 <= arr1.length, arr2.length, arr3.length <= 1000 1 <= arr1[i], arr2[i], arr3[i] <= 2000 Solution use 3 pointers one for each array and figure out in a chile loop which one to move Code ''' Leetcode 1213. Intersection of Three Sorted Arrays Question Link : https://leetcode.com/problems/intersection-of-three-sorted-arrays/ Solution Link : https://tofucode.com/posts/leetcode_1213_intersection-of-three-sorted-arrays.html ''' class Solution : def arraysIntersection ( self , arr1 : List [ int ], arr2 : List [ int ], arr3 : List [ int ]) -> List [ int ]: \"\"\" return sorted, only if in all 3 arrays [1,2,3,4,5] [1,2,5,7,9] [1,3,4,5,8] return [1, 5] 3 pointers to loop through all 3 arrays try to find the same element when the same: record result, when any one when not the same: move the one that points to the smallest [1,2,3,4,5] i [1,2,5,7,9] j [1,3,4,5,8] k Time : O(n) Space: O(n) for result \"\"\" i = 0 j = 0 k = 0 result = [] while i < len ( arr1 ) and j < len ( arr2 ) and k < len ( arr3 ): if arr1 [ i ] == arr2 [ j ] == arr3 [ k ]: result . append ( arr1 [ i ]) i += 1 j += 1 k += 1 else : if arr1 [ i ] <= arr2 [ j ] and arr1 [ i ] <= arr3 [ k ]: i += 1 elif arr2 [ j ] <= arr1 [ i ] and arr2 [ j ] <= arr3 [ k ]: j += 1 elif arr3 [ k ] <= arr1 [ i ] and arr3 [ k ] <= arr2 [ j ]: k += 1 return result","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_1213_intersection-of-three-sorted-arrays.html","loc":"https://tofucode.com/posts/leetcode_1213_intersection-of-three-sorted-arrays.html"},{"title":"Leetcode 1257. Smallest Common Region","text":"Question Link : https://leetcode.com/problems/smallest-common-region/ Difficulty: Medium Premium: True Question You are given some lists of regions where the first region of each list includes all other regions in that list. Naturally, if a region x contains another region y then x is bigger than y. Also, by definition, a region x contains itself. Given two regions: region1 and region2, return the smallest region that contains both of them. If you are given regions r1, r2, and r3 such that r1 includes r3, it is guaranteed there is no r2 such that r2 includes r3. It is guaranteed the smallest region exists. Example 1: Input: regions = [[\"Earth\",\"North America\",\"South America\"], [\"North America\",\"United States\",\"Canada\"], [\"United States\",\"New York\",\"Boston\"], [\"Canada\",\"Ontario\",\"Quebec\"], [\"South America\",\"Brazil\"]], region1 = \"Quebec\", region2 = \"New York\" Output: \"North America\" Example 2: Input: regions = [[\"Earth\", \"North America\", \"South America\"],[\"North America\", \"United States\", \"Canada\"],[\"United States\", \"New York\", \"Boston\"],[\"Canada\", \"Ontario\", \"Quebec\"],[\"South America\", \"Brazil\"]], region1 = \"Canada\", region2 = \"South America\" Output: \"Earth\" Constraints: 2 <= regions.length <= 104 2 <= regions[i].length <= 20 1 <= regions[i][j].length, region1.length, region2.length <= 20 region1 != region2 regions[i][j], region1, and region2 consist of English letters. The input is generated such that there exists a region which contains all the other regions, either directly or indirectly. Solution LCA problem, since the only info we care about here are the names, we can just use a dict instead of building out a Node class Code ''' Leetcode 1257. Smallest Common Region Question Link : https://leetcode.com/problems/smallest-common-region/ Solution Link : https://tofucode.com/posts/leetcode_1257_smallest-common-region.html ''' class Solution : def findSmallestRegion ( self , regions : List [ List [ str ]], region1 : str , region2 : str ) -> str : \"\"\" regions = [ [\"Earth\",\"North America\",\"South America\"], [\"North America\",\"United States\",\"Canada\"], [\"United States\",\"New York\",\"Boston\"], [\"Canada\",\"Ontario\",\"Quebec\"], [\"South America\",\"Brazil\"] ], for a sublist: first is the parent eg: Quebec (Quebec - Canada - North America) New York (New York - United States - North America) ask: region1, region2 find the first common ancester Tree: and find first common ancester 1. set up Tree: do we need Node class: no: all we care about is the child -> parent, use a dict Go through regions list and build a tree 3. find first common ancester traverse one region up to root and store in set() traverse second region up and return first common Time : O(n) Space: O(n) \"\"\" nodes = {} # child -> parent # set up tree for region_info in regions : parent_name = region_info [ 0 ] children_names = region_info [ 1 :] for child_name in children_names : nodes [ child_name ] = parent_name # find common ancestor p = region1 seen = set () while p : seen . add ( p ) p = nodes . get ( p , None ) p = region2 while p : if p in seen : return p p = nodes . get ( p , None )","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_1257_smallest-common-region.html","loc":"https://tofucode.com/posts/leetcode_1257_smallest-common-region.html"},{"title":"Leetcode 1644. Lowest Common Ancestor of a Binary Tree II","text":"Question Link : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/ Difficulty: Medium Premium: True Question Given the root of a binary tree, return the lowest common ancestor (LCA) of two given nodes, p and q. If either node p or q does not exist in the tree, return null. All values of the nodes in the tree are unique. According to the definition of LCA on Wikipedia: \"The lowest common ancestor of two nodes p and q in a binary tree T is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself)\". A descendant of a node x is a node y that is on the path from node x to some leaf node. Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5. A node can be a descendant of itself according to the definition of LCA. Example 3: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 10 Output: null Explanation: Node 10 does not exist in the tree, so return null. Constraints: The number of nodes in the tree is in the range [1, 104]. -109 <= Node.val <= 109 All Node.val are unique. p != q Follow up: Can you find the LCA traversing the tree, without checking nodes existence? Solution Similiar to the first LCA problem, the change here is since that p and q could be non-existant, we need to traverse the entire tree Code ''' Leetcode 1644. Lowest Common Ancestor of a Binary Tree II Question Link : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/ Solution Link : https://tofucode.com/posts/leetcode_1644_lowest-common-ancestor-of-a-binary-tree-ii.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution : def lowestCommonAncestor ( self , root : 'TreeNode' , p : 'TreeNode' , q : 'TreeNode' ) -> 'TreeNode' : \"\"\" find LCA of p and q: traverse the tree (all through the whole tree) build dict of child -> parent seen = set() take p, traverse back up to root, store in seen take q travese back and return first item already in seen Time : O(n) Space: O(n) \"\"\" nodes = {} # child node -> parent node self . traverse ( root , nodes , p , q ) seen = set () x = p while x : seen . add ( x ) x = nodes . get ( x , None ) x = q while x : if x in seen : return x x = nodes . get ( x , None ) return None def traverse ( self , root , nodes , p , q ): if not root : return stack = [ root ] while stack : node = stack . pop () # dfs l = node . left r = node . right if l : nodes [ l ] = node stack . append ( l ) if r : nodes [ r ] = node stack . append ( r )","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_1644_lowest-common-ancestor-of-a-binary-tree-ii.html","loc":"https://tofucode.com/posts/leetcode_1644_lowest-common-ancestor-of-a-binary-tree-ii.html"},{"title":"Leetcode 1650. Lowest Common Ancestor of a Binary Tree III","text":"Question Link : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/ Difficulty: Medium Premium: True Question Given two nodes of a binary tree p and q, return their lowest common ancestor (LCA). Each node will have a reference to its parent node. The definition for Node is below: class Node { public int val; public Node left; public Node right; public Node parent; } According to the definition of LCA on Wikipedia: \"The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself).\" Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition. Example 3: Input: root = [1,2], p = 1, q = 2 Output: 1 Constraints: The number of nodes in the tree is in the range [2, 105]. -109 <= Node.val <= 109 All Node.val are unique. p != q p and q exist in the tree. Solution Since there is already parent pointer in each node, this makes it an easier LCA problem Code ''' Leetcode 1650. Lowest Common Ancestor of a Binary Tree III Question Link : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/ Solution Link : https://tofucode.com/posts/leetcode_1650_lowest-common-ancestor-of-a-binary-tree-iii.html ''' \"\"\" # Definition for a Node. class Node: def __init__(self, val): self.val = val self.left = None self.right = None self.parent = None \"\"\" class Solution : def lowestCommonAncestor ( self , p : 'Node' , q : 'Node' ) -> 'Node' : \"\"\" node -> parent seen = set() traverse p, and store into seen traverse q, and return first that's in seen Time : O(n) Space: O(n) \"\"\" seen = set () x = p while x : seen . add ( x ) x = x . parent x = q while x : if x in seen : return x x = x . parent","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_1650_lowest-common-ancestor-of-a-binary-tree-iii.html","loc":"https://tofucode.com/posts/leetcode_1650_lowest-common-ancestor-of-a-binary-tree-iii.html"},{"title":"Leetcode 2107. Number of Unique Flavors After Sharing K Candies","text":"Question Link : https://leetcode.com/problems/number-of-unique-flavors-after-sharing-k-candies/ Difficulty: Medium Premium: True Question You are given a 0-indexed integer array candies, where candies[i] represents the flavor of the ith candy. Your mom wants you to share these candies with your little sister by giving her k consecutive candies, but you want to keep as many flavors of candies as possible. Return the maximum number of unique flavors of candy you can keep after sharing with your sister. Example 1: Input: candies = [1,2,2,3,4,3], k = 3 Output: 3 Explanation: Give the candies in the range [1, 3] (inclusive) with flavors [2,2,3]. You can eat candies with flavors [1,4,3]. There are 3 unique flavors, so return 3. Example 2: Input: candies = [2,2,2,2,3,3], k = 2 Output: 2 Explanation: Give the candies in the range [3, 4] (inclusive) with flavors [2,3]. You can eat candies with flavors [2,2,2,3]. There are 2 unique flavors, so return 2. Note that you can also share the candies with flavors [2,2] and eat the candies with flavors [2,2,3,3]. Example 3: Input: candies = [2,4,5], k = 0 Output: 3 Explanation: You do not have to give any candies. You can eat the candies with flavors [2,4,5]. There are 3 unique flavors, so return 3. Constraints: 1 <= candies.length <= 105 1 <= candies[i] <= 105 0 <= k <= candies.length Solution Since the ask is to take out a consecutive piece of length k - this first thought is that this could be a sliding window provlem with a constant length. The resulting unique candies can be maintained with a dict outside of the fixed sliding window. Code ''' Leetcode 2107. Number of Unique Flavors After Sharing K Candies Question Link : https://leetcode.com/problems/number-of-unique-flavors-after-sharing-k-candies/ Solution Link : https://tofucode.com/posts/leetcode_2107_number-of-unique-flavors-after-sharing-k-candies.html ''' class Solution : def shareCandies ( self , candies : List [ int ], k : int ) -> int : \"\"\" candies = [1,2,2,3,4,3], k = 3 give out [2,2,3], eat [1,4,3] give out k consecutive candies return set(rest) as unique flavors sliding window, want to find the largest set outside of the sliding window l = 0 r = l+k constant length window of k maintain a dict {} of flavor -> count of everything outside the sliding window on window move: adjust this dict: take out left end of window, add in right end of window [1,2,2,3,4,3] count: {3: 2, 4: 1} - init [1,2,2]: max 2 flavors count: {1: 1, 3: 1, 4 : 1} moved to [2,2,3]: max 3 flavors Time : O(n) Space: O(n) \"\"\" count = {} # flavor -> count # set up count on initial window for i in range ( k , len ( candies )): candy = candies [ i ] count [ candy ] = count . get ( candy , 0 ) + 1 result = len ( count ) # slide window and recalculate: # window: take left out, add right - next one in # count dict: add left in, take right out for i in range ( k , len ( candies )): l = i - k r = i l_candy = candies [ l ] r_candy = candies [ r ] # count: add left in, take right out count [ l_candy ] = count . get ( l_candy , 0 ) + 1 count [ r_candy ] -= 1 if count [ r_candy ] == 0 : del count [ r_candy ] result = max ( result , len ( count )) return result","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_2107_number-of-unique-flavors-after-sharing-k-candies.html","loc":"https://tofucode.com/posts/leetcode_2107_number-of-unique-flavors-after-sharing-k-candies.html"},{"title":"Leetcode 2389. Longest Subsequence With Limited Sum","text":"Question Link : https://leetcode.com/problems/longest-subsequence-with-limited-sum/ Difficulty: Easy Premium: False Question You are given an integer array nums of length n, and an integer array queries of length m. Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i]. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. Example 1: Input: nums = [4,5,2,1], queries = [3,10,21] Output: [2,3,4] Explanation: We answer the queries as follows: - The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2. - The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3. - The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4. Example 2: Input: nums = [2,3,4,5], queries = [1] Output: [0] Explanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0. Constraints: n == nums.length m == queries.length 1 <= n, m <= 1000 1 <= nums[i], queries[i] <= 106 Solution Sort the given nums so we can start adding from the smallest to get the max number of nums used. We then go through the subset sum array and find the number when the subset sum is still smaller than the query. We can further improve the second process with a binary search. Code ''' Leetcode 2389. Longest Subsequence With Limited Sum Question Link : https://leetcode.com/problems/longest-subsequence-with-limited-sum/ Solution Link : https://tofucode.com/posts/leetcode_2389_longest-subsequence-with-limited-sum.html ''' class Solution : def answerQueries ( self , nums : List [ int ], queries : List [ int ]) -> List [ int ]: ''' how many max number out of nums sum <= queries[i] [4,5,2,1] sort and subset sum 1 2 4 5 1 3 7 12 for queries[i]: loop through subset sum, and see where it goes to Time : O(n log n + m n) n nums, m queries Space: O(n) ''' nums = sorted ( nums ) sub = [] for num in nums : if not sub : sub . append ( num ) else : sub . append ( num + sub [ - 1 ]) result = [] for q in queries : r = 0 for s in sub : if s <= q : r += 1 else : break result . append ( r ) return result class SolutionImproved1 : def answerQueries ( self , nums : List [ int ], queries : List [ int ]) -> List [ int ]: ''' Improve as binary search # For each query, find its insertion index to the prefix sum array idx = bisect.bisect_right(sub, q) answer.append(idx) Time : O(n log n + m log n) n nums, m queries Space: O(n) ''' nums = sorted ( nums ) sub = [] for num in nums : if not sub : sub . append ( num ) else : sub . append ( num + sub [ - 1 ]) result = [] for q in queries : idx = bisect . bisect_right ( sub , q ) result . append ( idx ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2389_longest-subsequence-with-limited-sum.html","loc":"https://tofucode.com/posts/leetcode_2389_longest-subsequence-with-limited-sum.html"},{"title":"Leetcode 2955. Number of Same-End Substrings","text":"Question Link : https://leetcode.com/problems/number-of-same-end-substrings/ Difficulty: Medium Premium: True Question You are given a 0-indexed string s, and a 2D array of integers queries, where queries[i] = [li, ri] indicates a substring of s starting from the index li and ending at the index ri (both inclusive), i.e. s[li..ri]. Return an array ans where ans[i] is the number of same-end substrings of queries[i]. A 0-indexed string t of length n is called same-end if it has the same character at both of its ends, i.e., t[0] == t[n - 1]. A substring is a contiguous non-empty sequence of characters within a string. Example 1: Input: s = \"abcaab\", queries = [[0,0],[1,4],[2,5],[0,5]] Output: [1,5,5,10] Explanation: Here is the same-end substrings of each query: 1st query: s[0..0] is \"a\" which has 1 same-end substring: \"a\". 2nd query: s[1..4] is \"bcaa\" which has 5 same-end substrings: \"bcaa\", \"bcaa\", \"bcaa\", \"bcaa\", \"bcaa\". 3rd query: s[2..5] is \"caab\" which has 5 same-end substrings: \"caab\", \"caab\", \"caab\", \"caab\", \"caab\". 4th query: s[0..5] is \"abcaab\" which has 10 same-end substrings: \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\", \"abcaab\". Example 2: Input: s = \"abcd\", queries = [[0,3]] Output: [4] Explanation: The only query is s[0..3] which is \"abcd\". It has 4 same-end substrings: \"abcd\", \"abcd\", \"abcd\", \"abcd\". Constraints: 2 <= s.length <= 3 * 104 s consists only of lowercase English letters. 1 <= queries.length <= 3 * 104 queries[i] = [li, ri] 0 <= li <= ri < s.length Solution The main observation to make is that given each query, what matters is the number of occurance every char and use that to calculate the number of substrings for that char. To find the number of occurances, one can use: 1) linear search 2) binary search 3) prefix sum Code ''' Leetcode 2955. Number of Same-End Substrings Question Link : https://leetcode.com/problems/number-of-same-end-substrings/ Solution Link : https://tofucode.com/posts/leetcode_2955_number-of-same-end-substrings.html ''' class Solution : def sameEndSubstringCount ( self , s : str , queries : List [ List [ int ]]) -> List [ int ]: \"\"\" s = \"abcaab\", queries = [[0,0],[1,4],[2,5],[0,5]] query: left and right inclusive same-end: if it has the same character at both of its ends, i.e., t[0] == t[n - 1]. abcaab 012345 process s: for each char have a char->[position] a->[0, 3, 4] b->[1, 5] c->[2] for each query check the overlap of it between [position] [0,0] just a: 1 [1,4] overlaps a[3, 4], b [1], c[2] a[3, 4]: 1 + 1 + 2 (combination: 2 + 1 ) b[1]: 1 c[2]: 1 eg. abcaab a:[0, 3, 4]: 6 = 3 + 2 + 1 6 = (1 + 3) * 3 / 2 s of n length, q queries Time : O(n + nq) This will TLE Space: O(q) \"\"\" # build char to positions mapping positions = {} # char -> [idx] for i in range ( len ( s )): c = s [ i ] positions [ c ] = positions . get ( c , []) + [ i ] # go through each query result = [] for query in queries : total = 0 l , r = query # check overlap for k , position_list in positions . items (): overlap_count = 0 for p in position_list : if l <= p <= r : overlap_count += 1 total += ( 1 + overlap_count ) * overlap_count // 2 result . append ( total ) return result class SolutionImproved1 : def sameEndSubstringCount ( self , s : str , queries : List [ List [ int ]]) -> List [ int ]: \"\"\" Improved to binary search s = \"abcaab\", queries = [[0,0],[1,4],[2,5],[0,5]] query: left and right inclusive same-end: if it has the same character at both of its ends, i.e., t[0] == t[n - 1]. abcaab 012345 process s: for each char have a char->[position] a->[0, 3, 4] b->[1, 5] c->[2] for each query check the overlap of it between [position] [0,0] just a: 1 [1,4] overlaps a[3, 4], b [1], c[2] a[3, 4]: 1 + 1 + 2 (combination: 2 + 1 ) b[1]: 1 c[2]: 1 eg. abcaab a:[0, 3, 4]: 6 = 3 + 2 + 1 6 = (1 + 3) * 3 / 2 s of n length, q queries Time : O(n + q * log n) Space: O(q) \"\"\" # build char to positions mapping positions = {} # char -> [idx] for i in range ( len ( s )): c = s [ i ] positions [ c ] = positions . get ( c , []) + [ i ] # go through each query result = [] for query in queries : total = 0 l , r = query # check overlap for k , position_list in positions . items (): left_bound = bisect_left ( position_list , l ) right_bound = bisect_right ( position_list , r ) overlap_count = right_bound - left_bound total += ( 1 + overlap_count ) * overlap_count // 2 result . append ( total ) return result class SolutionImproved2 : def sameEndSubstringCount ( self , s : str , queries : List [ List [ int ]]) -> List [ int ]: \"\"\" Improved to prefix sum s = \"abcaab\", queries = [[0,0],[1,4],[2,5],[0,5]] query: left and right inclusive same-end: if it has the same character at both of its ends, i.e., t[0] == t[n - 1]. abcaab 012345 n = 6 first frequence: a: [1, 0, 0, 1, 1, 0] then prefix sum: a: [1, 1, 1, 2, 3, 0] a: [0,0] just a at position 0: 1 [1,4] = 3 s of n length, q queries Time : O(n + q) Space: O(n) \"\"\" # prefix sum 2d array: every row is a char's prefix sum array n = len ( s ) prefix_sum = [[ 0 ] * n for _ in range ( 26 )] # calculate frequency for i in range ( len ( s )): c = s [ i ] prefix_sum [ ord ( c ) - ord ( \"a\" )][ i ] += 1 # calculate prefix sum for char_prefix in prefix_sum : for j in range ( 1 , n ): char_prefix [ j ] += char_prefix [ j - 1 ] # go through each query result = [] for query in queries : total = 0 l , r = query # check overlap for char_prefix in prefix_sum : left_freq = 0 if l == 0 else char_prefix [ l - 1 ] right_freq = char_prefix [ r ] overlap_count = right_freq - left_freq total += ( 1 + overlap_count ) * overlap_count // 2 result . append ( total ) return result","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_2955_number-of-same-end-substrings.html","loc":"https://tofucode.com/posts/leetcode_2955_number-of-same-end-substrings.html"},{"title":"Leetcode 3263. Convert Doubly Linked List to Array I","text":"Question Link : https://leetcode.com/problems/convert-doubly-linked-list-to-array-i/ Difficulty: Easy Premium: True Question You are given the head of a doubly linked list, which contains nodes that have a next pointer and a previous pointer. Return an integer array which contains the elements of the linked list in order. Example 1: Input: head = [1,2,3,4,3,2,1] Output: [1,2,3,4,3,2,1] Example 2: Input: head = [2,2,2,2,2] Output: [2,2,2,2,2] Example 3: Input: head = [3,2,3,2,3,2] Output: [3,2,3,2,3,2] Constraints: The number of nodes in the given list is in the range [1, 50]. 1 <= Node.val <= 50 Solution Iterate through and store in an array Code ''' Leetcode 3263. Convert Doubly Linked List to Array I Question Link : https://leetcode.com/problems/convert-doubly-linked-list-to-array-i/ Solution Link : https://tofucode.com/posts/leetcode_3263_convert-doubly-linked-list-to-array-i.html ''' \"\"\" # Definition for a Node. class Node: def __init__(self, val, prev=None, next=None): self.val = val self.prev = prev self.next = next \"\"\" class Solution : def toArray ( self , root : 'Optional[Node]' ) -> List [ int ]: ''' iterate through Time : O(n) Space: O(n) ''' result = [] p = root while p : result . append ( p . val ) p = p . next return result","tags":"Leetcode Premium","url":"https://tofucode.com/posts/leetcode_3263_convert-doubly-linked-list-to-array-i.html","loc":"https://tofucode.com/posts/leetcode_3263_convert-doubly-linked-list-to-array-i.html"},{"title":"Leetcode 0236. Lowest Common Ancestor of a Binary Tree","text":"Question Link : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ Difficulty: Medium Premium: False Question Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\" Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Example 3: Input: root = [1,2], p = 1, q = 2 Output: 1 Constraints: The number of nodes in the tree is in the range [2, 105]. -109 <= Node.val <= 109 All Node.val are unique. p != q p and q will exist in the tree. Solution We traverse the tree and build a mapping of child -> parent node. Take p, take q and keep traversing back to parent, we return the first intersection. Code ''' Leetcode 0236. Lowest Common Ancestor of a Binary Tree Question Link : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0236_lowest-common-ancestor-of-a-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution : def lowestCommonAncestor ( self , root : 'TreeNode' , p : 'TreeNode' , q : 'TreeNode' ) -> 'TreeNode' : \"\"\" find LCA of p and q: traverse the tree (stop when found p and q) build dict of child -> parent seen = set() take p, traverse back up to root, store in seen take q travese back and return first item already in seen Time : O(n) Space: O(n) \"\"\" nodes = {} # child node -> parent node self . traverse ( root , nodes , p , q ) seen = set () x = p while x : seen . add ( x ) x = nodes . get ( x , None ) x = q while x : if x in seen : return x x = nodes . get ( x , None ) def traverse ( self , root , nodes , p , q ): if not root : return stack = [ root ] while stack : node = stack . pop () # dfs l = node . left r = node . right if l : nodes [ l ] = node stack . append ( l ) if r : nodes [ r ] = node stack . append ( r ) if p in nodes and q in nodes : return","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0236_lowest-common-ancestor-of-a-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0236_lowest-common-ancestor-of-a-binary-tree.html"},{"title":"Leetcode 0039. Combination Sum","text":"Question Link : https://leetcode.com/problems/combination-sum/ Difficulty: Medium Premium: False Question Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Example 1: Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Example 2: Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] Example 3: Input: candidates = [2], target = 1 Output: [] Constraints: 1 <= candidates.length <= 30 2 <= candidates[i] <= 40 All elements of candidates are distinct. 1 <= target <= 40 Solution Since we want to find all possible combinations, backtracking is the way to go. To allow using an element multiple times, include the current index when passing it down. Code ''' Leetcode 0039. Combination Sum Question Link : https://leetcode.com/problems/combination-sum/ Solution Link : https://tofucode.com/posts/leetcode_0039_combination-sum.html ''' class Solution : def combinationSum ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: ''' candidates to form target: * any number of times * unique combo * find all -> backtracking info: nums, current idx, remaining target, path, result when target is 0: reached a successful path otherwise from current idx to the end (including current), try and take that num [2,3,6,7], target = 7 idx, target, path 0, 7, [] check idx 0 for loop 0, 5, [2] 0, 3, [2, 2] 1, 0, [2, 2, 3] (append to result) 1, 4, [3] 2, 1, [6] 3, 0, [7] (append to result) n candidates, t target value, m smallest minimal number worst case that the target is composed of all of the smallest number: t / m Time : O(n &#94; (t / m)) Space: O(t / m) ''' nums = sorted ( candidates ) result = [] self . backtrack ( nums , 0 , target , [], result ) return result def backtrack ( self , nums , idx , target , path , result ): if target == 0 : result . append ( path ) return for i in range ( idx , len ( nums )): num = nums [ i ] t = target - num if t < 0 : return self . backtrack ( nums , i , t , path + [ num ], result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0039_combination-sum.html","loc":"https://tofucode.com/posts/leetcode_0039_combination-sum.html"},{"title":"Leetcode 0190. Reverse Bits","text":"Question Link : https://leetcode.com/problems/reverse-bits/ Difficulty: Easy Premium: False Question Reverse bits of a given 32 bits unsigned integer. Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825. Example 1: Input: n = 00000010100101000001111010011100 Output: 964176192 (00111001011110000010100101000000) Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: n = 11111111111111111111111111111101 Output: 3221225471 (10111111111111111111111111111111) Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Constraints: The input must be a binary string of length 32 Follow up: If this function is called many times, how would you optimize it? Solution Use bit operations to go through each bit and add the least significant bit each time to result Code ''' Leetcode 0190. Reverse Bits Question Link : https://leetcode.com/problems/reverse-bits/ Solution Link : https://tofucode.com/posts/leetcode_0190_reverse-bits.html ''' class Solution : def reverseBits ( self , n : int ) -> int : \"\"\" 32 bit int: [0 ... 31] index i -> 31 - i for each bit: shift result left, so can add to least sig get the least sig bit (OR): n & mask add it to result (AND) shift n right for the next least sig bit Time : O(1) Space: O(1) \"\"\" result = 0 mask = 1 for _ in range ( 32 ): result = result << 1 result |= n & mask n = n >> 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0190_reverse-bits.html","loc":"https://tofucode.com/posts/leetcode_0190_reverse-bits.html"},{"title":"Leetcode 0202. Happy Number","text":"Question Link : https://leetcode.com/problems/happy-number/ Difficulty: Easy Premium: False Question Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. Return true if n is a happy number, and false if not. Example 1: Input: n = 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 Example 2: Input: n = 2 Output: false Constraints: 1 <= n <= 231 - 1 Solution Since we need to exit if the loops continues endlessly, it is pretty straightforward to use a set to track all seen numbers for this. An improvement to cut down the space is to change to track fast and slow pointers and solve it as a graph cycle problem. Code ''' Leetcode 0202. Happy Number Question Link : https://leetcode.com/problems/happy-number/ Solution Link : https://tofucode.com/posts/leetcode_0202_happy-number.html ''' class Solution : def isHappy ( self , n : int ) -> bool : \"\"\" 19 1 &#94; 2 + 9 &#94; 2 = 82 = 1: happy endless loop: not happy use a set to check if seen: if seen and can return false Time : O(log n) Space: O(log n) \"\"\" seen = set () while not n in seen : seen . add ( n ) n = self . process ( n ) if n == 1 : return True return False def process ( self , num ): \"\"\" Time : O(log n) to go through all digits of a number n = 999, 3 digits: 10&#94;2 <= 999 < 10&#94;3 given n with d digits: 10&#94;(d-1) <= n < 10&#94;(d) take base 10 log: log(10&#94;(d-1)) <= log(n) < log(10&#94;(d)) d-1 <= log(n) < d So: d <= log(n) + 1 log(n) < d worst case log(n) \"\"\" result = 0 for c in str ( num ): result += int ( c ) ** 2 return result class SolutionImproved1 : def isHappy ( self , n : int ) -> bool : \"\"\" 19 1 &#94; 2 + 9 &#94; 2 = 82 = 1: happy endless loop: not happy as a graph problem, where each number is a state / node use two pointers: fast / slow start: slow: n fast: process(n) every step: slow 1 step fast: 2 steps Time : O(log n) Space: O(1) \"\"\" slow = n fast = self . process ( n ) while slow != fast : if fast == 1 : break slow = self . process ( slow ) fast = self . process ( self . process ( fast )) return fast == 1 # takes care if n == 1 def process ( self , num ): \"\"\" Time : O(log n) to go through all digits of a number n = 999, 3 digits: 10&#94;2 <= 999 < 10&#94;3 given n with d digits: 10&#94;(d-1) <= n < 10&#94;(d) take base 10 log: log(10&#94;(d-1)) <= log(n) < log(10&#94;(d)) d-1 <= log(n) < d So: d <= log(n) + 1 log(n) < d worst case log(n) \"\"\" result = 0 for c in str ( num ): result += int ( c ) ** 2 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0202_happy-number.html","loc":"https://tofucode.com/posts/leetcode_0202_happy-number.html"},{"title":"Leetcode 0217. Contains Duplicate","text":"Question Link : https://leetcode.com/problems/contains-duplicate/ Difficulty: Easy Premium: False Question Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1: Input: nums = [1,2,3,1] Output: true Explanation: The element 1 occurs at the indices 0 and 3. Example 2: Input: nums = [1,2,3,4] Output: false Explanation: All elements are distinct. Example 3: Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true Constraints: 1 <= nums.length <= 105 -109 <= nums[i] <= 109 Solution Use a set Code ''' Leetcode 0217. Contains Duplicate Question Link : https://leetcode.com/problems/contains-duplicate/ Solution Link : https://tofucode.com/posts/leetcode_0217_contains-duplicate.html ''' class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : \"\"\" nums: is a dup: true all distinct: false use a set and go through nums Time : O(n) Space: O(n) \"\"\" seen = set () for num in nums : if num in seen : return True seen . add ( num ) return False","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0217_contains-duplicate.html","loc":"https://tofucode.com/posts/leetcode_0217_contains-duplicate.html"},{"title":"Leetcode 0415. Add Strings","text":"Question Link : https://leetcode.com/problems/add-strings/ Difficulty: Easy Premium: False Question Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly. Example 1: Input: num1 = \"11\", num2 = \"123\" Output: \"134\" Example 2: Input: num1 = \"456\", num2 = \"77\" Output: \"533\" Example 3: Input: num1 = \"0\", num2 = \"0\" Output: \"0\" Constraints: 1 <= num1.length, num2.length <= 104 num1 and num2 consist of only digits. num1 and num2 don't have any leading zeros except for the zero itself. Solution process the result from back to front, taking care of the carry Code ''' Leetcode 0415. Add Strings Question Link : https://leetcode.com/problems/add-strings/ Solution Link : https://tofucode.com/posts/leetcode_0415_add-strings.html ''' class Solution : def addStrings ( self , num1 : str , num2 : str ) -> str : \"\"\" num1 + num2 non negative return sum as str Proposal: add digit by digit with carry different length: make num2 longer, starting from back go through the short one num1 anything remaining in num2 go through the rest result we'll collect in reverse 456 + 77 77 456 3 carry over 1 33 carry over 1 533 Time : O(m + n) Space: O(m + n) \"\"\" # num2 is longer if len ( num1 ) > len ( num2 ): num1 , num2 = num2 , num1 # two pointers from the back i = len ( num1 ) - 1 j = len ( num2 ) - 1 result = [] carry = 0 # go through based on num1 while i >= 0 : digit , carry = self . cal ( num1 [ i ], num2 [ j ], carry ) result . append ( digit ) i -= 1 j -= 1 # go through remaining num2, code num1 part as 0 while j >= 0 : digit , carry = self . cal ( \"0\" , num2 [ j ], carry ) result . append ( digit ) j -= 1 # check final carry if carry : result . append ( 1 ) return '' . join ( str ( x ) for x in result [:: - 1 ]) def cal ( self , x : str , y : str , carry : int ) -> ( int , int ): \"\"\" given the current number char x and y and carry return digit and carry as int \"\"\" a = int ( x ) b = int ( y ) digit = a + b + carry if digit >= 10 : digit %= 10 carry = 1 else : carry = 0 return digit , carry","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0415_add-strings.html","loc":"https://tofucode.com/posts/leetcode_0415_add-strings.html"},{"title":"Leetcode 0111. Minimum Depth of Binary Tree","text":"Question Link : https://leetcode.com/problems/minimum-depth-of-binary-tree/ Difficulty: Easy Premium: False Question Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example 1: Input: root = [3,9,20,null,null,15,7] Output: 2 Example 2: Input: root = [2,null,3,null,4,null,5,null,6] Output: 5 Constraints: The number of nodes in the tree is in the range [0, 105]. -1000 <= Node.val <= 1000 Solution Since we want to stop at the min depth, use bfs to go layer by layer Code ''' Leetcode 0111. Minimum Depth of Binary Tree Question Link : https://leetcode.com/problems/minimum-depth-of-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0111_minimum-depth-of-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def minDepth ( self , root : Optional [ TreeNode ]) -> int : \"\"\" min depth: shortest path root to first leaf node bfs: can stop at the first leaf node - min depth traverse the tree, pass along depth, record the min depth queue: store node, depth Time : O(n) Space: O(n) \"\"\" if not root : return 0 queue = [( root , 1 )] result = 0 while queue : node , depth = queue . pop ( 0 ) # bfs if not node . left and not node . right : result = depth break if node . left : queue . append (( node . left , depth + 1 )) if node . right : queue . append (( node . right , depth + 1 )) return result class SolutionImproved1 : def minDepth ( self , root : Optional [ TreeNode ]) -> int : \"\"\" Use python deque - so pop from the front is actually O(1) min depth: shortest path root to first leaf node bfs: can stop at the first leaf node - min depth traverse the tree, pass along depth, record the min depth queue: store node, depth Time : O(n) Space: O(n) \"\"\" if not root : return 0 queue = collections . deque ([( root , 1 )]) result = 0 while queue : node , depth = queue . popleft () # bfs if not node . left and not node . right : result = depth break if node . left : queue . append (( node . left , depth + 1 )) if node . right : queue . append (( node . right , depth + 1 )) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0111_minimum-depth-of-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0111_minimum-depth-of-binary-tree.html"},{"title":"Leetcode 0211. Design Add and Search Words Data Structure","text":"Question Link : https://leetcode.com/problems/design-add-and-search-words-data-structure/ Difficulty: Medium Premium: False Question Design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the WordDictionary class: WordDictionary() Initializes the object. void addWord(word) Adds word to the data structure, it can be matched later. bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter. Example: Input [\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"] [[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]] Output [null,null,null,null,false,true,true,true] Explanation WordDictionary wordDictionary = new WordDictionary(); wordDictionary.addWord(\"bad\"); wordDictionary.addWord(\"dad\"); wordDictionary.addWord(\"mad\"); wordDictionary.search(\"pad\"); // return False wordDictionary.search(\"bad\"); // return True wordDictionary.search(\".ad\"); // return True wordDictionary.search(\"b..\"); // return True Constraints: 1 <= word.length <= 25 word in addWord consists of lowercase English letters. word in search consist of '.' or lowercase English letters. There will be at most 2 dots in word for search queries. At most 104 calls will be made to addWord and search. Solution Use a standard trie prefix tree with the change being the dot matching any character. This calls for either dfs/bfs or with recursion. Code ''' Leetcode 0211. Design Add and Search Words Data Structure Question Link : https://leetcode.com/problems/design-add-and-search-words-data-structure/ Solution Link : https://tofucode.com/posts/leetcode_0211_design-add-and-search-words-data-structure.html ''' class TrieNode : def __init__ ( self , c ): self . c = c self . children = {} self . is_leaf = False class WordDictionary : \"\"\" With a trie prefix tree: node: c -> children * for dot . need to check all possible paths * also still need to check is_leaf word length of 25: Time : O(1) Space: O(1) \"\"\" def __init__ ( self ): self . root = TrieNode ( \"\" ) def addWord ( self , word : str ) -> None : current = self . root for c in word : if c in current . children : current = current . children [ c ] else : current . children [ c ] = TrieNode ( c ) current = current . children [ c ] current . is_leaf = True def search ( self , word : str ) -> bool : \"\"\" recursive search cause of the dot \"\"\" return self . check ( word , self . root ) def check ( self , word , node ): \"\"\" check that from node onward contains word \"\"\" if not word : return node . is_leaf c = word [ 0 ] if c == \".\" : for child in node . children . values (): if self . check ( word [ 1 :], child ): return True return False if not c in node . children : return False return self . check ( word [ 1 :], node . children [ c ]) class WordDictionaryAlternative1 : \"\"\" dfs, easier to write First think about normal trie traversal, then realize that there is a spit when a '.' dfs passing down, node and what's left to search word length of 25: Time : O(1) Space: O(1) \"\"\" def __init__ ( self ): self . root = TrieNode ( \"\" ) def addWord ( self , word : str ) -> None : current = self . root for c in word : if c in current . children : current = current . children [ c ] else : current . children [ c ] = TrieNode ( c ) current = current . children [ c ] current . is_leaf = True def search ( self , word : str ) -> bool : stack = [( self . root , word )] while stack : current , w = stack . pop () if w == '' : if current . is_leaf : return True else : continue c = w [ 0 ] if c in current . children : stack . append (( current . children [ c ], w [ 1 :])) elif c == '.' : for child in current . children . values (): stack . append (( child , w [ 1 :])) return False # Your WordDictionary object will be instantiated and called as such: # obj = WordDictionary() # obj.addWord(word) # param_2 = obj.search(word)","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0211_design-add-and-search-words-data-structure.html","loc":"https://tofucode.com/posts/leetcode_0211_design-add-and-search-words-data-structure.html"},{"title":"Leetcode 0623. Add One Row to Tree","text":"Question Link : https://leetcode.com/problems/add-one-row-to-tree/ Difficulty: Medium Premium: False Question Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth. Note that the root node is at depth 1. The adding rule is: Given the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root. cur's original left subtree should be the left subtree of the new left subtree root. cur's original right subtree should be the right subtree of the new right subtree root. If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1: Input: root = [4,2,6,3,1,5], val = 1, depth = 2 Output: [4,1,1,2,null,null,6,3,1,5] Example 2: Input: root = [4,2,null,3,1], val = 1, depth = 3 Output: [4,2,null,1,1,3,null,null,1] Constraints: The number of nodes in the tree is in the range [1, 104]. The depth of the tree is in the range [1, 104]. -100 <= Node.val <= 100 -105 <= val <= 105 1 <= depth <= the depth of tree + 1 Solution Traverse the tree with dfs stack and keep strack of depth information along with each node. At the given dpeth, attach the new nodes. Will have to go through the whole tree. Code ''' Leetcode 0623. Add One Row to Tree Question Link : https://leetcode.com/problems/add-one-row-to-tree/ Solution Link : https://tofucode.com/posts/leetcode_0623_add-one-row-to-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def addOneRow ( self , root : Optional [ TreeNode ], val : int , depth : int ) -> Optional [ TreeNode ]: ''' dfs with a stack (depth, node) # -1 for left, 1 for right at depth-1: create 2 nodes and link Time : O(n) Space: O(n) ''' if depth == 1 : new_node = TreeNode ( val ) new_node . left = root return new_node stack = [( 1 , root )] while stack : d , node = stack . pop () if d == depth - 1 : # create 2 nodes l = TreeNode ( val ) r = TreeNode ( val ) # link node . left , l . left = l , node . left node . right , r . right = r , node . right left = node . left right = node . right if left : stack . append (( d + 1 , left )) if right : stack . append (( d + 1 , right )) return root","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0623_add-one-row-to-tree.html","loc":"https://tofucode.com/posts/leetcode_0623_add-one-row-to-tree.html"},{"title":"Leetcode 0958. Check Completeness of a Binary Tree","text":"Question Link : https://leetcode.com/problems/check-completeness-of-a-binary-tree/ Difficulty: Medium Premium: False Question Given the root of a binary tree, determine if it is a complete binary tree. In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example 1: Input: root = [1,2,3,4,5,6] Output: true Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible. Example 2: Input: root = [1,2,3,4,5,null,7] Output: false Explanation: The node with value 7 isn't as far left as possible. Constraints: The number of nodes in the tree is in the range [1, 100]. 1 <= Node.val <= 1000 Solution Since the question is mainly interested about the last level, we should use bfs. We can use a variable to mark when a null is seen, and then from that moment on, return False if there are still nodes with left or right. Can't check len(stack) as exit condition since there could be nodes on the same level with null children. Code ''' Leetcode 0958. Check Completeness of a Binary Tree Question Link : https://leetcode.com/problems/check-completeness-of-a-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0958_check-completeness-of-a-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def isCompleteTree ( self , root : Optional [ TreeNode ]) -> bool : ''' bfs 1 2, 3 3, 4, 5 4, 5, 6 when at second last layer check: mark when we hit a null, at that point forward: can't have left or right and all null Time : O(h) Space: O(n) ''' if not root : return True queue = [ root ] hit_null = False while queue : node = queue . pop ( 0 ) # bfs if node . left : if hit_null : return False queue . append ( node . left ) else : hit_null = True if node . right : if hit_null : return False queue . append ( node . right ) else : hit_null = True return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0958_check-completeness-of-a-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0958_check-completeness-of-a-binary-tree.html"},{"title":"Leetcode 0026. Remove Duplicates from Sorted Array","text":"Question Link : https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Difficulty: Easy Premium: False Question Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things: Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted. Example 1: Input: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4, , , , ,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: 1 <= nums.length <= 3 * 104 -100 <= nums[i] <= 100 nums is sorted in non-decreasing order. Solution Keep a pointer as an anchor and use a for loop to move the next none dup number forward. Code ''' Leetcode 0026. Remove Duplicates from Sorted Array Question Link : https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Solution Link : https://tofucode.com/posts/leetcode_0026_remove-duplicates-from-sorted-array.html ''' class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : \"\"\" Ask: [0,0,1,1,1,2,2,3,3,4] [0,1,2,3,4,_,_,_,_,_] sorted in non-decreasing order only want one from duplicates: for loop two pointers: x: go through array to find next non dup y: last good position y+1: trailing marker to mark duplicate spot to wrie to move non dup to marker: nums[y+1] = nums[x] [0,0,1,1,1,2,2,3,3,4] x y [0,0,1,1,1,2,2,3,3,4] x y (y+1) [0,1,1,1,1,2,2,3,3,4] y x edge cases: len is 0 or 1 Time : O(n) Space: O(1) \"\"\" if not nums : return 0 y = 0 for x in range ( len ( nums )): if nums [ x ] != nums [ y ]: y += 1 nums [ y ] = nums [ x ] return y + 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0026_remove-duplicates-from-sorted-array.html","loc":"https://tofucode.com/posts/leetcode_0026_remove-duplicates-from-sorted-array.html"},{"title":"Leetcode 0027. Remove Element","text":"Question Link : https://leetcode.com/problems/remove-element/ Difficulty: Easy Premium: False Question Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things: Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i < actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted. Example 1: Input: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2, , ] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3, , ,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: 0 <= nums.length <= 100 0 <= nums[i] <= 50 0 <= val <= 100 Solution Use two pointers to keep switching the good non-val elements forward Code ''' Leetcode 0027. Remove Element Question Link : https://leetcode.com/problems/remove-element/ Solution Link : https://tofucode.com/posts/leetcode_0027_remove-element.html ''' class Solution : def removeElement ( self , nums : List [ int ], val : int ) -> int : \"\"\" Ask: nums = [0,1,2,2,3,0,4,2], val = 2 move 2 out and other numbers forward: [0,1,4,0,3,_,_,_] Proposal: The order of the elements may be changed: switch back and forward two pointers: x, y x from the front: mark val y from the back: mark non val switch x and y [0,1,2,2,3,0,4,2] x y [0,1,4,2,3,0,_,2] x y [0,1,4,0,3,_,_,2] x y Edge case: [1], val = 1 [2,2], val = 2 while loop also needs to run when x = y Time : O(n) Space: O(1) \"\"\" x = 0 y = len ( nums ) - 1 while x <= y : if nums [ y ] == val : y -= 1 elif nums [ x ] != val : x += 1 else : nums [ x ] = nums [ y ] x += 1 y -= 1 return y + 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0027_remove-element.html","loc":"https://tofucode.com/posts/leetcode_0027_remove-element.html"},{"title":"Leetcode 0094. Binary Tree Inorder Traversal","text":"Question Link : https://leetcode.com/problems/binary-tree-inorder-traversal/ Difficulty: Easy Premium: False Question Given the root of a binary tree, return the inorder traversal of its nodes' values. Example 1: Input: root = [1,null,2,3] Output: [1,3,2] Explanation: Example 2: Input: root = [1,2,3,4,5,null,8,null,null,6,7,9] Output: [4,2,6,5,7,1,3,9,8] Explanation: Example 3: Input: root = [] Output: [] Example 4: Input: root = [1] Output: [1] Constraints: The number of nodes in the tree is in the range [0, 100]. -100 <= Node.val <= 100 Follow up: Recursive solution is trivial, could you do it iteratively? Solution Inorder traversal Code ''' Leetcode 0094. Binary Tree Inorder Traversal Question Link : https://leetcode.com/problems/binary-tree-inorder-traversal/ Solution Link : https://tofucode.com/posts/leetcode_0094_binary-tree-inorder-traversal.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def inorderTraversal ( self , root : Optional [ TreeNode ]) -> List [ int ]: ''' inorder: left, node, right Time : O(n) Space: O(n) ''' self . result = [] self . inorder ( root ) return self . result def inorder ( self , node ): if not node : return self . inorder ( node . left ) self . result . append ( node . val ) self . inorder ( node . right )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0094_binary-tree-inorder-traversal.html","loc":"https://tofucode.com/posts/leetcode_0094_binary-tree-inorder-traversal.html"},{"title":"Leetcode 0144. Binary Tree Preorder Traversal","text":"Question Link : https://leetcode.com/problems/binary-tree-preorder-traversal/ Difficulty: Easy Premium: False Question Given the root of a binary tree, return the preorder traversal of its nodes' values. Example 1: Input: root = [1,null,2,3] Output: [1,2,3] Explanation: Example 2: Input: root = [1,2,3,4,5,null,8,null,null,6,7,9] Output: [1,2,4,5,6,7,3,8,9] Explanation: Example 3: Input: root = [] Output: [] Example 4: Input: root = [1] Output: [1] Constraints: The number of nodes in the tree is in the range [0, 100]. -100 <= Node.val <= 100 Follow up: Recursive solution is trivial, could you do it iteratively? Solution Preorder traversal Code ''' Leetcode 0144. Binary Tree Preorder Traversal Question Link : https://leetcode.com/problems/binary-tree-preorder-traversal/ Solution Link : https://tofucode.com/posts/leetcode_0144_binary-tree-preorder-traversal.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def preorderTraversal ( self , root : Optional [ TreeNode ]) -> List [ int ]: \"\"\" preorder: node, left, right Time : O(n) Space: O(n) \"\"\" self . result = [] self . traverse ( root ) return self . result def traverse ( self , node ): if not node : return self . result . append ( node . val ) self . traverse ( node . left ) self . traverse ( node . right )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0144_binary-tree-preorder-traversal.html","loc":"https://tofucode.com/posts/leetcode_0144_binary-tree-preorder-traversal.html"},{"title":"Leetcode 0145. Binary Tree Postorder Traversal","text":"Question Link : https://leetcode.com/problems/binary-tree-postorder-traversal/ Difficulty: Easy Premium: False Question Given the root of a binary tree, return the postorder traversal of its nodes' values. Example 1: Input: root = [1,null,2,3] Output: [3,2,1] Explanation: Example 2: Input: root = [1,2,3,4,5,null,8,null,null,6,7,9] Output: [4,6,7,5,2,9,8,3,1] Explanation: Example 3: Input: root = [] Output: [] Example 4: Input: root = [1] Output: [1] Constraints: The number of the nodes in the tree is in the range [0, 100]. -100 <= Node.val <= 100 Follow up: Recursive solution is trivial, could you do it iteratively? Solution Postorder traversal Code ''' Leetcode 0145. Binary Tree Postorder Traversal Question Link : https://leetcode.com/problems/binary-tree-postorder-traversal/ Solution Link : https://tofucode.com/posts/leetcode_0145_binary-tree-postorder-traversal.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def postorderTraversal ( self , root : Optional [ TreeNode ]) -> List [ int ]: \"\"\" postorder: left, right, node Time : O(n) Space: O(n) \"\"\" self . result = [] self . traverse ( root ) return self . result def traverse ( self , node ): if not node : return self . traverse ( node . left ) self . traverse ( node . right ) self . result . append ( node . val )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0145_binary-tree-postorder-traversal.html","loc":"https://tofucode.com/posts/leetcode_0145_binary-tree-postorder-traversal.html"},{"title":"Leetcode 0173. Binary Search Tree Iterator","text":"Question Link : https://leetcode.com/problems/binary-search-tree-iterator/ Difficulty: Medium Premium: False Question Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false. int next() Moves the pointer to the right, then returns the number at the pointer. Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. Example 1: Input [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3 bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return False Constraints: The number of nodes in the tree is in the range [1, 105]. 0 <= Node.val <= 106 At most 105 calls will be made to hasNext, and next. Follow up: Could you implement next() and hasNext() to run in average O(1) time and use O(h) memory, where h is the height of the tree? Solution Trivial solution is to use a stack and traverse the whole tree in init Best solution is to use a stack to only always store the left subtree Code ''' Leetcode 0173. Binary Search Tree Iterator Question Link : https://leetcode.com/problems/binary-search-tree-iterator/ Solution Link : https://tofucode.com/posts/leetcode_0173_binary-search-tree-iterator.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class BSTIterator : ''' Use in order traversal to put everything into a stack first Time and space for next: Time : O(1) Space: O(n) ''' def __init__ ( self , root : Optional [ TreeNode ]): self . stack = [] self . idx = 0 self . traverse ( root ) def next ( self ) -> int : result = self . stack [ self . idx ] self . idx += 1 return result def hasNext ( self ) -> bool : return self . idx < len ( self . stack ) def traverse ( self , node ): if not node : return self . traverse ( node . left ) self . stack . append ( node . val ) self . traverse ( node . right ) class BSTIteratorImproved1 : \"\"\" inorder traversal: left, node, right naive: inorder traverse into a stack and move the pointer want to uniify the logic of next and hasNext: From current node: * go left as much as possible * go back to parent or left node ( use a stack ) * go right, and then go left as possible stack: keep track of left node stack - keep going left top of the stack - next smallest element Time : O(h) goAllTheWayLeft() Space: O(h) \"\"\" def __init__ ( self , root : Optional [ TreeNode ]): self . stack = [] self . goAllTheWayLeft ( root ) def next ( self ) -> int : current = self . stack . pop () # next smallest element if current . right : self . goAllTheWayLeft ( current . right ) return current . val def hasNext ( self ) -> bool : return len ( self . stack ) > 0 def goAllTheWayLeft ( self , node ): while node : self . stack . append ( node ) node = node . left","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0173_binary-search-tree-iterator.html","loc":"https://tofucode.com/posts/leetcode_0173_binary-search-tree-iterator.html"},{"title":"Leetcode 0098. Validate Binary Search Tree","text":"Question Link : https://leetcode.com/problems/validate-binary-search-tree/ Difficulty: Medium Premium: False Question Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Example 1: Input: root = [2,1,3] Output: true Example 2: Input: root = [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4. Constraints: The number of nodes in the tree is in the range [1, 104]. -231 <= Node.val <= 231 - 1 Solution Can use recursion but to ensure that the whole sub tree below the current node satisfies the requirement, one would want to pass in a range. Code ''' Leetcode 0098. Validate Binary Search Tree Question Link : https://leetcode.com/problems/validate-binary-search-tree/ Solution Link : https://tofucode.com/posts/leetcode_0098_validate-binary-search-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def isValidBST ( self , root : Optional [ TreeNode ]) -> bool : \"\"\" recursion but with passing down left and right range for every node check: if not in contraint range: return False if not (left < node < right): return False recursion and pass in acceptable range for left and right sub tree Time : O(n) Space: O(n) \"\"\" return self . isValid ( root , - math . inf , math . inf ) def isValid ( self , node : TreeNode , left , right ): if node is None : return True if node . val >= right or node . val <= left : return False if node . left and node . left . val >= node . val : return False if node . right and node . right . val <= node . val : return False return self . isValid ( node . left , left , node . val ) and self . isValid ( node . right , node . val , right ) class SolutionNope1 : def isValidBST ( self , root : Optional [ TreeNode ]) -> bool : \"\"\" recursion: for every node check: left < node < right Nope: This doesn't work when there is a sub tree that might go out of range of the skip node and this would return True eg. 3 does not satisfy that node 5 has all nodes of its right subtree bigger than 5 5 / \\ 4 6 / \\ 3 7 Time : O(n) Space: O(n) \"\"\" if not root : return True if root . left and root . left . val >= root . val : return False if root . right and root . val >= root . right . val : return False return self . isValidBST ( root . left ) and self . isValidBST ( root . right )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0098_validate-binary-search-tree.html","loc":"https://tofucode.com/posts/leetcode_0098_validate-binary-search-tree.html"},{"title":"Leetcode 0501. Find Mode in Binary Search Tree","text":"Question Link : https://leetcode.com/problems/find-mode-in-binary-search-tree/ Difficulty: Easy Premium: False Question Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it. If the tree has more than one mode, return them in any order. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees. Example 1: Input: root = [1,null,2,2] Output: [2] Example 2: Input: root = [0] Output: [0] Constraints: The number of nodes in the tree is in the range [1, 104]. -105 <= Node.val <= 105 Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). Solution Can use in order traversal to go through the tree and use class vars to track the current and max counts. Same ideas can be applied to a iterative dfs. Code ''' Leetcode 0501. Find Mode in Binary Search Tree Question Link : https://leetcode.com/problems/find-mode-in-binary-search-tree/ Solution Link : https://tofucode.com/posts/leetcode_0501_find-mode-in-binary-search-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def findMode ( self , root : Optional [ TreeNode ]) -> List [ int ]: ''' Since this is BST where node - left node or right node can be the same number all the duplicates of the same number are connected. traverse the tree # inorder since the bst is ordered keep track of max count current count and current val result list go through the same number nodes: count == max count: append to result list count < max count: ignore count > max count: renew result list and append, reset count Time : O(n) Space: O(n) ''' self . result = [] self . current = None self . cur_count = 0 self . max_count = 0 self . traverse ( root ) return self . result def traverse ( self , node ): if not node : return self . traverse ( node . left ) # ineorder if node . val == self . current : self . cur_count += 1 else : self . cur_count = 1 self . current = node . val if self . cur_count == self . max_count : self . result . append ( node . val ) elif self . cur_count > self . max_count : self . max_count = self . cur_count self . result = [ node . val ] self . current = node . val self . traverse ( node . right )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0501_find-mode-in-binary-search-tree.html","loc":"https://tofucode.com/posts/leetcode_0501_find-mode-in-binary-search-tree.html"},{"title":"Leetcode 0108. Convert Sorted Array to Binary Search Tree","text":"Question Link : https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ Difficulty: Easy Premium: False Question Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. Example 1: Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted: Example 2: Input: nums = [1,3] Output: [3,1] Explanation: [1,null,3] and [3,1] are both height-balanced BSTs. Constraints: 1 <= nums.length <= 104 -104 <= nums[i] <= 104 nums is sorted in a strictly increasing order. Solution Recursively contruct the tree by creating a node from the middle number and then constructing the left and right sub tree. Code ''' Leetcode 0108. Convert Sorted Array to Binary Search Tree Question Link : https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ Solution Link : https://tofucode.com/posts/leetcode_0108_convert-sorted-array-to-binary-search-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def sortedArrayToBST ( self , nums : List [ int ]) -> Optional [ TreeNode ]: ''' recursively: return is nothing left take the middle and create node make bst out of left / right node.left = left bst node.right = right bst odd length: middle num [0 1 2 3 4] 2 even length: either middle num works [0 1 2 3] 1 - just do left Time : O(n) Space: O(n) ''' return self . createBST ( nums , 0 , len ( nums ) - 1 ) def createBST ( self , nums , left , right ): if right < left : return None mid = ( left + right ) // 2 node = TreeNode ( nums [ mid ]) node . left = self . createBST ( nums , left , mid - 1 ) node . right = self . createBST ( nums , mid + 1 , right ) return node","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0108_convert-sorted-array-to-binary-search-tree.html","loc":"https://tofucode.com/posts/leetcode_0108_convert-sorted-array-to-binary-search-tree.html"},{"title":"Leetcode 0322. Coin Change","text":"Question Link : https://leetcode.com/problems/coin-change/ Difficulty: Medium Premium: False Question You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. Example 1: Input: coins = [1,2,5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1 Example 3: Input: coins = [1], amount = 0 Output: 0 Constraints: 1 <= coins.length <= 12 1 <= coins[i] <= 231 - 1 0 <= amount <= 104 Solution Use a 2d array with all coins to all amounts. Later improve this to a 1d array as you are only checking up and left so the space can be reused. Code ''' Leetcode 0322. Coin Change Question Link : https://leetcode.com/problems/coin-change/ Solution Link : https://tofucode.com/posts/leetcode_0322_coin-change.html ''' class Solution : def coinChange ( self , coins : List [ int ], amount : int ) -> int : \"\"\" coins = [1,2,5], amount = 11 5 + 5 + 1 = 11 result: 3 coins 2d dp: dp[i][j] for coin 0 to coin i: the min count of coins to make up amount j dp size: (3, amount+1) 1 2 3 4 5 6 7 8 9 10 11 1 1 2 3 4 5 6 7 8 9 10 11 2 1 1 2 5 1 coin 2, j amount (pad amount by 1) d[1][1] = 1 # above d[1][2] = 1 # cause just one 2 coin is smaller than d[0][1] d[1][3] = min( d[0][3], # check up and don't take current d[1][3-2] + 1 # check can take current coin, -2 of current coin value ) = 2 # min(don't take current, possible combo + a current coin) dp[i][j] = min(dp[i-1][j], dp[j-coin] + 1) check bounds: i-1 # can't check up for dp for i == 0 j-coin # can start loop at j = coin flatten to 1d dp: (cause we are always only checking left and up) loop through each coin: dp[j] = min(dp[j], dp[j - coin] + 1) Time : O(n * amount) Space: O(n * amount) \"\"\" n = len ( coins ) dp = [[ math . inf ] * ( amount + 1 ) for i in range ( n )] for i in range ( n ): coin = coins [ i ] dp [ i ][ 0 ] = 0 # zero coins for zero amount for j in range ( 1 , amount + 1 ): # check up if possible if i - 1 >= 0 : dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i - 1 ][ j ]) # checl left if possible if j - coin >= 0 : dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i ][ j - coin ] + 1 ) result = dp [ n - 1 ][ amount ] return result if result != math . inf else - 1 class SolutionImproved1 : def coinChange ( self , coins : List [ int ], amount : int ) -> int : \"\"\" Improved Space flatten to 1d dp: (cause we are always only checking left and up) loop through each coin: dp[j] = min(dp[j], dp[j - coin] + 1) Changes: 1. Use a 1d array and only need to set dp[0] = 0 2. Start the inner for loop at coin instead of 1 so j - coin is valid 3. Check dp[amount] for the possible answer Time : O(n * amount) Space: O(amount) \"\"\" n = len ( coins ) dp = [ math . inf ] * ( amount + 1 ) dp [ 0 ] = 0 # zero coins for zero amount for i in range ( n ): coin = coins [ i ] for j in range ( coin , amount + 1 ): dp [ j ] = min ( dp [ j ], dp [ j - coin ] + 1 ) result = dp [ amount ] return result if result != math . inf else - 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0322_coin-change.html","loc":"https://tofucode.com/posts/leetcode_0322_coin-change.html"},{"title":"Leetcode 0088. Merge Sorted Array","text":"Question Link : https://leetcode.com/problems/merge-sorted-array/ Difficulty: Easy Premium: False Question You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. Example 1: Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2: Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3: Input: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints: nums1.length == m + n nums2.length == n 0 <= m, n <= 200 1 <= m + n <= 200 -109 <= nums1[i], nums2[j] <= 109 Follow up: Can you come up with an algorithm that runs in O(m + n) time? Solution Since we'd want to try to not use extra space (per the requirement of doing everything in place in nums1), we can try to start inserting to the back of nums1 - since it is \"clean\" without any data. To do that we use theree pointers, one for each nums array and compare the values there, one for the insert position starting at the back of nums1 Code ''' Leetcode 0088. Merge Sorted Array Question Link : https://leetcode.com/problems/merge-sorted-array/ Solution Link : https://tofucode.com/posts/leetcode_0088_merge-sorted-array.html ''' class Solution : def merge ( self , nums1 : List [ int ], m : int , nums2 : List [ int ], n : int ) -> None : \"\"\" Do not return anything, modify nums1 in-place instead. \"\"\" \"\"\" [1,2,3,0,0,0], m = 3, [2,5,6], n = 3 Output: [1,2,2,3,5,6] two pointers: process largest first - tail to head another pointer for insert position [1,2,3,0,0,0], m = 3, x i [2,5,6], n = 3 y [1,2,3,0,0,0] # start of nums1 # add y and y-- [1,2,3,0,0,6] x i [2,5,6] y # add y and y-- [1,2,3,0,5,6] x i [2,5,6] y # add x and x-- [1,2,3,3,5,6] x i [2,5,6] y # add y and y-- (even though it's equal) [1,2,2,3,5,6] x When we go through all of y first: stop when we go through all of x first: bring remaining of y over to nums1 Time : O(n + m) Space: O(1) \"\"\" x = m - 1 y = n - 1 i = m + n - 1 while x >= 0 and y >= 0 : if nums1 [ x ] <= nums2 [ y ]: nums1 [ i ] = nums2 [ y ] y -= 1 else : nums1 [ i ] = nums1 [ x ] x -= 1 i -= 1 if y < 0 : return # bring remaining of nums2 over while y >= 0 : nums1 [ i ] = nums2 [ y ] y -= 1 i -= 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0088_merge-sorted-array.html","loc":"https://tofucode.com/posts/leetcode_0088_merge-sorted-array.html"},{"title":"Leetcode 0771. Jewels and Stones","text":"Question Link : https://leetcode.com/problems/jewels-and-stones/ Difficulty: Easy Premium: False Question You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels. Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\". Example 1: Input: jewels = \"aA\", stones = \"aAAbbbb\" Output: 3 Example 2: Input: jewels = \"z\", stones = \"ZZ\" Output: 0 Constraints: 1 <= jewels.length, stones.length <= 50 jewels and stones consist of only English letters. All the characters of jewels are unique. Solution Use a set to denote the known jewels so we can check every stone against that Code ''' Leetcode 0771. Jewels and Stones Question Link : https://leetcode.com/problems/jewels-and-stones/ Solution Link : https://tofucode.com/posts/leetcode_0771_jewels-and-stones.html ''' class Solution : def numJewelsInStones ( self , jewels : str , stones : str ) -> int : \"\"\" jewels: \"aA\" -> set(\"aA\") for every stone in stones: check if in set Time : O(n + m) Space: O(n) <- n is length of jewels - consist of only English letters so really O(1) \"\"\" known_jewels = set ([ c for c in jewels ]) result = 0 for c in stones : if c in known_jewels : result += 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0771_jewels-and-stones.html","loc":"https://tofucode.com/posts/leetcode_0771_jewels-and-stones.html"},{"title":"Leetcode 1757. Recyclable and Low Fat Products","text":"Question Link : https://leetcode.com/problems/recyclable-and-low-fat-products/ Difficulty: Easy Premium: False Question Table: Products +-------------+---------+ | Column Name | Type | +-------------+---------+ | product_id | int | | low_fats | enum | | recyclable | enum | +-------------+---------+ product_id is the primary key (column with unique values) for this table. low_fats is an ENUM (category) of type ('Y', 'N') where 'Y' means this product is low fat and 'N' means it is not. recyclable is an ENUM (category) of types ('Y', 'N') where 'Y' means this product is recyclable and 'N' means it is not. Write a solution to find the ids of products that are both low fat and recyclable. Return the result table in any order. The result format is in the following example. Example 1: Input: Products table: +-------------+----------+------------+ | product_id | low_fats | recyclable | +-------------+----------+------------+ | 0 | Y | N | | 1 | Y | Y | | 2 | N | Y | | 3 | Y | Y | | 4 | N | N | +-------------+----------+------------+ Output: +-------------+ | product_id | +-------------+ | 1 | | 3 | +-------------+ Explanation: Only products 1 and 3 are both low fat and recyclable. Solution Select statement with a where Code ''' Leetcode 1757. Recyclable and Low Fat Products Question Link : https://leetcode.com/problems/recyclable-and-low-fat-products/ Solution Link : https://tofucode.com/posts/leetcode_1757_recyclable-and-low-fat-products.html ''' # Write your MySQL query statement below SELECT product_id FROM Products WHERE low_fats = 'Y' AND recyclable = 'Y'","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1757_recyclable-and-low-fat-products.html","loc":"https://tofucode.com/posts/leetcode_1757_recyclable-and-low-fat-products.html"},{"title":"Leetcode 3110. Score of a String","text":"Question Link : https://leetcode.com/problems/score-of-a-string/ Difficulty: Easy Premium: False Question You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters. Return the score of s. Example 1: Input: s = \"hello\" Output: 13 Explanation: The ASCII values of the characters in s are: 'h' = 104, 'e' = 101, 'l' = 108, 'o' = 111. So, the score of s would be |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111| = 3 + 7 + 0 + 3 = 13. Example 2: Input: s = \"zaz\" Output: 50 Explanation: The ASCII values of the characters in s are: 'z' = 122, 'a' = 97. So, the score of s would be |122 - 97| + |97 - 122| = 25 + 25 = 50. Constraints: 2 <= s.length <= 100 s consists only of lowercase English letters. Solution Go through the string and calculate each abs() pair Code ''' Leetcode 3110. Score of a String Question Link : https://leetcode.com/problems/score-of-a-string/ Solution Link : https://tofucode.com/posts/leetcode_3110_score-of-a-string.html ''' class Solution : def scoreOfString ( self , s : str ) -> int : ''' \"hello\" h: 104 | h - e | e: 101 | e - l | l: 108 | l - l | l: 108 | l - o | o: 111 | current - next | Time : O(n) Space: O(1) ''' result = 0 for i in range ( len ( s ) - 1 ): result += abs ( ord ( s [ i ]) - ord ( s [ i + 1 ])) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_3110_score-of-a-string.html","loc":"https://tofucode.com/posts/leetcode_3110_score-of-a-string.html"},{"title":"Leetcode 1046. Last Stone Weight","text":"Question Link : https://leetcode.com/problems/last-stone-weight/ Difficulty: Easy Premium: False Question You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is: If x == y, both stones are destroyed, and If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x. At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0. Example 1: Input: stones = [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone. Example 2: Input: stones = [1] Output: 1 Constraints: 1 <= stones.length <= 30 1 <= stones[i] <= 1000 Solution Use a priority queue and put all weights in with x -1 to have the max up front. In the end don't forget to check for the empty case Code ''' Leetcode 1046. Last Stone Weight Question Link : https://leetcode.com/problems/last-stone-weight/ Solution Link : https://tofucode.com/posts/leetcode_1046_last-stone-weight.html ''' from queue import PriorityQueue class Solution : def lastStoneWeight ( self , stones : List [ int ]) -> int : \"\"\" maintain order : priority queue x -1 to have max in front Time : O(n log n) # get/put is log n Space: O(n) \"\"\" pq = PriorityQueue () for stone in stones : pq . put ( - stone ) while pq . qsize () > 1 : first = - pq . get () second = - pq . get () if first != second : remain = abs ( first - second ) pq . put ( - remain ) # If there are no stones left, return 0 if pq . qsize () == 0 : return 0 return abs ( pq . get ())","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1046_last-stone-weight.html","loc":"https://tofucode.com/posts/leetcode_1046_last-stone-weight.html"},{"title":"Leetcode 1768. Merge Strings Alternately","text":"Question Link : https://leetcode.com/problems/merge-strings-alternately/ Difficulty: Easy Premium: False Question You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string. Return the merged string. Example 1: Input: word1 = \"abc\", word2 = \"pqr\" Output: \"apbqcr\" Explanation: The merged string will be merged as so: word1: a b c word2: p q r merged: a p b q c r Example 2: Input: word1 = \"ab\", word2 = \"pqrs\" Output: \"apbqrs\" Explanation: Notice that as word2 is longer, \"rs\" is appended to the end. word1: a b word2: p q r s merged: a p b q r s Example 3: Input: word1 = \"abcd\", word2 = \"pq\" Output: \"apbqcd\" Explanation: Notice that as word1 is longer, \"cd\" is appended to the end. word1: a b c d word2: p q merged: a p b q c d Constraints: 1 <= word1.length, word2.length <= 100 word1 and word2 consist of lowercase English letters. Solution Use 2 ponters one for each word, and check at the end if there are any left. If try solving this question with setting one word as the shorter one, note that the requirement is that we always need to start with word1. Code ''' Leetcode 1768. Merge Strings Alternately Question Link : https://leetcode.com/problems/merge-strings-alternately/ Solution Link : https://tofucode.com/posts/leetcode_1768_merge-strings-alternately.html ''' class Solution : def mergeAlternately ( self , word1 : str , word2 : str ) -> str : \"\"\" word1 = \"ab\", word2 = \"pqrs\" 2 pointers a p b qrs n total chars Time : O(n) Space: O(n) \"\"\" i = 0 j = 0 result = [] while i < len ( word1 ) and j < len ( word2 ): result . append ( word1 [ i ]) result . append ( word2 [ j ]) i += 1 j += 1 if i < len ( word1 ): result . append ( word1 [ i :]) elif j < len ( word2 ): result . append ( word2 [ i :]) return \"\" . join ( result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1768_merge-strings-alternately.html","loc":"https://tofucode.com/posts/leetcode_1768_merge-strings-alternately.html"},{"title":"Leetcode 1431. Kids With the Greatest Number of Candies","text":"Question Link : https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/ Difficulty: Easy Premium: False Question There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have. Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies. Example 1: Input: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: If you give all extraCandies to: - Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. - Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. - Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. - Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. - Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. Example 2: Input: candies = [4,2,1,1,2], extraCandies = 1 Output: [true,false,false,false,false] Explanation: There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. Example 3: Input: candies = [12,1,12], extraCandies = 10 Output: [true,false,true] Constraints: n == candies.length 2 <= n <= 100 1 <= candies[i] <= 100 1 <= extraCandies <= 50 Solution Follow the instructions and first find the max, check each one if it satisfies the condition. Code ''' Leetcode 1431. Kids With the Greatest Number of Candies Question Link : https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/ Solution Link : https://tofucode.com/posts/leetcode_1431_kids-with-the-greatest-number-of-candies.html ''' class Solution : def kidsWithCandies ( self , candies : List [ int ], extraCandies : int ) -> List [ bool ]: \"\"\" find the max go through and check current + exta >= max Time : O(n) Space: O(n) \"\"\" greatest = max ( candies ) result = [] for candy in candies : if candy + extraCandies >= greatest : result . append ( True ) else : result . append ( False ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1431_kids-with-the-greatest-number-of-candies.html","loc":"https://tofucode.com/posts/leetcode_1431_kids-with-the-greatest-number-of-candies.html"},{"title":"Leetcode 0071. Simplify Path","text":"Question Link : https://leetcode.com/problems/simplify-path/ Difficulty: Medium Premium: False Question Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names. The canonical path should have the following format: The path starts with a single slash '/'. Any two directories are separated by a single slash '/'. The path does not end with a trailing '/'. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..') Return the simplified canonical path. Example 1: Input: path = \"/home/\" Output: \"/home\" Explanation: Note that there is no trailing slash after the last directory name. Example 2: Input: path = \"/../\" Output: \"/\" Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: Input: path = \"/home//foo/\" Output: \"/home/foo\" Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Constraints: 1 <= path.length <= 3000 path consists of English letters, digits, period '.', slash '/' or '_'. path is a valid absolute Unix path. Solution Use a stack, consider the different cases, especially when to continue. Code ''' Leetcode 0071. Simplify Path Question Link : https://leetcode.com/problems/simplify-path/ Solution Link : https://tofucode.com/posts/leetcode_0071_simplify-path.html ''' class Solution : def simplifyPath ( self , path : str ) -> str : \"\"\" split path by / process each part join at the end Time : O(n) Space: O(n) \"\"\" stack = [] parts = path . split ( \"/\" ) for part in parts : if not part or part == \".\" : continue elif part == \"..\" : if stack : stack . pop () else : stack . append ( part ) return \"/\" + \"/\" . join ( stack )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0071_simplify-path.html","loc":"https://tofucode.com/posts/leetcode_0071_simplify-path.html"},{"title":"Leetcode 0133. Clone Graph","text":"Question Link : https://leetcode.com/problems/clone-graph/ Difficulty: Medium Premium: False Question Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. class Node { public int val; public List neighbors; } Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph. Example 1: Input: adjList = [[2,4],[1,3],[2,4],[1,3]] Output: [[2,4],[1,3],[2,4],[1,3]] Explanation: There are 4 nodes in the graph. 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). Example 2: Input: adjList = [[]] Output: [[]] Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors. Example 3: Input: adjList = [] Output: [] Explanation: This an empty graph, it does not have any nodes. Constraints: The number of nodes in the graph is in the range [0, 100]. 1 <= Node.val <= 100 Node.val is unique for each node. There are no repeated edges and no self-loops in the graph. The Graph is connected and all nodes can be visited starting from the given node. Solution First thing to note is that val -> node is unique, so we can store the whole graph with a val -> node dict. Code ''' Leetcode 0133. Clone Graph Question Link : https://leetcode.com/problems/clone-graph/ Solution Link : https://tofucode.com/posts/leetcode_0133_clone-graph.html ''' \"\"\" # Definition for a Node. class Node: def __init__(self, val = 0, neighbors = None): self.val = val self.neighbors = neighbors if neighbors is not None else [] \"\"\" class Solution : def cloneGraph ( self , node : 'Node' ) -> 'Node' : \"\"\" each node's value is the same as the node's index unique mapping value -> node new_graph = {} # the new graph: val to new node dfs/bfs through the graph and record return new_graph[node.val] Time : O(n) Space: O(n) \"\"\" if not node : return node new_graph = {} # the new graph: val to new node seen = set () stack = [ node ] while stack : current = stack . pop () if current in seen : continue seen . add ( current ) # clone the new node new_node = self . clone ( new_graph , current ) # clone the neighbors into new_graph, add to stack for neighbor in current . neighbors : new_nei = self . clone ( new_graph , neighbor ) new_node . neighbors . append ( new_nei ) stack . append ( neighbor ) return new_graph [ node . val ] def clone ( self , new_graph , current ): current_val = current . val new_node = new_graph . get ( current_val , Node ( current_val )) new_graph [ current_val ] = new_node return new_node","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0133_clone-graph.html","loc":"https://tofucode.com/posts/leetcode_0133_clone-graph.html"},{"title":"Leetcode 2390. Removing Stars From a String","text":"Question Link : https://leetcode.com/problems/removing-stars-from-a-string/ Difficulty: Medium Premium: False Question You are given a string s, which contains stars *. In one operation, you can: Choose a star in s. Remove the closest non-star character to its left, as well as remove the star itself. Return the string after all stars have been removed. Note: The input will be generated such that the operation is always possible. It can be shown that the resulting string will always be unique. Example 1: Input: s = \"leet cod*e\" Output: \"lecoe\" Explanation: Performing the removals from left to right: - The closest character to the 1st star is 't' in \"leet cod e\". s becomes \"lee cod e\". - The closest character to the 2nd star is 'e' in \"lee cod e\". s becomes \"lecod e\". - The closest character to the 3rd star is 'd' in \"lecod*e\". s becomes \"lecoe\". There are no more stars, so we return \"lecoe\". Example 2: Input: s = \"erase * \" Output: \"\" Explanation: The entire string is removed, so we return an empty string. Constraints: 1 <= s.length <= 105 s consists of lowercase English letters and stars *. The operation above can be performed on s. Solution Use a stack since it mentions removing to the left. Code ''' Leetcode 2390. Removing Stars From a String Question Link : https://leetcode.com/problems/removing-stars-from-a-string/ Solution Link : https://tofucode.com/posts/leetcode_2390_removing-stars-from-a-string.html ''' class Solution : def removeStars ( self , s : str ) -> str : \"\"\" stack, pop when there is a star Time : O(n) Space: O(n) \"\"\" stack = [] for c in s : if c == \"*\" : stack . pop () else : stack . append ( c ) return \"\" . join ( stack )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2390_removing-stars-from-a-string.html","loc":"https://tofucode.com/posts/leetcode_2390_removing-stars-from-a-string.html"},{"title":"Leetcode 1020. Number of Enclaves","text":"Question Link : https://leetcode.com/problems/number-of-enclaves/ Difficulty: Medium Premium: False Question You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell. A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid. Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves. Example 1: Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary. Example 2: Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation: All 1s are either on the boundary or can reach the boundary. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 500 grid[i][j] is either 0 or 1. Solution Same as the island problems with taking into account for the boundaries. Code ''' Leetcode 1020. Number of Enclaves Question Link : https://leetcode.com/problems/number-of-enclaves/ Solution Link : https://tofucode.com/posts/leetcode_1020_number-of-enclaves.html ''' class Solution : def numEnclaves ( self , grid : List [ List [ int ]]) -> int : \"\"\" sames as https://leetcode.com/problems/number-of-closed-islands/ change land to 1 when adding to result, add the number of cells of the island ime : O(mn) Space: O(mn) \"\"\" rows = len ( grid ) cols = len ( grid [ 0 ]) if rows else 0 seen = set () count = 0 for i in range ( rows ): for j in range ( cols ): if grid [ i ][ j ] == 1 and not ( i , j ) in seen : found , valid = self . dfs ( grid , i , j , rows , cols ) seen = seen | found if valid : count += len ( found ) return count def dfs ( self , grid , i , j , rows , cols ): stack = [( i , j )] seen = set () valid_result = True while stack : current = stack . pop () if current in seen : continue seen . add ( current ) if self . is_boarder ( current , rows , cols ): valid_result = False for offset in [( - 1 , 0 ), ( 1 , 0 ), ( 0 , - 1 ), ( 0 , 1 )]: x = current [ 0 ] + offset [ 0 ] y = current [ 1 ] + offset [ 1 ] if 0 <= x < rows and 0 <= y < cols and grid [ x ][ y ] == 1 : stack . append (( x , y )) return seen , valid_result def is_boarder ( self , current , rows , cols ): i , j = current return i == 0 or i == rows - 1 or j == 0 or j == cols - 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1020_number-of-enclaves.html","loc":"https://tofucode.com/posts/leetcode_1020_number-of-enclaves.html"},{"title":"Leetcode 1254. Number of Closed Islands","text":"Question Link : https://leetcode.com/problems/number-of-closed-islands/ Difficulty: Medium Premium: False Question Given a 2D grid consists of 0s (land) and 1s (water). An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s. Return the number of closed islands. Example 1: Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] Output: 2 Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s). Example 2: Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] Output: 1 Example 3: Input: grid = [[1,1,1,1,1,1,1], [1,0,0,0,0,0,1], [1,0,1,1,1,0,1], [1,0,1,0,1,0,1], [1,0,1,1,1,0,1], [1,0,0,0,0,0,1], [1,1,1,1,1,1,1]] Output: 2 Constraints: 1 <= grid.length, grid[0].length <= 100 0 <= grid[i][j] <=1 Solution This is a slightly modified version of the classic number of island problem. Code ''' Leetcode 1254. Number of Closed Islands Question Link : https://leetcode.com/problems/number-of-closed-islands/ Solution Link : https://tofucode.com/posts/leetcode_1254_number-of-closed-islands.html ''' class Solution : def closedIsland ( self , grid : List [ List [ int ]]) -> int : ''' very similiar as the normal number of islands: https://leetcode.com/problems/number-of-islands/description/ The added difference here is that if an island is at the boarder, we do not count that. so add a is_boarder() check only do count += 1 if the island from the dfs does not have cells on the boarder Time : O(mn) Space: O(mn) ''' rows = len ( grid ) cols = len ( grid [ 0 ]) if rows else 0 seen = set () count = 0 for i in range ( rows ): for j in range ( cols ): if grid [ i ][ j ] == 0 and not ( i , j ) in seen : found , valid = self . dfs ( grid , i , j , rows , cols ) seen = seen | found if valid : count += 1 return count def dfs ( self , grid , i , j , rows , cols ): stack = [( i , j )] seen = set () valid_result = True while stack : current = stack . pop () if current in seen : continue seen . add ( current ) if self . is_boarder ( current , rows , cols ): valid_result = False for offset in [( - 1 , 0 ), ( 1 , 0 ), ( 0 , - 1 ), ( 0 , 1 )]: x = current [ 0 ] + offset [ 0 ] y = current [ 1 ] + offset [ 1 ] if 0 <= x < rows and 0 <= y < cols and grid [ x ][ y ] == 0 : stack . append (( x , y )) return seen , valid_result def is_boarder ( self , current , rows , cols ): i , j = current return i == 0 or i == rows - 1 or j == 0 or j == cols - 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1254_number-of-closed-islands.html","loc":"https://tofucode.com/posts/leetcode_1254_number-of-closed-islands.html"},{"title":"Leetcode 2405. Optimal Partition of String","text":"Question Link : https://leetcode.com/problems/optimal-partition-of-string/ Difficulty: Medium Premium: False Question Given a string s, partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once. Return the minimum number of substrings in such a partition. Note that each character should belong to exactly one substring in a partition. Example 1: Input: s = \"abacaba\" Output: 4 Explanation: Two possible partitions are (\"a\",\"ba\",\"cab\",\"a\") and (\"ab\",\"a\",\"ca\",\"ba\"). It can be shown that 4 is the minimum number of substrings needed. Example 2: Input: s = \"ssssss\" Output: 6 Explanation: The only valid partition is (\"s\",\"s\",\"s\",\"s\",\"s\",\"s\"). Constraints: 1 <= s.length <= 105 s consists of only English lowercase letters. Solution Since each substring can only have one copy of a letter, we can use a set to check that it only appears once for each substring. Code ''' Leetcode 2405. Optimal Partition of String Question Link : https://leetcode.com/problems/optimal-partition-of-string/ Solution Link : https://tofucode.com/posts/leetcode_2405_optimal-partition-of-string.html ''' class Solution : def partitionString ( self , s : str ) -> int : \"\"\" \"abacaba\" ab ac ab a keep a seen set for every substring, can also be an array since max size is 26 Time : O(n) Space: O(1) \"\"\" seen = set () # current substring result = 0 for c in s : if c in seen : seen = set () result += 1 seen . add ( c ) if seen : result += 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2405_optimal-partition-of-string.html","loc":"https://tofucode.com/posts/leetcode_2405_optimal-partition-of-string.html"},{"title":"Leetcode 0881. Boats to Save People","text":"Question Link : https://leetcode.com/problems/boats-to-save-people/ Difficulty: Medium Premium: False Question You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person. Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Constraints: 1 <= people.length <= 5 * 104 1 <= people[i] <= limit <= 3 * 104 Solution First sort the people by weight Since each boat can at most carry 2 people, we can greedily try to pair people from the lightest and heaviest using two pointers Code ''' Leetcode 0881. Boats to Save People Question Link : https://leetcode.com/problems/boats-to-save-people/ Solution Link : https://tofucode.com/posts/leetcode_0881_boats-to-save-people.html ''' class Solution : def numRescueBoats ( self , people : List [ int ], limit : int ) -> int : \"\"\" sort people greedy: pair smallest to largest if possible also run when l == r: the last remaining one in the middle Time : O(n log n) Space: O(n) \"\"\" people = sorted ( people ) result = 0 i = 0 j = len ( people ) - 1 while i <= j : if people [ i ] + people [ j ] <= limit : i += 1 j -= 1 else : j -= 1 result += 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0881_boats-to-save-people.html","loc":"https://tofucode.com/posts/leetcode_0881_boats-to-save-people.html"},{"title":"Leetcode 0005. Longest Palindromic Substring","text":"Question Link : https://leetcode.com/problems/longest-palindromic-substring/ Difficulty: Medium Premium: False Question Given a string s, return the longest palindromic substring in s. Example 1: Input: s = \"babad\" Output: \"bab\" Explanation: \"aba\" is also a valid answer. Example 2: Input: s = \"cbbd\" Output: \"bb\" Constraints: 1 <= s.length <= 1000 s consist of only digits and English letters. Solution For each char expand from the center, make note that we need to check both odd and even cases Code ''' Leetcode 0005. Longest Palindromic Substring Question Link : https://leetcode.com/problems/longest-palindromic-substring/ Solution Link : https://tofucode.com/posts/leetcode_0005_longest-palindromic-substring.html ''' class Solution : def longestPalindrome ( self , s : str ) -> str : ''' expand from center 0 123 b aba d <-b-> aba Time : O(n&#94;2) Space: O(1) ''' result = '' for i in range ( len ( s )): odd = self . expandPalindrome ( s , i , i ) if len ( odd ) > len ( result ): result = odd even = self . expandPalindrome ( s , i , i + 1 ) if len ( even ) > len ( result ): result = even return result def expandPalindrome ( self , s , l , r ): while l >= 0 and r < len ( s ): if s [ l ] != s [ r ]: break l -= 1 r += 1 return s [ l + 1 : r ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0005_longest-palindromic-substring.html","loc":"https://tofucode.com/posts/leetcode_0005_longest-palindromic-substring.html"},{"title":"Leetcode 0009. Palindrome Number","text":"Question Link : https://leetcode.com/problems/palindrome-number/ Difficulty: Easy Premium: False Question Given an integer x, return true if x is a palindrome, and false otherwise. Example 1: Input: x = 121 Output: true Explanation: 121 reads as 121 from left to right and from right to left. Example 2: Input: x = -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: x = 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Constraints: -231 <= x <= 231 - 1 Follow up: Could you solve it without converting the integer to a string? Solution Most apparent solution is to convert to string and check on the string, if doing this without a string conversion: build the palindrome number and then check with the original x. Code ''' Leetcode 0009. Palindrome Number Question Link : https://leetcode.com/problems/palindrome-number/ Solution Link : https://tofucode.com/posts/leetcode_0009_palindrome-number.html ''' class Solution : def isPalindrome ( self , x : int ) -> bool : \"\"\" int -> string 2 pointers, start and end, check each char if anytime no match: return False all match: return True note for odd/even length odd: i == j even: good cheat: return s == s[::-1] Time : O(n) Space: O(n) \"\"\" s = str ( x ) i = 0 j = len ( s ) - 1 while i <= j : if s [ i ] != s [ j ]: return False i += 1 j -= 1 return True class SolutionFollowUp1 : def isPalindrome ( self , x : int ) -> bool : ''' Follow up 1: Could you solve it without converting the integer to a string? Go through the number and calculate the palindrome and compare with original Time : O(n) n number of digits Space: O(1) ''' if x < 0 : return False if x == 0 : return True current = x num = 0 while current > 0 : last_digit = current % 10 current = ( current - last_digit ) / 10 num = num * 10 num += last_digit return num == x","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0009_palindrome-number.html","loc":"https://tofucode.com/posts/leetcode_0009_palindrome-number.html"},{"title":"Leetcode 0011. Container With Most Water","text":"Question Link : https://leetcode.com/problems/container-with-most-water/ Difficulty: Medium Premium: False Question You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container. Example 1: Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example 2: Input: height = [1,1] Output: 1 Constraints: n == height.length 2 <= n <= 105 0 <= height[i] <= 104 Solution Use two pointers from start and end and go towards the middle. Always move the shorter one of the two since that is the bottleneck Code ''' Leetcode 0011. Container With Most Water Question Link : https://leetcode.com/problems/container-with-most-water/ Solution Link : https://tofucode.com/posts/leetcode_0011_container-with-most-water.html ''' class Solution : def maxArea ( self , height : List [ int ]) -> int : ''' Time : O(n) Space: O(1) ''' a = 0 b = len ( height ) - 1 result = 0 while a < b : current = min ( height [ a ], height [ b ]) * ( b - a ) result = max ( result , current ) if height [ a ] < height [ b ]: a += 1 else : b -= 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0011_container-with-most-water.html","loc":"https://tofucode.com/posts/leetcode_0011_container-with-most-water.html"},{"title":"Leetcode 0983. Minimum Cost For Tickets","text":"Question Link : https://leetcode.com/problems/minimum-cost-for-tickets/ Difficulty: Medium Premium: False Question You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365. Train tickets are sold in three different ways: a 1-day pass is sold for costs[0] dollars, a 7-day pass is sold for costs[1] dollars, and a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days. Example 1: Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total, you spent $11 and covered all the days of your travel. Example 2: Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total, you spent $17 and covered all the days of your travel. Constraints: 1 <= days.length <= 365 1 <= days[i] <= 365 days is in strictly increasing order. costs.length == 3 1 <= costs[i] <= 1000 Solution A bit like coin change problem where we would now look back 1,7,30 days. Code ''' Leetcode 0983. Minimum Cost For Tickets Question Link : https://leetcode.com/problems/minimum-cost-for-tickets/ Solution Link : https://tofucode.com/posts/leetcode_0983_minimum-cost-for-tickets.html ''' class Solution : def mincostTickets ( self , days : List [ int ], costs : List [ int ]) -> int : \"\"\" days: 1 - 365 inclusive costs: 1, 7, 30 days days = [1,4,6,7,8,20], costs = [2,7,15] [1,4,6,7,8,20] 1,7777777,1 2 * 2 + 7 = 11 dp = [1 ... 20] inclusive, can use offset of start day init with math.inf loop through all days: if travel day: dp[i] = min( 1 day: dp[i] = dp[i-1] + cost 7 day: dp[i] = dp[i-7] + cost 30 day: dp[i] = dp[i-30] + cost ) else: dp[i] = dp[i-1] # n is constant as there's a 365 limit Time : O(1) Space: O(1) \"\"\" dp = [ math . inf ] * ( days [ - 1 ] + 1 ) dp [ 0 ] = 0 travel_days = set ( days ) for i in range ( 1 , days [ - 1 ] + 1 ): if i in travel_days : buy1 = dp [ i - 1 ] + costs [ 0 ] buy7 = dp [ max ( i - 7 , 0 )] + costs [ 1 ] buy30 = dp [ max ( i - 30 , 0 )] + costs [ 2 ] dp [ i ] = min ( buy1 , buy7 , buy30 ) else : dp [ i ] = dp [ i - 1 ] return dp [ days [ - 1 ]]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0983_minimum-cost-for-tickets.html","loc":"https://tofucode.com/posts/leetcode_0983_minimum-cost-for-tickets.html"},{"title":"Leetcode 0064. Minimum Path Sum","text":"Question Link : https://leetcode.com/problems/minimum-path-sum/ Difficulty: Medium Premium: False Question Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example 1: Input: grid = [[1,3,1],[1,5,1],[4,2,1]] Output: 7 Explanation: Because the path 1 â 3 â 1 â 1 â 1 minimizes the sum. Example 2: Input: grid = [[1,2,3],[4,5,6]] Output: 12 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 200 0 <= grid[i][j] <= 100 Solution Identify that it can only be coming from left or above, and this is very clearly a dp problem, the 2d dp array can also be compressed to a 1d array to save on space since we only care about the last row Code ''' Leetcode 0064. Minimum Path Sum Question Link : https://leetcode.com/problems/minimum-path-sum/ Solution Link : https://tofucode.com/posts/leetcode_0064_minimum-path-sum.html ''' class Solution : def minPathSum ( self , grid : List [ List [ int ]]) -> int : \"\"\" move either down or right, so comes from either up or left, dp(i, j) = grid[i, j] + coming from up or left = grid[i, j] + min( dp(i-1, j), dp(i, j-1) ) return dp[bottom right corner] Time : O(mn) Space: O(mn) \"\"\" rows = len ( grid ) cols = len ( grid [ 0 ]) if rows else 0 dp = [[ 0 ] * cols for i in range ( rows )] for i in range ( rows ): for j in range ( cols ): if i == 0 and j == 0 : dp [ i ][ j ] = grid [ i ][ j ] elif i == 0 : dp [ i ][ j ] = grid [ i ][ j ] + dp [ i ][ j - 1 ] elif j == 0 : dp [ i ][ j ] = grid [ i ][ j ] + dp [ i - 1 ][ j ] else : dp [ i ][ j ] = grid [ i ][ j ] + min ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]) return dp [ rows - 1 ][ cols - 1 ] class SolutionImproved1 : def minPathSum ( self , grid : List [ List [ int ]]) -> int : \"\"\" Compress the dp array to just 1d: we only care about the last row Time : O(mn) Space: O(m) \"\"\" rows = len ( grid ) cols = len ( grid [ 0 ]) if rows else 0 dp = grid [ 0 ][:] # just the last row for i in range ( rows ): for j in range ( cols ): if i == 0 and j == 0 : continue elif i == 0 : dp [ j ] = grid [ i ][ j ] + dp [ j - 1 ] # from left elif j == 0 : dp [ j ] = grid [ i ][ j ] + dp [ j ] # from up, dp[j] is last row's value else : dp [ j ] = grid [ i ][ j ] + min ( dp [ j ], dp [ j - 1 ]) return dp [ cols - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0064_minimum-path-sum.html","loc":"https://tofucode.com/posts/leetcode_0064_minimum-path-sum.html"},{"title":"Leetcode 0079. Word Search","text":"Question Link : https://leetcode.com/problems/word-search/ Difficulty: Medium Premium: False Question Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Example 1: Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\" Output: true Example 2: Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\" Output: true Example 3: Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\" Output: false Constraints: m == board.length n = board[i].length 1 <= m, n <= 6 1 <= word.length <= 15 board and word consists of only lowercase and uppercase English letters. Follow up: Could you use search pruning to make your solution faster with a larger board? Solution Need to use backtracking as we need to know the path. Need to do this recursively as the state of seen needs to be set/unset when traveling to a point in the matrix. Code ''' Leetcode 0079. Word Search Question Link : https://leetcode.com/problems/word-search/ Solution Link : https://tofucode.com/posts/leetcode_0079_word-search.html ''' class Solution : def exist ( self , board : List [ List [ str ]], word : str ) -> bool : \"\"\" backtracking dfs: to keep track of path dfs mark this one as used for each direction: if expolore that == true: return True mark as unused return False Time : O(mn * 3&#94;k) mn is board size, k is length of word, 3 is due to 3 way spilt Space: O(k) k is the length of word to be matched \"\"\" rows = len ( board ) cols = len ( board [ 0 ]) if rows else 0 seen = set () for i in range ( rows ): for j in range ( cols ): if self . dfs ( board , rows , cols , i , j , seen , word ): return True return False def dfs ( self , board , rows , cols , i , j , seen , word ): if not word : return True if board [ i ][ j ] != word [ 0 ]: return False if word [ 1 :] == '' : return True seen . add (( i , j )) for offset in [( 1 , 0 ), ( - 1 , 0 ), ( 0 , 1 ), ( 0 , - 1 )]: x = i + offset [ 0 ] y = j + offset [ 1 ] if 0 <= x < rows and 0 <= y < cols : if ( x , y ) not in seen : if self . dfs ( board , rows , cols , x , y , seen , word [ 1 :]): return True seen . remove (( i , j )) return False","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0079_word-search.html","loc":"https://tofucode.com/posts/leetcode_0079_word-search.html"},{"title":"Leetcode 0212. Word Search II","text":"Question Link : https://leetcode.com/problems/word-search-ii/ Difficulty: Hard Premium: False Question Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example 1: Input: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"] Output: [\"eat\",\"oath\"] Example 2: Input: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"] Output: [] Constraints: m == board.length n == board[i].length 1 <= m, n <= 12 board[i][j] is a lowercase English letter. 1 <= words.length <= 3 * 104 1 <= words[i].length <= 10 words[i] consists of lowercase English letters. All the strings of words are unique. Solution Intuition is to do the same as the Word Search problem, but time would be multiplied by number of words to search for. Here the best way is to first use all the words to build a trie, and run backtracking with that trie. Code ''' Leetcode 0212. Word Search II Question Link : https://leetcode.com/problems/word-search-ii/ Solution Link : https://tofucode.com/posts/leetcode_0212_word-search-ii.html ''' class Solution : def findWords ( self , board : List [ List [ str ]], words : List [ str ]) -> List [ str ]: \"\"\" We build a Trie, and while doing backtracking, try to match against the trie. Trie + Word Search Trie: https://leetcode.com/problems/implement-trie-prefix-tree/ Word Search: https://leetcode.com/problems/word-search/ Time : : O(mn * 3&#94;k) mn is board size, k is length of word, 3 is due to 3 way spilt Space: O(k) total k letters in the dictionary \"\"\" trie = Trie () for word in words : trie . insert ( word ) rows = len ( board ) cols = len ( board [ 0 ]) if rows else 0 seen = set () # or can be subed with: board[i][j] = \"#\" self . result = [] for i in range ( rows ): for j in range ( cols ): letter = board [ i ][ j ] if letter in trie . root . children : self . backtracking ( board , rows , cols , i , j , seen , trie . root . children [ letter ]) return self . result def backtracking ( self , board , rows , cols , i , j , seen , node ): node_letter = board [ i ][ j ] # check current char if board [ i ][ j ] != node . c : return # check if leaf and matched the whole word, null out node.original to avoid dups if node . is_leaf and node . original : self . result . append ( node . original ) node . original = None seen . add (( i , j )) # board[i][j] = \"#\" for offset in [( 1 , 0 ), ( - 1 , 0 ), ( 0 , 1 ), ( 0 , - 1 )]: x = i + offset [ 0 ] y = j + offset [ 1 ] if 0 <= x < rows and 0 <= y < cols : if ( x , y ) not in seen : letter = board [ x ][ y ] if letter in node . children : self . backtracking ( board , rows , cols , x , y , seen , node . children [ letter ]) seen . remove (( i , j )) # board[i][j] = node_letter class TrieNode : def __init__ ( self , c ): self . c = c self . children = {} # char -> TrieNode self . is_leaf = False self . original = None class Trie : def __init__ ( self ): self . root = TrieNode ( '' ) def insert ( self , word : str ) -> None : current = self . root for c in word : if not c in current . children : current . children [ c ] = TrieNode ( c ) current = current . children [ c ] current . is_leaf = True current . original = word","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0212_word-search-ii.html","loc":"https://tofucode.com/posts/leetcode_0212_word-search-ii.html"},{"title":"Leetcode 1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"Question Link : https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/ Difficulty: Medium Premium: False Question There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow. Roads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi. This year, there will be a big event in the capital (city 0), and many people want to travel to this city. Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed. It's guaranteed that each city can reach city 0 after reorder. Example 1: Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]] Output: 3 Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital). Example 2: Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]] Output: 2 Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital). Example 3: Input: n = 3, connections = [[1,0],[2,0]] Output: 0 Constraints: 2 <= n <= 5 * 104 connections.length == n - 1 connections[i].length == 2 0 <= ai, bi <= n - 1 ai != bi Solution Solution is to start at city zero and dfs or bfs outwards to try to traverse the whole tree, to do this we map the connections to bi-directional edges, and how many traversals use the actual direction of the edges, those are the ones that need to be flipped. Code ''' Leetcode 1466. Reorder Routes to Make All Paths Lead to the City Zero Question Link : https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/ Solution Link : https://tofucode.com/posts/leetcode_1466_reorder-routes-to-make-all-paths-lead-to-the-city-zero.html ''' class Solution : def minReorder ( self , n : int , connections : List [ List [ int ]]) -> int : \"\"\" Try dfs/bfs while mimicing bidirectional edges, check if a flip was needed 1. build mapping: node -> [(other nodes, direction)] see this as bidrectional 2. dfs from 0 and try to reach all nodes if actual direction in connections: need to flip this Time : O(n) n nodes m edges where m is n-1 Space: O(n) \"\"\" mapping = defaultdict ( set ) # node -> set(other nodes) for x , y in connections : mapping [ x ] . add (( y , True )) # actual direction mapping [ y ] . add (( x , False )) # reverse direction stack = [ 0 ] flip = 0 seen = set () while stack : current = stack . pop () for other , actual_direction in mapping [ current ]: if other in seen : continue seen . add ( current ) stack . append ( other ) if actual_direction : flip += 1 return flip","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1466_reorder-routes-to-make-all-paths-lead-to-the-city-zero.html","loc":"https://tofucode.com/posts/leetcode_1466_reorder-routes-to-make-all-paths-lead-to-the-city-zero.html"},{"title":"Leetcode 2492. Minimum Score of a Path Between Two Cities","text":"Question Link : https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/ Difficulty: Medium Premium: False Question You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected. The score of a path between two cities is defined as the minimum distance of a road in this path. Return the minimum possible score of a path between cities 1 and n. Note: A path is a sequence of roads between two cities. It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path. The test cases are generated such that there is at least one path between 1 and n. Example 1: Input: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]] Output: 5 Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5. It can be shown that no other path has less score. Example 2: Input: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]] Output: 2 Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2. Constraints: 2 <= n <= 105 1 <= roads.length <= 105 roads[i].length == 3 1 <= ai, bi <= n ai != bi 1 <= distancei <= 104 There are no repeated edges. There is at least one path between 1 and n. Solution First thought is to use dfs, note the edages are bi-directional so using a defaultdict makes things easier. This can also be done with union find since we are really just looking for the min score for everything that is also connected to 1 and n. Code ''' Leetcode 2492. Minimum Score of a Path Between Two Cities Question Link : https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/ Solution Link : https://tofucode.com/posts/leetcode_2492_minimum-score-of-a-path-between-two-cities.html ''' class Solution : def minScore ( self , n : int , roads : List [ List [ int ]]) -> int : \"\"\" The cities graph is not necessarily connected. edges: bi-directional 1 -> n any road that is connected - find the min dfs from 1, search the whole graph. n nodes m edges Time : O(n+m) Space: O(n+m) \"\"\" graph = defaultdict ( dict ) # nested dict: node->{ other node -> score } for x , y , score in roads : graph [ x ][ y ] = graph [ y ][ x ] = score result = math . inf stack = [ 1 ] seen = set () while stack : current = stack . pop () if current in seen : continue seen . add ( current ) for other_node , score in graph [ current ] . items (): stack . append ( other_node ) result = min ( score , result ) return result class SolutionAlternative1 : def minScore ( self , n : int , roads : List [ List [ int ]]) -> int : \"\"\" Union find 1. Union all linked roads based on roads list 2. Go through all roads again, if it's linked to 1, min on that and result n nodes m edges Time : O(n+m) Space: O(n) \"\"\" uf = UnionFind () for x , y , score in roads : uf . union ( x , y ) result = math . inf for x , y , score in roads : if ( uf . find ( 1 ) == uf . find ( x )): result = min ( result , score ) return result class UnionFind : def __init__ ( self ): self . nodes = {} def union ( self , x , y ): # setdefault: only set x -> x if it's not there self . nodes . setdefault ( x , x ) self . nodes . setdefault ( y , y ) rx = self . find ( x ) ry = self . find ( y ) self . nodes [ rx ] = ry def find ( self , x ): self . nodes . setdefault ( x , x ) if x != self . nodes [ x ]: self . nodes [ x ] = self . find ( self . nodes [ x ]) return self . nodes [ x ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2492_minimum-score-of-a-path-between-two-cities.html","loc":"https://tofucode.com/posts/leetcode_2492_minimum-score-of-a-path-between-two-cities.html"},{"title":"Leetcode 2348. Number of Zero-Filled Subarrays","text":"Question Link : https://leetcode.com/problems/number-of-zero-filled-subarrays/ Difficulty: Medium Premium: False Question Given an integer array nums, return the number of subarrays filled with 0. A subarray is a contiguous non-empty sequence of elements within an array. Example 1: Input: nums = [1,3,0,0,2,0,0,4] Output: 6 Explanation: There are 4 occurrences of [0] as a subarray. There are 2 occurrences of [0,0] as a subarray. There is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6. Example 2: Input: nums = [0,0,0,2,0,0] Output: 9 Explanation: There are 5 occurrences of [0] as a subarray. There are 3 occurrences of [0,0] as a subarray. There is 1 occurrence of [0,0,0] as a subarray. There is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9. Example 3: Input: nums = [2,10,2019] Output: 0 Explanation: There is no subarray filled with 0. Therefore, we return 0. Constraints: 1 <= nums.length <= 105 -109 <= nums[i] <= 109 Solution Identify that this can be solved with progression sum fomular with the need to check ending subarray of zeros. For the improved version, we can actually just keep adding the count per loop which would give the same resulting sum. Code ''' Leetcode 2348. Number of Zero-Filled Subarrays Question Link : https://leetcode.com/problems/number-of-zero-filled-subarrays/ Solution Link : https://tofucode.com/posts/leetcode_2348_number-of-zero-filled-subarrays.html ''' class Solution : def zeroFilledSubarray ( self , nums : List [ int ]) -> int : \"\"\" [0,0,0,2,0,0] zeros: 3 2 1 sum 0,0,0 1 2 3 (1+3) * 3 // 2 = 6 0,0 0 1 2 (1+2) * 2 // 2 = 3 just go through once: count continuous zeros calculate sum addto total Time : O(n) Space: O(1) \"\"\" result = 0 count = 0 for num in nums : if num == 0 : count += 1 else : result += self . calculate ( count ) count = 0 # check at the end result += self . calculate ( count ) return result def calculate ( self , count ): return ( 1 + count ) * count // 2 class SolutionImproved1 : def zeroFilledSubarray ( self , nums : List [ int ]) -> int : \"\"\" [0,0,0,2,0,0] zeros: 3 2 1 sum 0,0,0 1 2 3 1 + 2 + 3 0,0 0 1 2 1 + 2 Time : O(n) Space: O(1) \"\"\" result = 0 count = 0 for num in nums : if num == 0 : count += 1 else : count = 0 result += count return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2348_number-of-zero-filled-subarrays.html","loc":"https://tofucode.com/posts/leetcode_2348_number-of-zero-filled-subarrays.html"},{"title":"Leetcode 0605. Can Place Flowers","text":"Question Link : https://leetcode.com/problems/can-place-flowers/ Difficulty: Easy Premium: False Question You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots. Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule. Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: true Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: false Constraints: 1 <= flowerbed.length <= 2 * 104 flowerbed[i] is 0 or 1. There are no two adjacent flowers in flowerbed. 0 <= n <= flowerbed.length Solution Go through the array and check each spot with respect to i+1 and i-1. Take note on the start and end. Code ''' Leetcode 0605. Can Place Flowers Question Link : https://leetcode.com/problems/can-place-flowers/ Solution Link : https://tofucode.com/posts/leetcode_0605_can-place-flowers.html ''' class Solution : def canPlaceFlowers ( self , flowerbed : List [ int ], n : int ) -> bool : \"\"\" go through and check and plant [1,0,0,0,1] for loop, find 0: check i-1 and i+1 are also zero check first and last Time : O(n) Space: O(1) \"\"\" if n == 0 : return True count = n for i in range ( len ( flowerbed )): if flowerbed [ i ] == 0 : if self . checkBeforeAfteer ( flowerbed , i ): count -= 1 flowerbed [ i ] = 1 if count == 0 : return True return False def checkBeforeAfteer ( self , flowerbed , i ): \"\"\" Before either at the start or i-1 is 0 AND After either at the end or i+1 is 0 \"\"\" return ( i == 0 or flowerbed [ i - 1 ] == 0 ) and ( i == len ( flowerbed ) - 1 or flowerbed [ i + 1 ] == 0 )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0605_can-place-flowers.html","loc":"https://tofucode.com/posts/leetcode_0605_can-place-flowers.html"},{"title":"Leetcode 1472. Design Browser History","text":"Question Link : https://leetcode.com/problems/design-browser-history/ Difficulty: Medium Premium: False Question You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps. Implement the BrowserHistory class: BrowserHistory(string homepage) Initializes the object with the homepage of the browser. void visit(string url) Visits url from the current page. It clears up all the forward history. string back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. Return the current url after moving back in history at most steps. string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. Return the current url after forwarding in history at most steps. Example: Input: [\"BrowserHistory\",\"visit\",\"visit\",\"visit\",\"back\",\"back\",\"forward\",\"visit\",\"forward\",\"back\",\"back\"] [[\"leetcode.com\"],[\"google.com\"],[\"facebook.com\"],[\"youtube.com\"],[1],[1],[1],[\"linkedin.com\"],[2],[2],[7]] Output: [null,null,null,null,\"facebook.com\",\"google.com\",\"facebook.com\",null,\"linkedin.com\",\"google.com\",\"leetcode.com\"] Explanation: BrowserHistory browserHistory = new BrowserHistory(\"leetcode.com\"); browserHistory.visit(\"google.com\"); // You are in \"leetcode.com\". Visit \"google.com\" browserHistory.visit(\"facebook.com\"); // You are in \"google.com\". Visit \"facebook.com\" browserHistory.visit(\"youtube.com\"); // You are in \"facebook.com\". Visit \"youtube.com\" browserHistory.back(1); // You are in \"youtube.com\", move back to \"facebook.com\" return \"facebook.com\" browserHistory.back(1); // You are in \"facebook.com\", move back to \"google.com\" return \"google.com\" browserHistory.forward(1); // You are in \"google.com\", move forward to \"facebook.com\" return \"facebook.com\" browserHistory.visit(\"linkedin.com\"); // You are in \"facebook.com\". Visit \"linkedin.com\" browserHistory.forward(2); // You are in \"linkedin.com\", you cannot move forward any steps. browserHistory.back(2); // You are in \"linkedin.com\", move back two steps to \"facebook.com\" then to \"google.com\". return \"google.com\" browserHistory.back(7); // You are in \"google.com\", you can move back only one step to \"leetcode.com\". return \"leetcode.com\" Constraints: 1 <= homepage.length <= 20 1 <= url.length <= 20 1 <= steps <= 100 homepage and url consist of '.' or lower case English letters. At most 5000 calls will be made to visit, back, and forward. Solution Use either 1 stack with a pointer or separate back and forward stack with current. Code ''' Leetcode 1472. Design Browser History Question Link : https://leetcode.com/problems/design-browser-history/ Solution Link : https://tofucode.com/posts/leetcode_1472_design-browser-history.html ''' class BrowserHistory : ''' Use a single stack, with a current pointer. visit: add url and clear stack to the right n visits Time : O(1) Space: O(n) ''' def __init__ ( self , homepage : str ): self . stack = [ homepage ] self . p = 0 def visit ( self , url : str ) -> None : self . p += 1 if self . p == len ( self . stack ): self . stack . append ( url ) else : self . stack [ self . p ] = url self . stack = self . stack [: self . p + 1 ] def back ( self , steps : int ) -> str : self . p = max ( self . p - steps , 0 ) return self . stack [ self . p ] def forward ( self , steps : int ) -> str : self . p = min ( self . p + steps , len ( self . stack ) - 1 ) return self . stack [ self . p ] class BrowserHistoryAlternative1 : ''' Easier to think about this first, but actually more complicated to write out 2 stack: back_stack: forward_stacK: [\"leetcode.com\"],[\"google.com\"],[\"facebook.com\"],[\"youtube.com\"] hompage + visit: l, g, f, y back, current, forward [l, g, f] y [] back 1: [l, g] f [y] back 1: [l] g [y, f] forward: [l, g] f [y] visit: current -> back_stack url -> current forward_stack = [] back: current -> forward_stack back_stack -> current forward: current -> back_stack forward_stack -> current n visits Time : O(1) Space: O(n) ''' def __init__ ( self , homepage : str ): self . back_stack = [] self . forward_stack = [] self . current = homepage def visit ( self , url : str ) -> None : self . back_stack . append ( self . current ) self . current = url self . forward_stack = [] def back ( self , steps : int ) -> str : step = steps while self . back_stack and step > 0 : self . forward_stack . append ( self . current ) self . current = self . back_stack . pop () step -= 1 return self . current def forward ( self , steps : int ) -> str : step = steps while self . forward_stack and step > 0 : self . back_stack . append ( self . current ) self . current = self . forward_stack . pop () step -= 1 return self . current # Your BrowserHistory object will be instantiated and called as such: # obj = BrowserHistory(homepage) # obj.visit(url) # param_2 = obj.back(steps) # param_3 = obj.forward(steps)","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1472_design-browser-history.html","loc":"https://tofucode.com/posts/leetcode_1472_design-browser-history.html"},{"title":"Leetcode 0208. Implement Trie (Prefix Tree)","text":"Question Link : https://leetcode.com/problems/implement-trie-prefix-tree/ Difficulty: Medium Premium: False Question A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise. Example 1: Input [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"] [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]] Output [null, null, true, false, true, null, true] Explanation Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // return True trie.search(\"app\"); // return False trie.startsWith(\"app\"); // return True trie.insert(\"app\"); trie.search(\"app\"); // return True Constraints: 1 <= word.length, prefix.length <= 2000 word and prefix consist only of lowercase English letters. At most 3 * 104 calls in total will be made to insert, search, and startsWith. Solution Standard trie. Note that search() and startsWith() can be combined to common code. Code ''' Leetcode 0208. Implement Trie (Prefix Tree) Question Link : https://leetcode.com/problems/implement-trie-prefix-tree/ Solution Link : https://tofucode.com/posts/leetcode_0208_implement-trie-prefix-tree.html ''' class TrieNode : def __init__ ( self , c ): self . c = c self . children = {} # char -> TrieNode self . is_leaf = False class Trie : ''' node: children a : {p -> TrieNode(p1)} p1: {p -> TrieNode(p2)} p2: {l -> TrieNode(l)} l: {e -> TrieNode(e, is_leaf)} appl n words, m as longest word Time : O(m) Space: O(nm) ''' def __init__ ( self ): self . root = TrieNode ( '' ) def insert ( self , word : str ) -> None : current = self . root for c in word : if not c in current . children : current . children [ c ] = TrieNode ( c ) current = current . children [ c ] current . is_leaf = True def search ( self , word : str ) -> bool : ''' trace the tree for word, and must end with a leaf node ''' return self . checkWord ( word , True ) def startsWith ( self , prefix : str ) -> bool : ''' trace the tree for word, no need for leaf node ''' return self . checkWord ( prefix , False ) def checkWord ( self , word : str , check_is_leaf : bool ) -> bool : current = self . root for c in word : if c in current . children : current = current . children [ c ] else : return False if check_is_leaf : return current . is_leaf return True # Your Trie object will be instantiated and called as such: # obj = Trie() # obj.insert(word) # param_2 = obj.search(word) # param_3 = obj.startsWith(prefix)","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0208_implement-trie-prefix-tree.html","loc":"https://tofucode.com/posts/leetcode_0208_implement-trie-prefix-tree.html"},{"title":"Leetcode 0106. Construct Binary Tree from Inorder and Postorder Traversal","text":"Question Link : https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ Difficulty: Medium Premium: False Question Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree. Example 1: Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] Output: [3,9,20,null,null,15,7] Example 2: Input: inorder = [-1], postorder = [-1] Output: [-1] Constraints: 1 <= inorder.length <= 3000 postorder.length == inorder.length -3000 <= inorder[i], postorder[i] <= 3000 inorder and postorder consist of unique values. Each value of postorder also appears in inorder. inorder is guaranteed to be the inorder traversal of the tree. postorder is guaranteed to be the postorder traversal of the tree. Solution Start by looking at the given inorder and postorder arrays and we can find that postorder gives the root at the end, so if we keep poping the last of postorder, that node can be used as the node at each step of the recursion. Then look at where that root number is in the inorder array, we can see that the root can be seen as splitting the left and right branches within inorder. Improvements can be made by using a map for num -> index for inorder, and use low and high bounds instead of acutally splicing the array. Code ''' Leetcode 0106. Construct Binary Tree from Inorder and Postorder Traversal Question Link : https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ Solution Link : https://tofucode.com/posts/leetcode_0106_construct-binary-tree-from-inorder-and-postorder-traversal.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def buildTree ( self , inorder : List [ int ], postorder : List [ int ]) -> Optional [ TreeNode ]: ''' inorder: left, root, right postorder: left, right, root recursively: [9,15,7,20,3] node: 3, 20, 7, 15, 9 - keep going right at 3, split inorder left: [9] right: [15, 20, 7] Time : O(n&#94;2) index() and array slicing is both O(n) Space: O(n&#94;2) ''' if len ( inorder ) == 0 : return None num = postorder . pop () idx = inorder . index ( num ) node = TreeNode ( num ) node . right = self . buildTree ( inorder [ idx + 1 :], postorder ) node . left = self . buildTree ( inorder [: idx ], postorder ) return node","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0106_construct-binary-tree-from-inorder-and-postorder-traversal.html","loc":"https://tofucode.com/posts/leetcode_0106_construct-binary-tree-from-inorder-and-postorder-traversal.html"},{"title":"Leetcode 0460. LFU Cache","text":"Question Link : https://leetcode.com/problems/lfu-cache/ Difficulty: Hard Premium: False Question Design and implement a data structure for a Least Frequently Used (LFU) cache. Implement the LFUCache class: LFUCache(int capacity) Initializes the object with the capacity of the data structure. int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1. void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated. To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key. When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it. The functions get and put must each run in O(1) average time complexity. Example 1: Input [\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, 3, null, -1, 3, 4] Explanation // cnt(x) = the use counter for key x // cache=[] will show the last used order for tiebreakers (leftmost element is most recent) LFUCache lfu = new LFUCache(2); lfu.put(1, 1); // cache=[1,_], cnt(1)=1 lfu.put(2, 2); // cache=[2,1], cnt(2)=1, cnt(1)=1 lfu.get(1); // return 1 // cache=[1,2], cnt(2)=1, cnt(1)=2 lfu.put(3, 3); // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2. // cache=[3,1], cnt(3)=1, cnt(1)=2 lfu.get(2); // return -1 (not found) lfu.get(3); // return 3 // cache=[3,1], cnt(3)=2, cnt(1)=2 lfu.put(4, 4); // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1. // cache=[4,3], cnt(4)=1, cnt(3)=2 lfu.get(1); // return -1 (not found) lfu.get(3); // return 3 // cache=[3,4], cnt(4)=1, cnt(3)=3 lfu.get(4); // return 4 // cache=[4,3], cnt(4)=2, cnt(3)=3 Constraints: 1 <= capacity <= 104 0 <= key <= 105 0 <= value <= 109 At most 2 * 105 calls will be made to get and put. Solution The core is 2 dicts: one for key to value and freq mapping, and one for freq to keys mapping. Notes: Min_freq can first be done by doing a min() on all the frequencies, marking a variable min_freq can then be done in a later iteration Because freq dict maps to a number of keys, deleting a key within this could be O(n) in worst case, in Improved1 we can use a orderedDict to mitigate this since python does not have a orderedSet, but it is essentially for constant time removal Code ''' Leetcode 0460. LFU Cache Question Link : https://leetcode.com/problems/lfu-cache/ Solution Link : https://tofucode.com/posts/leetcode_0460_lfu-cache.html ''' class LFUCache : ''' frequency: a use counter is maintained for each key in the cache. removing The key with the smallest use counter is the least frequently used key. f+1 for get/put dict: key -> (value, freq) freq -> [keys] # all keys with this freq need keep track of the smallest freq: min_freq keep track of size: which is size of key dict for get/put Time : O(n) # worst case. cause of remove(key) in updateFreq Space: O(n) ''' def __init__ ( self , capacity : int ): self . store = {} # key -> (value, freq) self . freq = {} # freq -> [keys] # all keys with this freq self . min_freq = 1 self . capacity = capacity def get ( self , key : int ) -> int : if not key in self . store : return - 1 v , _f = self . store [ key ] self . updateFreq ( key ) return v def put ( self , key : int , value : int ) -> None : if self . capacity == 0 : return if key in self . store : self . updateFreq ( key ) v , f = self . store [ key ] self . store [ key ] = ( value , f ) else : if len ( self . store ) == self . capacity : # evict lfu first min_key = self . freq [ self . min_freq ] . pop ( 0 ) del self . store [ min_key ] self . store [ key ] = ( value , 1 ) self . freq [ 1 ] = self . freq . get ( 1 , []) + [ key ] self . min_freq = 1 def updateFreq ( self , key ): ''' update both dicts of key's frequency, update min_freq ''' v , f = self . store [ key ] # update self.store self . store [ key ] = ( v , f + 1 ) # update self.freq key_list = self . freq [ f ] key_list . remove ( key ) # O(n) self . freq [ f + 1 ] = self . freq . get ( f + 1 , []) + [ key ] # update min_freq if self . min_freq == f and len ( key_list ) == 0 : self . min_freq = f + 1 # Your LFUCache object will be instantiated and called as such: # obj = LFUCache(capacity) # param_1 = obj.get(key) # obj.put(key,value) class LFUCacheImproved1 : ''' Improvement over LFUCache: Use orderedDict (really as a set) and defaultdict, this makes updateFreq to O(1) self.freq = defaultdict(OrderedDict) # freq -> {keys} each freq would map to a set of keys, where deleting a key would be O(1) Changes: 1. self.freq = defaultdict(OrderedDict) really a OrderedSet 2. adding to self.freq change to, the 1 doesn't matter: self.freq[1][key] = 1 3. evicting now with: popitem(last=False) for get/put Time : O(1) Space: O(n) ''' def __init__ ( self , capacity : int ): self . store = {} # key -> (value, freq) self . freq = defaultdict ( OrderedDict ) # freq -> {keys} # all keys with this freq self . min_freq = 1 self . capacity = capacity def get ( self , key : int ) -> int : if not key in self . store : return - 1 v , _f = self . store [ key ] self . updateFreq ( key ) return v def put ( self , key : int , value : int ) -> None : if self . capacity == 0 : return if key in self . store : self . updateFreq ( key ) v , f = self . store [ key ] self . store [ key ] = ( value , f ) else : if len ( self . store ) == self . capacity : # evict lfu first min_key , _v = self . freq [ self . min_freq ] . popitem ( last = False ) del self . store [ min_key ] self . store [ key ] = ( value , 1 ) self . freq [ 1 ][ key ] = 1 self . min_freq = 1 def updateFreq ( self , key ): ''' update both dicts of key's frequency, update min_freq ''' v , f = self . store [ key ] # update self.store self . store [ key ] = ( v , f + 1 ) # update self.freq del self . freq [ f ][ key ] self . freq [ f + 1 ][ key ] = 1 # update min_freq if self . min_freq == f and len ( self . freq [ f ]) == 0 : self . min_freq = f + 1 class CacheNode : def __init__ ( self , key = None , val = None ): self . key = key self . val = val self . freq = 1 self . next = None self . prev = None class DoubleLinkedList : ''' all CacheNodes of a certain frequency, add to the end, pop first''' def __init__ ( self ): self . head = CacheNode () self . tail = CacheNode () self . link ( self . head , self . tail ) def append ( self , node ): last = self . tail . prev self . link ( last , node ) self . link ( node , self . tail ) def popFirst ( self ): if self . isEmpty (): return None first = self . head . next self . unlink ( first ) return first def link ( self , a , b ): a . next = b b . prev = a def unlink ( self , node ): if node . prev and node . next : node . prev . next = node . next node . next . prev = node . prev def isEmpty ( self ): return self . head . next == self . tail class LFUCacheAlternative1 : ''' Package the code from LRU as a double linked list, and for previous self.freq use freq -> DoubleLinkedList lru: https://leetcode.com/problems/lru-cache/description/ for get/put Time : O(1) Space: O(n) ''' def __init__ ( self , capacity : int ): self . nodes = {} # key -> node self . flist = {} # freq -> DoubleLinkedList self . min_freq = 1 self . capacity = capacity def get ( self , key : int ) -> int : node = self . nodes . get ( key , None ) if not node : return - 1 self . updateNode ( node ) return node . val def put ( self , key : int , value : int ) -> None : if self . capacity == 0 : return node = self . nodes . get ( key , None ) if node : node . val = value self . updateNode ( node ) else : if len ( self . nodes ) == self . capacity : # evict n = self . flist [ self . min_freq ] . popFirst () del self . nodes [ n . key ] n = CacheNode ( key , value ) self . nodes [ key ] = n l = self . flist . get ( 1 , DoubleLinkedList ()) l . append ( n ) self . flist [ 1 ] = l self . min_freq = 1 def updateNode ( self , node ): ''' remove node from current list if there, update, and add to new list''' f = node . freq # update node node . freq = f + 1 # update self.flist self . flist . get ( f ) . unlink ( node ) l = self . flist . get ( node . freq , DoubleLinkedList ()) l . append ( node ) self . flist [ node . freq ] = l # update min_freq if self . min_freq == f and self . flist [ f ] . isEmpty (): self . min_freq = f + 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0460_lfu-cache.html","loc":"https://tofucode.com/posts/leetcode_0460_lfu-cache.html"},{"title":"Leetcode 0129. Sum Root to Leaf Numbers","text":"Question Link : https://leetcode.com/problems/sum-root-to-leaf-numbers/ Difficulty: Medium Premium: False Question You are given the root of a binary tree containing digits from 0 to 9 only. Each root-to-leaf path in the tree represents a number. For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123. Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer. A leaf node is a node with no children. Example 1: Input: root = [1,2,3] Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: root = [4,9,0,5,1] Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. Constraints: The number of nodes in the tree is in the range [1, 1000]. 0 <= Node.val <= 9 The depth of the tree will not exceed 10. Solution Start from the root, and recursively go down, use a string or an array to keep track of the seen values down the curernt path, when we hit a leaf node, now return that as the number of the current path back up the stack. Code ''' Leetcode 0129. Sum Root to Leaf Numbers Question Link : https://leetcode.com/problems/sum-root-to-leaf-numbers/ Solution Link : https://tofucode.com/posts/leetcode_0129_sum-root-to-leaf-numbers.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def sumNumbers ( self , root : Optional [ TreeNode ]) -> int : ''' all root -> leaf -- sum up traverse and record path: when is leaf, add to total Time : O(h) Space: O(n) ''' return self . traverse ( root , '' ) def traverse ( self , node , path ): if not node : return 0 current = path + str ( node . val ) if not node . left and not node . right : return int ( current ) return self . traverse ( node . left , current ) + self . traverse ( node . right , current )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0129_sum-root-to-leaf-numbers.html","loc":"https://tofucode.com/posts/leetcode_0129_sum-root-to-leaf-numbers.html"},{"title":"Leetcode 1470. Shuffle the Array","text":"Question Link : https://leetcode.com/problems/shuffle-the-array/ Difficulty: Easy Premium: False Question Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn]. Return the array in the form [x1,y1,x2,y2,...,xn,yn]. Example 1: Input: nums = [2,5,1,3,4,7], n = 3 Output: [2,3,5,4,1,7] Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7]. Example 2: Input: nums = [1,2,3,4,4,3,2,1], n = 4 Output: [1,4,2,3,3,2,4,1] Example 3: Input: nums = [1,1,2,2], n = 2 Output: [1,2,1,2] Constraints: 1 <= n <= 500 nums.length == 2n 1 <= nums[i] <= 10&#94;3 Solution Go through the array and append i and i+n. Code ''' Leetcode 1470. Shuffle the Array Question Link : https://leetcode.com/problems/shuffle-the-array/ Solution Link : https://tofucode.com/posts/leetcode_1470_shuffle-the-array.html ''' class Solution : def shuffle ( self , nums : List [ int ], n : int ) -> List [ int ]: ''' 2,5,1, 3,4,7 2,3 5,4, 1,7 0,3 ... 2,5 - index Time : O(n) Space: O(n) ''' result = [] for i in range ( n ): result . append ( nums [ i ]) result . append ( nums [ i + n ]) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1470_shuffle-the-array.html","loc":"https://tofucode.com/posts/leetcode_1470_shuffle-the-array.html"},{"title":"Leetcode 0146. LRU Cache","text":"Question Link : https://leetcode.com/problems/lru-cache/ Difficulty: Medium Premium: False Question Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity. Example 1: Input [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4] Explanation LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // cache is {1=1} lRUCache.put(2, 2); // cache is {1=1, 2=2} lRUCache.get(1); // return 1 lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache.get(2); // returns -1 (not found) lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache.get(1); // return -1 (not found) lRUCache.get(3); // return 3 lRUCache.get(4); // return 4 Constraints: 1 <= capacity <= 3000 0 <= key <= 104 0 <= value <= 105 At most 2 * 105 calls will be made to get and put. Solution For constant time of look up, we'd need a hashmap/dict of key->value, for tracking least recently used, we can use a double linked list so that elements can easily be moved to one end. Extract common functions for reuse. Also notice later on that we need key stored on the node to go from node -> key for easy deletion of the key. Code ''' Leetcode 0146. LRU Cache Question Link : https://leetcode.com/problems/lru-cache/ Solution Link : https://tofucode.com/posts/leetcode_0146_lru-cache.html ''' class Node : def __init__ ( self , key = None , val = None ): self . key = key self . val = val self . prev = None self . next = None class LRUCache : def __init__ ( self , capacity : int ): ''' key -> value: hashmap # for look ups evict least recently used key: can use a list, when one element is used: lift it to one end - most recently used others at the other end - least recently used - to be evicted linked list to easily take node and move to end: most recent at tail, evict: least recent at head key -> node node: key # need to store key too, so we can get key from node and delete it from hashmap value prev next common func: unlink(node) unlinks a node from the linked list link(a, b) links a and b in that order addToTail(node) adds this node to the tail of the list so it is most recently used Time : O(1) for get and put Space: O(n) ''' self . store = {} # key -> node self . capacity = capacity self . head = Node () # least recent self . tail = Node () # most recent self . head . next = self . tail self . tail . prev = self . head def get ( self , key : int ) -> int : if key in self . store : node = self . store [ key ] self . unlink ( node ) self . addToTail ( node ) return node . val return - 1 def put ( self , key : int , value : int ) -> None : node = self . store . get ( key , None ) if node : node . val = value self . unlink ( node ) self . addToTail ( node ) else : node = Node ( key , value ) # check for eviction if len ( self . store ) >= self . capacity : old = self . unlink ( self . head . next ) del self . store [ old . key ] self . addToTail ( node ) self . store [ key ] = node def unlink ( self , node ): node . prev . next = node . next node . next . prev = node . prev return node def link ( self , a , b ): a . next = b b . prev = a def addToTail ( self , node ): self . link ( self . tail . prev , node ) self . link ( node , self . tail ) # Your LRUCache object will be instantiated and called as such: # obj = LRUCache(capacity) # param_1 = obj.get(key) # obj.put(key,value)","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0146_lru-cache.html","loc":"https://tofucode.com/posts/leetcode_0146_lru-cache.html"},{"title":"Leetcode 0093. Restore IP Addresses","text":"Question Link : https://leetcode.com/problems/restore-ip-addresses/ Difficulty: Medium Premium: False Question A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. For example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses. Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order. Example 1: Input: s = \"25525511135\" Output: [\"255.255.11.135\",\"255.255.111.35\"] Example 2: Input: s = \"0000\" Output: [\"0.0.0.0\"] Example 3: Input: s = \"101023\" Output: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"] Constraints: 1 <= s.length <= 20 s consists of digits only. Solution Since we want to consider different combos of splitting the current string, we'd want to use backtracking. Check that the various conditions are satisfied. Code ''' Leetcode 0093. Restore IP Addresses Question Link : https://leetcode.com/problems/restore-ip-addresses/ Solution Link : https://tofucode.com/posts/leetcode_0093_restore-ip-addresses.html ''' class Solution : def restoreIpAddresses ( self , s : str ) -> List [ str ]: ''' Use backtracking to build a path various checks to check for the conditions note for the for loop only check next 3 Time : O(3 &#94; 3) 3 branches, depth of 3 Space: O(1) ''' result = [] self . backtrack ( result , [], s , 0 ) return result def backtrack ( self , result , path , s , idx ): if idx == len ( s ): if len ( path ) == 4 : result . append ( '.' . join ( path )) return if len ( path ) >= 4 : return # go to next possible integer with max length 3 for i in range ( idx + 1 , min ( idx + 1 + 3 , len ( s ) + 1 )): num = s [ idx : i ] # check leading 0 if num [ 0 ] == '0' and len ( num ) > 1 : break # check range if int ( num ) > 255 : break self . backtrack ( result , path + [ num ], s , i )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0093_restore-ip-addresses.html","loc":"https://tofucode.com/posts/leetcode_0093_restore-ip-addresses.html"},{"title":"Leetcode 0232. Implement Queue using Stacks","text":"Question Link : https://leetcode.com/problems/implement-queue-using-stacks/ Difficulty: Easy Premium: False Question Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise. Notes: You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations. Example 1: Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false Constraints: 1 <= x <= 9 At most 100 calls will be made to push, pop, peek, and empty. All the calls to pop and peek are valid. Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer. Solution We separate write and read with the 2 queues, where we just keep writting to s1, and when read is needed, we reverse things into s2 in order to write the last of s2. Code ''' Leetcode 0232. Implement Queue using Stacks Question Link : https://leetcode.com/problems/implement-queue-using-stacks/ Solution Link : https://tofucode.com/posts/leetcode_0232_implement-queue-using-stacks.html ''' class MyQueue : ''' stack: push to top, pop from top s1: keep adding push here s2: reverse s1 into s2 when called pop, return last of s2 s1: write s2: read, peek (peek is same as read, read has extra step to delete) Time : Push O(1) Pop amortized O(1) Space: O(n) ''' def __init__ ( self ): self . s1 = [] # add in order self . s2 = [] # reverse order def push ( self , x ): self . s1 . append ( x ) def pop ( self ): self . peek () return self . s2 . pop () # pop last of s2 which is FIFO def peek ( self ): if not self . s2 : while self . s1 : self . s2 . append ( self . s1 . pop ()) return self . s2 [ - 1 ] def empty ( self ): return not self . s1 and not self . s2 # Your MyQueue object will be instantiated and called as such: # obj = MyQueue() # obj.push(x) # param_2 = obj.pop() # param_3 = obj.peek() # param_4 = obj.empty()","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0232_implement-queue-using-stacks.html","loc":"https://tofucode.com/posts/leetcode_0232_implement-queue-using-stacks.html"},{"title":"Leetcode 0100. Same Tree","text":"Question Link : https://leetcode.com/problems/same-tree/ Difficulty: Easy Premium: False Question Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. Example 1: Input: p = [1,2,3], q = [1,2,3] Output: true Example 2: Input: p = [1,2], q = [1,null,2] Output: false Example 3: Input: p = [1,2,1], q = [1,1,2] Output: false Constraints: The number of nodes in both trees is in the range [0, 100]. -104 <= Node.val <= 104 Solution Recursively compare all node. Note the 4 different cases of the 2 nodes. Code ''' Leetcode 0100. Same Tree Question Link : https://leetcode.com/problems/same-tree/ Solution Link : https://tofucode.com/posts/leetcode_0100_same-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def isSameTree ( self , p : Optional [ TreeNode ], q : Optional [ TreeNode ]) -> bool : ''' Recursion: check and compare all nodes Time : O(n) Space: O(n) ''' if p is None and q is None : return True if bool ( p ) &#94; bool ( q ): return False if p . val != q . val : return False return self . isSameTree ( p . left , q . left ) and self . isSameTree ( p . right , q . right )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0100_same-tree.html","loc":"https://tofucode.com/posts/leetcode_0100_same-tree.html"},{"title":"Leetcode 0150. Evaluate Reverse Polish Notation","text":"Question Link : https://leetcode.com/problems/evaluate-reverse-polish-notation/ Difficulty: Medium Premium: False Question Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, and /. Each operand may be an integer or another expression. Note that division between two integers should truncate toward zero. It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation. Example 1: Input: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2: Input: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\" \",\"/\",\" \",\"17\",\"+\",\"5\",\"+\"] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 Constraints: 1 <= tokens.length <= 104 tokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200]. Solution Notice the pattern that the operation is always for the 2 previous numbers, in this case a stack makes case so we can access the last 2. Two other things to note: 1. Check not an operation as a number, isdigit() doesn't work with negative numbers 2. to truncate toward zero: int(a / b) Code ''' Leetcode 0150. Evaluate Reverse Polish Notation Question Link : https://leetcode.com/problems/evaluate-reverse-polish-notation/ Solution Link : https://tofucode.com/posts/leetcode_0150_evaluate-reverse-polish-notation.html ''' class Solution : def evalRPN ( self , tokens : List [ str ]) -> int : ''' stack keep pushing numbers, if operation, pop the last 2 and evaluate, push back Time : O(n) Space: O(n) ''' stack = [] ops = set ([ \"+\" , \"-\" , \"*\" , \"/\" ]) for token in tokens : if not token in ops : stack . append ( int ( token )) else : b = stack . pop () a = stack . pop () result = 0 if token == '+' : result = a + b elif token == '-' : result = a - b elif token == '*' : result = a * b elif token == '/' : result = int ( a / b ) stack . append ( result ) return stack [ - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0150_evaluate-reverse-polish-notation.html","loc":"https://tofucode.com/posts/leetcode_0150_evaluate-reverse-polish-notation.html"},{"title":"Leetcode 1143. Longest Common Subsequence","text":"Question Link : https://leetcode.com/problems/longest-common-subsequence/ Difficulty: Medium Premium: False Question Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \"ace\" is a subsequence of \"abcde\". A common subsequence of two strings is a subsequence that is common to both strings. Example 1: Input: text1 = \"abcde\", text2 = \"ace\" Output: 3 Explanation: The longest common subsequence is \"ace\" and its length is 3. Example 2: Input: text1 = \"abc\", text2 = \"abc\" Output: 3 Explanation: The longest common subsequence is \"abc\" and its length is 3. Example 3: Input: text1 = \"abc\", text2 = \"def\" Output: 0 Explanation: There is no such common subsequence, so the result is 0. Constraints: 1 <= text1.length, text2.length <= 1000 text1 and text2 consist of only lowercase English characters. Solution Use dp. The decision to pre pad with 0s is cause we need to check left, up, and upper left, padding with zeros will be cleaner than checking i, j equal to zero cases. Code ''' Leetcode 1143. Longest Common Subsequence Question Link : https://leetcode.com/problems/longest-common-subsequence/ Solution Link : https://tofucode.com/posts/leetcode_1143_longest-common-subsequence.html ''' class Solution : def longestCommonSubsequence ( self , text1 : str , text2 : str ) -> int : ''' dp pad with 0 dp[i+1][j+1] = longest at i, j in text1, text2 abcde a 11111 c 00222 d 00033 Time : O(mn) Space: O(mn) ''' if text1 == text2 : return len ( text1 ) rows = len ( text1 ) cols = len ( text2 ) dp = [[ 0 ] * ( cols + 1 ) for x in range ( rows + 1 )] for i in range ( rows ): for j in range ( cols ): if text1 [ i ] == text2 [ j ]: dp [ i + 1 ][ j + 1 ] = dp [ i ][ j ] + 1 else : dp [ i + 1 ][ j + 1 ] = max ( dp [ i ][ j + 1 ], dp [ i + 1 ][ j ]) return dp [ - 1 ][ - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1143_longest-common-subsequence.html","loc":"https://tofucode.com/posts/leetcode_1143_longest-common-subsequence.html"},{"title":"Leetcode 0198. House Robber","text":"Question Link : https://leetcode.com/problems/house-robber/ Difficulty: Medium Premium: False Question You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Constraints: 1 <= nums.length <= 100 0 <= nums[i] <= 400 Solution Find the dp relationship where max money at house i depends on if you rob house i-1 or not Code ''' Leetcode 0198. House Robber Question Link : https://leetcode.com/problems/house-robber/ Solution Link : https://tofucode.com/posts/leetcode_0198_house-robber.html ''' class Solution : def rob ( self , nums : List [ int ]) -> int : ''' dp[i] = max money up to house i [2,7,9,3,1] [2 7 x ] x = max(7, 2+9) = 11 Time : O(n) Space: O(n) ''' if not nums : return 0 dp = [ 0 ] * len ( nums ) # max at robbing house i for i in range ( len ( nums )): if i == 0 : dp [ i ] = nums [ i ] elif i == 1 : dp [ i ] = max ( dp [ i - 1 ], nums [ i ]) else : dp [ i ] = max ( dp [ i - 1 ], dp [ i - 2 ] + nums [ i ]) return dp [ - 1 ] class SolutionImproved1 : def rob ( self , nums : List [ int ]) -> int : ''' Use DP with two pointers to keep track: p1 is current, p2 is previous Improved Space Time : O(n) Space: O(1) ''' if not nums : return 0 p1 = 0 p2 = 0 for i in range ( len ( nums )): p1 , p2 = max ( p2 + nums [ i ] , p1 ), p1 return p1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0198_house-robber.html","loc":"https://tofucode.com/posts/leetcode_0198_house-robber.html"},{"title":"Leetcode 0931. Minimum Falling Path Sum","text":"Question Link : https://leetcode.com/problems/minimum-falling-path-sum/ Difficulty: Medium Premium: False Question Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix. A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1). Example 1: Input: matrix = [[2,1,3],[6,5,4],[7,8,9]] Output: 13 Explanation: There are two falling paths with a minimum sum as shown. Example 2: Input: matrix = [[-19,57],[-40,-5]] Output: -59 Explanation: The falling path with a minimum sum is shown. Constraints: n == matrix.length == matrix[i].length 1 <= n <= 100 -100 <= matrix[i][j] <= 100 Solution Think about how we would start from the bottom and go down each col, we can see for each point we'd want the smallest one from above, and a sum at a certain point needs to be reused for different points too, so this is a typical dp problem. Code ''' Leetcode 0931. Minimum Falling Path Sum Question Link : https://leetcode.com/problems/minimum-falling-path-sum/ Solution Link : https://tofucode.com/posts/leetcode_0931_minimum-falling-path-sum.html ''' class Solution : def minFallingPathSum ( self , matrix : List [ List [ int ]]) -> int : ''' always going down dp[x][y] = the min sum falling from the top to x, y matrix = [[2,1,3],[6,5,4],[7,8,9]] 2 1 3 7 6 5 13 13 14 Space is actually only using the last row, so can be cut down to O(n) Time : O(mn) # this is a square, so o(n**2) for time and space Space: O(mn) ''' row = len ( matrix ) col = len ( matrix [ 0 ]) dp = [[ math . inf ] * col for x in range ( row )] for i in range ( row ): for j in range ( col ): if i == 0 : dp [ 0 ][ j ] = matrix [ 0 ][ j ] else : dp [ i ][ j ] = min ( self . getPosition ( dp , i - 1 , j - 1 , row , col ), \\ self . getPosition ( dp , i - 1 , j , row , col ), \\ self . getPosition ( dp , i - 1 , j + 1 , row , col ), \\ ) + matrix [ i ][ j ] return min ( dp [ - 1 ]) def getPosition ( self , dp , i , j , row , col ): if i < 0 or i >= row or j < 0 or j >= col : return math . inf return dp [ i ][ j ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0931_minimum-falling-path-sum.html","loc":"https://tofucode.com/posts/leetcode_0931_minimum-falling-path-sum.html"},{"title":"Leetcode 0124. Binary Tree Maximum Path Sum","text":"Question Link : https://leetcode.com/problems/binary-tree-maximum-path-sum/ Difficulty: Hard Premium: False Question A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path. Example 1: Input: root = [1,2,3] Output: 6 Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6. Example 2: Input: root = [-10,9,20,null,null,15,7] Output: 42 Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42. Constraints: The number of nodes in the tree is in the range [1, 3 * 104]. -1000 <= Node.val <= 1000 Solution This is not the same as finding subtree sum, as a single path might not be able to pass all nodes of a subtree. Use recursion and at every node consider the case where the path keeps going up or is tha path that passes both left and right of said node. Code ''' Leetcode 0124. Binary Tree Maximum Path Sum Question Link : https://leetcode.com/problems/binary-tree-maximum-path-sum/ Solution Link : https://tofucode.com/posts/leetcode_0124_binary-tree-maximum-path-sum.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def maxPathSum ( self , root : Optional [ TreeNode ]) -> int : ''' Use recursion, this is NOT to find the subtree with the largest sum - cause that might need more than a single path: [5,4,8,11,null,13,4,7,2,null,null,null,1] At each node find the max of path up to node, max of left + node right + node just node For the total result: use an extra var, so we can check current max path that might still go up path that passes through node and goes left and right (left + right + node.val) Time : O(n) go through all the node Space: O(n) h - height of the tree ''' self . result = - math . inf self . traverse ( root ) return self . result def traverse ( self , node ): ''' returns max of a path that passes to node ''' if not node : return 0 left = self . traverse ( node . left ) right = self . traverse ( node . right ) r = max ( left + node . val , right + node . val , node . val ) self . result = max ( self . result , r , left + right + node . val ) return r","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0124_binary-tree-maximum-path-sum.html","loc":"https://tofucode.com/posts/leetcode_0124_binary-tree-maximum-path-sum.html"},{"title":"Leetcode 1339. Maximum Product of Splitted Binary Tree","text":"Question Link : https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/ Difficulty: Medium Premium: False Question Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized. Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7. Note that you need to maximize the answer before taking the mod and not after taking it. Example 1: Input: root = [1,2,3,4,5,6] Output: 110 Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10) Example 2: Input: root = [1,null,2,3,4,null,null,5,6] Output: 90 Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6) Constraints: The number of nodes in the tree is in the range [2, 5 * 104]. 1 <= Node.val <= 104 Solution Think of the problem as trying to find 2 x sum of subtrees that have the biggest product. We can calculate the subtree sum at each node, and the total sum - one subtree sum would be the other subtree sum. Code ''' Leetcode 1339. Maximum Product of Splitted Binary Tree Question Link : https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_1339_maximum-product-of-splitted-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def maxProduct ( self , root : Optional [ TreeNode ]) -> int : ''' max product: make the 2 halves as equal as possible record sum of node and its subtree for every node product = (total sum - subtree sum) * subtree num Time : O(n) Space: O(n) ''' self . subtree_sum = [] total = self . traverse ( root ) result = 0 for x in self . subtree_sum : result = max ( result , ( total - x ) * x ) return result % ( 10 ** 9 + 7 ) def traverse ( self , node ): if not node : return 0 r = node . val + self . traverse ( node . left ) + self . traverse ( node . right ) self . subtree_sum . append ( r ) return r","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1339_maximum-product-of-splitted-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_1339_maximum-product-of-splitted-binary-tree.html"},{"title":"Leetcode 0872. Leaf-Similar Trees","text":"Question Link : https://leetcode.com/problems/leaf-similar-trees/ Difficulty: Easy Premium: False Question Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar. Example 1: Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8] Output: true Example 2: Input: root1 = [1,2,3], root2 = [1,3,2] Output: false Constraints: The number of nodes in each tree will be in the range [1, 200]. Both of the given trees will have values in the range [0, 200]. Solution Traverse both trees and note the leaf node values, compare. Code ''' Leetcode 0872. Leaf-Similar Trees Question Link : https://leetcode.com/problems/leaf-similar-trees/ Solution Link : https://tofucode.com/posts/leetcode_0872_leaf-similar-trees.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def leafSimilar ( self , root1 : Optional [ TreeNode ], root2 : Optional [ TreeNode ]) -> bool : ''' go through both and compare Time : O(n) Space: O(n) ''' a = self . traverse ( root1 , []) b = self . traverse ( root2 , []) return a == b def traverse ( self , node , result ): if not node : return [] if not node . left and not node . right : return result + [ node . val ] current = [] if node . left : current = self . traverse ( node . left , result ) + current if node . right : current = current + self . traverse ( node . right , result ) return current","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0872_leaf-similar-trees.html","loc":"https://tofucode.com/posts/leetcode_0872_leaf-similar-trees.html"},{"title":"Leetcode 0938. Range Sum of BST","text":"Question Link : https://leetcode.com/problems/range-sum-of-bst/ Difficulty: Easy Premium: False Question Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high]. Example 1: Input: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32. Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 Output: 23 Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23. Constraints: The number of nodes in the tree is in the range [1, 2 * 104]. 1 <= Node.val <= 105 1 <= low <= high <= 105 All Node.val are unique. Solution We go through the tree and add up the nodes that satisfy the range. Use the fact that this is a BST to decide which branch to go down. Code ''' Leetcode 0938. Range Sum of BST Question Link : https://leetcode.com/problems/range-sum-of-bst/ Solution Link : https://tofucode.com/posts/leetcode_0938_range-sum-of-bst.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def rangeSumBST ( self , root : Optional [ TreeNode ], low : int , high : int ) -> int : ''' go through the tree, if in range: add recursively Time: O(n) Space:O(n) # recursive stack is height of tree: worst case is n ''' if not root : return 0 v = root . val if low <= v <= high : return v + self . rangeSumBST ( root . left , low , high ) + self . rangeSumBST ( root . right , low , high ) elif v < low : return self . rangeSumBST ( root . right , low , high ) else : return self . rangeSumBST ( root . left , low , high ) class SolutionAlternative1 : def rangeSumBST ( self , root : Optional [ TreeNode ], low : int , high : int ) -> int : ''' Iteratively use bfs/dfs Time: O(n) Space:O(1) ''' result = 0 stack = [ root ] while stack : node = stack . pop () if node : v = node . val if low <= v <= high : result += v if low < v : stack . append ( node . left ) if v < high : stack . append ( node . right ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0938_range-sum-of-bst.html","loc":"https://tofucode.com/posts/leetcode_0938_range-sum-of-bst.html"},{"title":"Leetcode 0328. Odd Even Linked List","text":"Question Link : https://leetcode.com/problems/odd-even-linked-list/ Difficulty: Medium Premium: False Question Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is even, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input. You must solve the problem in O(1) extra space complexity and O(n) time complexity. Example 1: Input: head = [1,2,3,4,5] Output: [1,3,5,2,4] Example 2: Input: head = [2,1,3,5,6,4,7] Output: [2,3,6,7,1,5,4] Constraints: The number of nodes in the linked list is in the range [0, 104]. -106 <= Node.val <= 106 Solution Since we want to use constant space, we'd have to use 2 pointers to alternatively create the odd and even lists and link them at the end. Code ''' Leetcode 0328. Odd Even Linked List Question Link : https://leetcode.com/problems/odd-even-linked-list/ Solution Link : https://tofucode.com/posts/leetcode_0328_odd-even-linked-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def oddEvenList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: ''' 2 pointers 1 2 3 4 5 null a b a b a b link a -> b 1 3 4 2 4 Time : O(n) Space: O(1) ''' # 0 or 1 or 2 nodes: just return if not head or not head . next or not head . next . next : return head odd = head even = head . next even_start = even # track this to stitch the two together move_odd = True while odd and even and odd . next and even . next : if move_odd : if odd . next : odd . next , odd = odd . next . next , odd . next . next else : if even . next : even . next , even = even . next . next , even . next . next move_odd = not move_odd # connect the two parts even . next = None odd . next = even_start return head # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class SolutionAlternative1 : def oddEvenList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: ''' Simplified by not tracking odd or even number but moving both pointers at the same time Since they started at 1 apart and are therefor always tracking odd and even Time : O(n) Space: O(1) ''' # 0 or 1 or 2 nodes: just return if not head or not head . next or not head . next . next : return head odd = head even = head . next even_start = even # track this to stitch the two together while even and even . next : odd . next = even . next odd = odd . next even . next = odd . next even = even . next # connect the two parts odd . next = even_start return head","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0328_odd-even-linked-list.html","loc":"https://tofucode.com/posts/leetcode_0328_odd-even-linked-list.html"},{"title":"Leetcode 0876. Middle of the Linked List","text":"Question Link : https://leetcode.com/problems/middle-of-the-linked-list/ Difficulty: Easy Premium: False Question Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. Example 1: Input: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. Example 2: Input: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. Constraints: The number of nodes in the list is in the range [1, 100]. 1 <= Node.val <= 100 Solution Use a fast point at 2 times the speed of a slow pointer. when the fast one is at the end, the slow one is at the middle. Code ''' Leetcode 0876. Middle of the Linked List Question Link : https://leetcode.com/problems/middle-of-the-linked-list/ Solution Link : https://tofucode.com/posts/leetcode_0876_middle-of-the-linked-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def middleNode ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: ''' fast pointer at 2x the speed of slow 1 2 3 4 5 s f s f 1 2 3 4 5 6 s f s f s f Time : O(n) Space: O(1) ''' fast = slow = head while fast and fast . next : slow = slow . next fast = fast . next . next return slow","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0876_middle-of-the-linked-list.html","loc":"https://tofucode.com/posts/leetcode_0876_middle-of-the-linked-list.html"},{"title":"Leetcode 0451. Sort Characters By Frequency","text":"Question Link : https://leetcode.com/problems/sort-characters-by-frequency/ Difficulty: Medium Premium: False Question Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them. Example 1: Input: s = \"tree\" Output: \"eert\" Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer. Example 2: Input: s = \"cccaaa\" Output: \"aaaccc\" Explanation: Both 'c' and 'a' appear three times, so both \"cccaaa\" and \"aaaccc\" are valid answers. Note that \"cacaca\" is incorrect, as the same characters must be together. Example 3: Input: s = \"Aabb\" Output: \"bbAa\" Explanation: \"bbaA\" is also a valid answer, but \"Aabb\" is incorrect. Note that 'A' and 'a' are treated as two different characters. Constraints: 1 <= s.length <= 5 * 105 s consists of uppercase and lowercase English letters and digits. Solution Count and sort and reconstruct the string. Code ''' Leetcode 0451. Sort Characters By Frequency Question Link : https://leetcode.com/problems/sort-characters-by-frequency/ Solution Link : https://tofucode.com/posts/leetcode_0451_sort-characters-by-frequency.html ''' class Solution : def frequencySort ( self , s : str ) -> str : ''' map of char -> count go through s and count everything sort conatruct the string Time : O(n log n) Space: O(n) ''' counter = {} # char -> count for c in s : counter [ c ] = counter . get ( c , 0 ) + 1 sorted_chars = sorted ( counter . items (), key = lambda x : x [ 1 ], reverse = True ) result = '' for c , count in sorted_chars : result += c * count return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0451_sort-characters-by-frequency.html","loc":"https://tofucode.com/posts/leetcode_0451_sort-characters-by-frequency.html"},{"title":"Leetcode 1657. Determine if Two Strings Are Close","text":"Question Link : https://leetcode.com/problems/determine-if-two-strings-are-close/ Difficulty: Medium Premium: False Question Two strings are considered close if you can attain one from the other using the following operations: Operation 1: Swap any two existing characters. For example, abcde -> aecdb Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character. For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's) You can use the operations on either string as many times as necessary. Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise. Example 1: Input: word1 = \"abc\", word2 = \"bca\" Output: true Explanation: You can attain word2 from word1 in 2 operations. Apply Operation 1: \"abc\" -> \"acb\" Apply Operation 1: \"acb\" -> \"bca\" Example 2: Input: word1 = \"a\", word2 = \"aa\" Output: false Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations. Example 3: Input: word1 = \"cabbba\", word2 = \"abbccc\" Output: true Explanation: You can attain word2 from word1 in 3 operations. Apply Operation 1: \"cabbba\" -> \"caabbb\" Apply Operation 2: \"caabbb\" -> \"baaccc\" Apply Operation 2: \"baaccc\" -> \"abbccc\" Constraints: 1 <= word1.length, word2.length <= 105 word1 and word2 contain only lowercase English letters. Solution Consider what the 2 operations do and see how that translates to looking for count of chars in both strings. Here the True conditions are: if word1 has a char, word2 must also have it. if the count of the counts are the same for the 2 words. Code ''' Leetcode 1657. Determine if Two Strings Are Close Question Link : https://leetcode.com/problems/determine-if-two-strings-are-close/ Solution Link : https://tofucode.com/posts/leetcode_1657_determine-if-two-strings-are-close.html ''' class Solution : def closeStrings ( self , word1 : str , word2 : str ) -> bool : ''' can swap so position in the word does not matter count word 1 and 2 \"cabbba\" \"abbccc\" a: 2 a: 1 b: 3 b: 2 c: 1 c: 3 if a char appears in word2, it must appear in word2 to be able to do op2 check that count of all the values are the same with a sort on both counters Time : O(n) Space: O(1) ''' if len ( word1 ) != len ( word2 ): return False counter1 = self . count ( word1 ) counter2 = self . count ( word2 ) for i in range ( 26 ): a = counter1 [ i ] b = counter2 [ i ] if a == 0 and b > 0 or a > 0 and b == 0 : return False return sorted ( counter1 ) == sorted ( counter2 ) def count ( self , word ): result = [ 0 ] * 26 for c in word : result [ ord ( c ) - ord ( 'a' )] += 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1657_determine-if-two-strings-are-close.html","loc":"https://tofucode.com/posts/leetcode_1657_determine-if-two-strings-are-close.html"},{"title":"Leetcode 1704. Determine if String Halves Are Alike","text":"Question Link : https://leetcode.com/problems/determine-if-string-halves-are-alike/ Difficulty: Easy Premium: False Question You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half. Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters. Return true if a and b are alike. Otherwise, return false. Example 1: Input: s = \"book\" Output: true Explanation: a = \"bo\" and b = \"ok\". a has 1 vowel and b has 1 vowel. Therefore, they are alike. Example 2: Input: s = \"textbook\" Output: false Explanation: a = \"text\" and b = \"book\". a has 1 vowel whereas b has 2. Therefore, they are not alike. Notice that the vowel o is counted twice. Constraints: 2 <= s.length <= 1000 s.length is even. s consists of uppercase and lowercase letters. Solution Count vowels for the 2 halves and compare. Code ''' Leetcode 1704. Determine if String Halves Are Alike Question Link : https://leetcode.com/problems/determine-if-string-halves-are-alike/ Solution Link : https://tofucode.com/posts/leetcode_1704_determine-if-string-halves-are-alike.html ''' class Solution : def halvesAreAlike ( self , s : str ) -> bool : ''' go through s, add up vowel count to 2 vars Time : O(n) Space: O(1) ''' vowels = set ([ x for x in 'aeiouAEIOU' ]) first = 0 second = 0 mid = len ( s ) // 2 for i in range ( len ( s )): c = s [ i ] add = True if c in vowels else False if add : if i < mid : first += 1 else : second += 1 return first == second","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1704_determine-if-string-halves-are-alike.html","loc":"https://tofucode.com/posts/leetcode_1704_determine-if-string-halves-are-alike.html"},{"title":"Leetcode 1207. Unique Number of Occurrences","text":"Question Link : https://leetcode.com/problems/unique-number-of-occurrences/ Difficulty: Easy Premium: False Question Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise. Example 1: Input: arr = [1,2,2,1,1,3] Output: true Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. Example 2: Input: arr = [1,2] Output: false Example 3: Input: arr = [-3,0,1,-3,1,1,1,-3,10,0] Output: true Constraints: 1 <= arr.length <= 1000 -1000 <= arr[i] <= 1000 Solution Use a hash map to count the occurance and then check is all that is unique. Code ''' Leetcode 1207. Unique Number of Occurrences Question Link : https://leetcode.com/problems/unique-number-of-occurrences/ Solution Link : https://tofucode.com/posts/leetcode_1207_unique-number-of-occurrences.html ''' class Solution : def uniqueOccurrences ( self , arr : List [ int ]) -> bool : ''' Go through arr counter: num -> count len of set of all count == len(counter) Time : O(n) Sapce: O(n) ''' counter = {} # num -> count for i in arr : counter [ i ] = counter . get ( i , 0 ) + 1 return len ( counter ) == len ( set ( counter . values ()))","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1207_unique-number-of-occurrences.html","loc":"https://tofucode.com/posts/leetcode_1207_unique-number-of-occurrences.html"},{"title":"Leetcode 0380. Insert Delete GetRandom O(1)","text":"Question Link : https://leetcode.com/problems/insert-delete-getrandom-o1/ Difficulty: Medium Premium: False Question Implement the RandomizedSet class: RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity. Example 1: Input [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"] [[], [1], [2], [2], [], [1], [2], []] Output [null, true, false, true, 2, true, false, 2] Explanation RandomizedSet randomizedSet = new RandomizedSet(); randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomizedSet.remove(2); // Returns false as 2 does not exist in the set. randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly. randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2]. randomizedSet.insert(2); // 2 was already in the set, so return false. randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2. Constraints: -231 <= val <= 231 - 1 At most 2 * 105 calls will be made to insert, remove, and getRandom. There will be at least one element in the data structure when getRandom is called. Solution First start with a set and realize that we need better runtim for getRandom. Second find that we can use a dict that does the same thing as a set, but also gives number -> index mapping where index is for another array. So we use the array for getRandom and use the dict for insert and remove while also updating the list to stay in sync. Code ''' Leetcode 0380. Insert Delete GetRandom O(1) Question Link : https://leetcode.com/problems/insert-delete-getrandom-o1/ Solution Link : https://tofucode.com/posts/leetcode_0380_insert-delete-getrandom-o1.html ''' class RandomizedSet : ''' use a set/map : insert/remove: O(1) getRandom: O(n) get all and pick 1 array: for getRandom: randomly pick a index between 0 and len - 1 dict: # number -> index for insert and remove Time : O(1) for all 3 operations Space : O(n) ''' def __init__ ( self ): self . nums = [] self . position = {} # number -> index def insert ( self , val : int ) -> bool : ''' Returns True if inserted this time, False is already present ''' if val not in self . position : # add to the end of the list and update position dict self . nums . append ( val ) self . position [ val ] = len ( self . nums ) - 1 return True return False def remove ( self , val : int ) -> bool : ''' Return True if contains and removed this time. False if not in there ''' if val in self . position : # switch the to be deleted element with the last one idx = self . position [ val ] last = self . nums [ - 1 ] # update for last self . nums [ idx ] = last self . position [ last ] = idx # delete val from array and dict self . nums . pop () self . position . pop ( val ) return True return False def getRandom ( self ) -> int : return self . nums [ random . randint ( 0 , len ( self . nums ) - 1 )] # Your RandomizedSet object will be instantiated and called as such: # obj = RandomizedSet() # param_1 = obj.insert(val) # param_2 = obj.remove(val) # param_3 = obj.getRandom()","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0380_insert-delete-getrandom-o1.html","loc":"https://tofucode.com/posts/leetcode_0380_insert-delete-getrandom-o1.html"},{"title":"Leetcode 0002. Add Two Numbers","text":"Question Link : https://leetcode.com/problems/add-two-numbers/ Difficulty: Medium Premium: False Question You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2: Input: l1 = [0], l2 = [0] Output: [0] Example 3: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] Constraints: The number of nodes in each linked list is in the range [1, 100]. 0 <= Node.val <= 9 It is guaranteed that the list represents a number that does not have leading zeros. Solution Use 2 pointers to go through each list and sum up each digit Use a carry to denote when it's >= 10 At the very end, check the carry again Code ''' Leetcode 0002. Add Two Numbers Question Link : https://leetcode.com/problems/add-two-numbers/ Solution Link : https://tofucode.com/posts/leetcode_0002_add-two-numbers.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def addTwoNumbers ( self , l1 : Optional [ ListNode ], l2 : Optional [ ListNode ]) -> Optional [ ListNode ]: ''' [2,4,3] [5,6,4] 7 0 7+1 carry Time : O(m + n) Space: O(m + n) ''' a = l1 b = l2 dummy = ListNode () p = dummy carry = 0 while a or b : s = carry if a : s += a . val a = a . next if b : s += b . val b = b . next carry = s // 10 s = s % 10 node = ListNode ( s ) p . next = node p = p . next # check if there is still a 1 if carry : node = ListNode ( carry ) p . next = node return dummy . next","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0002_add-two-numbers.html","loc":"https://tofucode.com/posts/leetcode_0002_add-two-numbers.html"},{"title":"Leetcode 0001. Two Sum","text":"Question Link : https://leetcode.com/problems/two-sum/ Difficulty: Easy Premium: False Question Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 <= nums.length <= 104 -109 <= nums[i] <= 109 -109 <= target <= 109 Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity? Solution ww Code ''' Leetcode 0001. Two Sum Question Link : https://leetcode.com/problems/two-sum/ Solution Link : https://tofucode.com/posts/leetcode_0001_two-sum.html ''' class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: ''' [3,2,4], target = 6 numbers: [2, 4] indices: [1, 2] other = target - current number 3 ? 4 ? 2 ? seen = {} # number -> index 3 -> 0, 2 -> 1, Time: O(n) Space: O(n) ''' seen = {} # number -> index for i in range ( len ( nums )): num = nums [ i ] other = target - num if other in seen : return [ seen [ other ], i ] seen [ num ] = i","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0001_two-sum.html","loc":"https://tofucode.com/posts/leetcode_0001_two-sum.html"},{"title":"Leetcode 0224. Basic Calculator","text":"Question Link : https://leetcode.com/problems/basic-calculator/ Difficulty: Hard Question Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). Example 1: Input: s = \"1 + 1\" Output: 2 Example 2: Input: s = \" 2-1 + 2 \" Output: 3 Example 3: Input: s = \"(1+(4+5+2)-3)+(6+8)\" Output: 23 Constraints: 1 <= s.length <= 3 * 105 s consists of digits, '+', '-', '(', ')', and ' '. s represents a valid expression. '+' is not used as a unary operation (i.e., \"+1\" and \"+(2 + 3)\" is invalid). '-' could be used as a unary operation (i.e., \"-1\" and \"-(2 + 3)\" is valid). There will be no two consecutive operators in the input. Every number and running calculation will fit in a signed 32-bit integer. Solution We can use a stack like the case without parentheses. The tricky part is dealing with the sign before a parenthesis. An improved version can be just storing (), sign before (), and a number that was evaluated before. Code ''' Leetcode 0224. Basic Calculator Question Link : https://leetcode.com/problems/basic-calculator/ Solution Link : https://tofucode.com/posts/leetcode_0224_basic-calculator.html ''' class Solution : def calculate ( self , s : str ) -> int : ''' Similiar to withough () Use a stack to store () and numbers, when you hit a ), process till ( the special case was the -( case which needs an extra sign to change the processed result This stores the sign information before the parenthesis Time : O(n) Space: O(n) ''' line = '' . join ([ c . strip () for c in s . strip ()]) stack = [] i = 0 sign = 1 while i < len ( line ): c = line [ i ] if c . isdigit (): j = i + 1 while j < len ( line ) and line [ j ] . isdigit (): j += 1 num = int ( line [ i : j ]) stack . append ( sign * num ) sign = 1 i = j elif c == '+' : sign = 1 i += 1 elif c == '-' : sign = - 1 i += 1 elif c == '(' : if sign == 1 : stack . append ( c ) else : stack . append ( '-(' ) sign = 1 i += 1 elif c == ')' : total = 0 while stack and stack [ - 1 ] != '(' and stack [ - 1 ] != '-(' : total += stack . pop () last = stack . pop () # pop the ( if last == '-(' : total = - 1 * total stack . append ( total ) i += 1 return sum ([ x for x in stack ]) class SolutionImproved1 : def calculate ( self , s : str ) -> int : ''' Stack: (: store the current result onto it for later, store the curent sign insdie the (): evaluate as normal without the () ): calculate before the () and within () Time : O(n) Space: O(n) ''' stack = [] num = 0 # current number res = 0 # current result sign = 1 for ch in s : if ch . isdigit (): num = ( num * 10 ) + int ( ch ) elif ch == '+' : res += sign * num sign = 1 num = 0 elif ch == '-' : res += sign * num sign = - 1 num = 0 elif ch == '(' : # Push current result, sign stack . append ( res ) stack . append ( sign ) # reset sign = 1 res = 0 elif ch == ')' : res += sign * num # evaluate current number onto current result last_sign = stack . pop () # last sign last_num = stack . pop () # last number res = last_num + last_sign * res # last_sign * res is the current res with the sign before # reset sign = 1 num = 0 res += sign * num return res","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0224_basic-calculator.html","loc":"https://tofucode.com/posts/leetcode_0224_basic-calculator.html"},{"title":"Leetcode 0227. Basic Calculator II","text":"Question Link : https://leetcode.com/problems/basic-calculator-ii/ Difficulty: Medium Question Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1]. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). Example 1: Input: s = \"3+2*2\" Output: 7 Example 2: Input: s = \" 3/2 \" Output: 1 Example 3: Input: s = \" 3+5 / 2 \" Output: 5 Constraints: 1 <= s.length <= 3 * 105 s consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces. s represents a valid expression. All the integers in the expression are non-negative integers in the range [0, 231 - 1]. The answer is guaranteed to fit in a 32-bit integer. Solution First thought is to use a stack so we can process and save number in it. The Stack can further be simplified into just a number. Code ''' Leetcode 0227. Basic Calculator II Question Link : https://leetcode.com/problems/basic-calculator-ii/ Solution Link : https://tofucode.com/posts/leetcode_0227_basic-calculator-ii.html ''' class Solution : def calculate ( self , s : str ) -> int : ''' Use a stack number: add it in with a sign + -: sign of 1/-1 * /: find the next number, calculate with the last number on stack, add back result Time : O(n) Space: O(n) ''' line = '' . join ([ c . strip () for c in s . strip ()]) stack = [] i = 0 sign = 1 while i < len ( line ): c = line [ i ] if c . isdigit (): j = i + 1 while j < len ( line ) and line [ j ] . isdigit (): j += 1 num = int ( line [ i : j ]) stack . append ( sign * num ) sign = 1 i = j elif c == '+' : sign = 1 i += 1 elif c == '-' : sign = - 1 i += 1 elif c == '*' or c == '/' : last = stack . pop () j = i + 1 while j < len ( line ) and line [ j ] . isdigit (): j += 1 num = int ( line [ i + 1 : j ]) if c == '*' : stack . append ( sign * last * num ) elif c == '/' : stack . append ( sign * int ( last / num )) sign = 1 i = j return sum ( stack ) class SolutionImproved1 : def calculate ( self , s : str ) -> int : ''' simplify stack to last number, and the toral result Time : O(n) Space: O(1) ''' line = '' . join ([ c . strip () for c in s . strip ()]) i = 0 sign = 1 last = 0 result = 0 while i < len ( line ): c = line [ i ] if c . isdigit (): j = i + 1 while j < len ( line ) and line [ j ] . isdigit (): j += 1 num = int ( line [ i : j ]) last = num i = j elif c == '+' : result += sign * last last = 0 sign = 1 i += 1 elif c == '-' : result += sign * last last = 0 sign = - 1 i += 1 elif c == '*' or c == '/' : j = i + 1 while j < len ( line ) and line [ j ] . isdigit (): j += 1 num = int ( line [ i + 1 : j ]) if c == '*' : last = last * num elif c == '/' : last = int ( last / num ) i = j result += sign * last return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0227_basic-calculator-ii.html","loc":"https://tofucode.com/posts/leetcode_0227_basic-calculator-ii.html"},{"title":"Leetcode 0263. Ugly Number","text":"Question Link : https://leetcode.com/problems/ugly-number/ Difficulty: Easy Question An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return true if n is an ugly number. Example 1: Input: n = 6 Output: true Explanation: 6 = 2 Ã 3 Example 2: Input: n = 1 Output: true Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5. Example 3: Input: n = 14 Output: false Explanation: 14 is not ugly since it includes the prime factor 7. Constraints: -231 <= n <= 231 - 1 Solution Keep dividing by the given numbers when possibles. Return false when not possible. Code ''' Leetcode 0263. Ugly Number Question Link : https://leetcode.com/problems/ugly-number/ Solution Link : https://tofucode.com/posts/leetcode_0263_ugly-number.html ''' class Solution : def isUgly ( self , n : int ) -> bool : ''' Go through 2, 3, 5, divide if can be divided Time : O(log n) log 2 + log 3 + log 5 Space: O(1) ''' if n < 1 : return False nums = [ 2 , 3 , 5 ] i = n while i != 1 : can_divide = False for num in nums : if i % num == 0 : i /= num can_divide = True if not can_divide : return False return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0263_ugly-number.html","loc":"https://tofucode.com/posts/leetcode_0263_ugly-number.html"},{"title":"Leetcode 0223. Rectangle Area","text":"Question Link : https://leetcode.com/problems/rectangle-area/ Difficulty: Medium Question Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles. The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2). The second rectangle is defined by its bottom-left corner (bx1, by1) and its top-right corner (bx2, by2). Example 1: Input: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2 Output: 45 Example 2: Input: ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2 Output: 16 Constraints: -104 <= ax1 <= ax2 <= 104 -104 <= ay1 <= ay2 <= 104 -104 <= bx1 <= bx2 <= 104 -104 <= by1 <= by2 <= 104 Solution The result is the area total - overlap, to calculate overlap, we try to find the condition where there would be a overlap and see if this exists. Code ''' Leetcode 0223. Rectangle Area Question Link : https://leetcode.com/problems/rectangle-area/ Solution Link : https://tofucode.com/posts/leetcode_0223_rectangle-area.html ''' class Solution : def computeArea ( self , ax1 : int , ay1 : int , ax2 : int , ay2 : int , bx1 : int , by1 : int , bx2 : int , by2 : int ) -> int : ''' first area + second area - overlap if any overlap: x_diff * y_diff Time : O(1) Space: O(1) ''' a_area = ( ax2 - ax1 ) * ( ay2 - ay1 ) b_area = ( bx2 - bx1 ) * ( by2 - by1 ) result = a_area + b_area x_diff = min ( ax2 , bx2 ) - max ( ax1 , bx1 ) y_diff = min ( ay2 , by2 ) - max ( ay1 , by1 ) if x_diff > 0 and y_diff > 0 : result -= x_diff * y_diff return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0223_rectangle-area.html","loc":"https://tofucode.com/posts/leetcode_0223_rectangle-area.html"},{"title":"Leetcode 0374. Guess Number Higher or Lower","text":"Question Link : https://leetcode.com/problems/guess-number-higher-or-lower/ Difficulty: Easy Question We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results: -1: Your guess is higher than the number I picked (i.e. num > pick). 1: Your guess is lower than the number I picked (i.e. num < pick). 0: your guess is equal to the number I picked (i.e. num == pick). Return the number that I picked. Example 1: Input: n = 10, pick = 6 Output: 6 Example 2: Input: n = 1, pick = 1 Output: 1 Example 3: Input: n = 2, pick = 1 Output: 1 Constraints: 1 <= n <= 231 - 1 1 <= pick <= n Solution Use binary search with the only change being using guess() to check where the anwser is. Code ''' Leetcode 0374. Guess Number Higher or Lower Question Link : https://leetcode.com/problems/guess-number-higher-or-lower/ Solution Link : https://tofucode.com/posts/leetcode_0374_guess-number-higher-or-lower.html ''' # The guess API is already defined for you. # @param num, your guess # @return -1 if num is higher than the picked number # 1 if num is lower than the picked number # otherwise return 0 # def guess(num: int) -> int: class Solution : def guessNumber ( self , n : int ) -> int : ''' binary search edge case: n = 1: return 1 n = 2, l = 1, r = 2, mid is 1, l += 1, return l Time : O(log n) Space: O(1) ''' l = 1 r = n while l < r : mid = ( l + r ) // 2 res = guess ( mid ) if res == 0 : return mid elif res == - 1 : r = mid - 1 else : l = mid + 1 return l","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0374_guess-number-higher-or-lower.html","loc":"https://tofucode.com/posts/leetcode_0374_guess-number-higher-or-lower.html"},{"title":"Leetcode 0222. Count Complete Tree Nodes","text":"Question Link : https://leetcode.com/problems/count-complete-tree-nodes/ Difficulty: Medium Question Given the root of a complete binary tree, return the number of the nodes in the tree. According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Design an algorithm that runs in less than O(n) time complexity. Example 1: Input: root = [1,2,3,4,5,6] Output: 6 Example 2: Input: root = [] Output: 0 Example 3: Input: root = [1] Output: 1 Constraints: The number of nodes in the tree is in the range [0, 5 * 104]. 0 <= Node.val <= 5 * 104 The tree is guaranteed to be complete. Solution To have the time below O(n), we need to think how this differs from a binary tree and use that. For a full tree the node count is 2 &#94; height - 1. Otherwise we can keep goind down to find the count for complete trees. Code ''' Leetcode 0222. Count Complete Tree Nodes Question Link : https://leetcode.com/problems/count-complete-tree-nodes/ Solution Link : https://tofucode.com/posts/leetcode_0222_count-complete-tree-nodes.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def countNodes ( self , root : Optional [ TreeNode ]) -> int : ''' Full binary tree: complete + last row is full height total 1 1 2 3 3 7 total = 2 &#94; height - 1 So for full binary tree, do this. Other keep recursing Because: all nodes in the last level are as far left as possible, half of the call is always a full tree Time : O(logn&#94;2) Sapce: O(logn&#94;2) resursive stack ''' if not root : return 0 left = right = root height = 0 while right != None : left = left . left right = right . right height += 1 if left == None : # perfect tree return ( 1 << height ) - 1 else : # another complete tree return 1 + self . countNodes ( root . left ) + self . countNodes ( root . right ) class SolutionNaive1 : def countNodes ( self , root : Optional [ TreeNode ]) -> int : ''' Recursion Time : O(n) Space: O(n) ''' if not root : return 0 return 1 + self . countNodes ( root . left ) + self . countNodes ( root . right )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0222_count-complete-tree-nodes.html","loc":"https://tofucode.com/posts/leetcode_0222_count-complete-tree-nodes.html"},{"title":"Leetcode 0056. Merge Intervals","text":"Question Link : https://leetcode.com/problems/merge-intervals/ Difficulty: Medium Question Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1: Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2: Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints: 1 <= intervals.length <= 104 intervals[i].length == 2 0 <= starti <= endi <= 104 Solution Sort by start time and go through and merge. Code ''' Leetcode 0056. Merge Intervals Question Link : https://leetcode.com/problems/merge-intervals/ Solution Link : https://tofucode.com/posts/leetcode_0056_merge-intervals.html ''' class Solution : def merge ( self , intervals : List [ List [ int ]]) -> List [ List [ int ]]: ''' sorted by start time go through and check the last one if can merge: merge with the ending time being the latest else add it in to result [1,3],[2,6],[8,10],[15,18]] [1,3] [1,6] Time : O(n log n) Space: O(n) ''' intervals = sorted ( intervals , key = lambda x : x [ 0 ]) result = [] for interval in intervals : if not result : result . append ( interval ) continue last = result [ - 1 ] if last [ 1 ] >= interval [ 0 ]: result . pop () result . append ([ last [ 0 ], max ( last [ 1 ], interval [ 1 ])]) else : result . append ( interval ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0056_merge-intervals.html","loc":"https://tofucode.com/posts/leetcode_0056_merge-intervals.html"},{"title":"Leetcode 0057. Insert Interval","text":"Question Link : https://leetcode.com/problems/insert-interval/ Difficulty: Medium Question You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Constraints: 0 <= intervals.length <= 104 intervals[i].length == 2 0 <= starti <= endi <= 105 intervals is sorted by starti in ascending order. newInterval.length == 2 0 <= start <= end <= 105 Solution Same as the merge interval problem. Code ''' Leetcode 0057. Insert Interval Question Link : https://leetcode.com/problems/insert-interval/ Solution Link : https://tofucode.com/posts/leetcode_0057_insert-interval.html ''' class Solution : def insert ( self , intervals : List [ List [ int ]], newInterval : List [ int ]) -> List [ List [ int ]]: ''' add the new one in and merge intervals Time : O(n log n) Space: O(n) ''' intervals . append ( newInterval ) intervals = sorted ( intervals , key = lambda x : x [ 0 ]) result = [] for interval in intervals : if not result : result . append ( interval ) continue last = result [ - 1 ] if last [ 1 ] >= interval [ 0 ]: result . pop () result . append ([ last [ 0 ], max ( last [ 1 ], interval [ 1 ])]) else : result . append ( interval ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0057_insert-interval.html","loc":"https://tofucode.com/posts/leetcode_0057_insert-interval.html"},{"title":"Leetcode 0435. Non-overlapping Intervals","text":"Question Link : https://leetcode.com/problems/non-overlapping-intervals/ Difficulty: Medium Question Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Example 1: Input: intervals = [[1,2],[2,3],[3,4],[1,3]] Output: 1 Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping. Example 2: Input: intervals = [[1,2],[1,2],[1,2]] Output: 2 Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping. Example 3: Input: intervals = [[1,2],[2,3]] Output: 0 Explanation: You don't need to remove any of the intervals since they're already non-overlapping. Constraints: 1 <= intervals.length <= 105 intervals[i].length == 2 -5 * 104 <= starti < endi <= 5 * 104 Solution Use the merge interval solution, except here when there would be a merge, we just drop the later one. Code ''' Leetcode 0435. Non-overlapping Intervals Question Link : https://leetcode.com/problems/non-overlapping-intervals/ Solution Link : https://tofucode.com/posts/leetcode_0435_non-overlapping-intervals.html ''' class Solution : def eraseOverlapIntervals ( self , intervals : List [ List [ int ]]) -> int : ''' sort by earliest end time maintain all non overlapping intervals [1,2],[2,3],[3,4],[1,3] sorted: [1,2],[2,3],[1,3],[3,4] current: [1,2] result 0 [1,3] 0 [1,3] 1 [1,4] 1 Time : O(n log n) Space: O(n) for the sort, otherwise O(1) ''' intervals = sorted ( intervals , key = lambda x : x [ 1 ]) result = [] # all non overlapping intervals for interval in intervals : if not result : result . append ( interval ) continue last = result [ - 1 ] if last [ 1 ] > interval [ 0 ]: # do nothing, as instead of merging, we remove current continue else : result . append ( interval ) return len ( intervals ) - len ( result ) class SolutionImproved1 : def eraseOverlapIntervals ( self , intervals : List [ List [ int ]]) -> int : ''' Change the result array to last pointer, since we're only checking the last one Time : O(n log n) Space: O(n) for the sort, otherwise O(1) ''' intervals = sorted ( intervals , key = lambda x : x [ 1 ]) result = 0 last = None for interval in intervals : if not last : last = interval continue if last [ 1 ] > interval [ 0 ]: # remove current result += 1 else : last [ 1 ] = interval [ 1 ] return result class SolutionImrpved2 : def eraseOverlapIntervals ( self , intervals : List [ List [ int ]]) -> int : ''' sort by earliest end time maintain the last interval end greedy [1,2],[2,3],[3,4],[1,3] sorted: [1,2],[2,3],[1,3],[3,4] current: [1,2] result 0 [1,3] 0 [1,3] 1 [1,4] 1 Time : O(n log n) Space: O(n) for the sort, otherwise O(1) ''' intervals = sorted ( intervals , key = lambda x : x [ 1 ]) result = 0 end = - math . inf for interval in intervals : if end > interval [ 0 ]: result += 1 else : end = interval [ 1 ] return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0435_non-overlapping-intervals.html","loc":"https://tofucode.com/posts/leetcode_0435_non-overlapping-intervals.html"},{"title":"Leetcode 0452. Minimum Number of Arrows to Burst Balloons","text":"Question Link : https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/ Difficulty: Medium Question There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons. Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path. Given the array points, return the minimum number of arrows that must be shot to burst all balloons. Example 1: Input: points = [[10,16],[2,8],[1,6],[7,12]] Output: 2 Explanation: The balloons can be burst by 2 arrows: - Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6]. - Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12]. Example 2: Input: points = [[1,2],[3,4],[5,6],[7,8]] Output: 4 Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows. Example 3: Input: points = [[1,2],[2,3],[3,4],[4,5]] Output: 2 Explanation: The balloons can be burst by 2 arrows: - Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3]. - Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5]. Constraints: 1 <= points.length <= 105 points[i].length == 2 -231 <= xstart < xend <= 231 - 1 Solution Merge intervals but only merge and store the overlap Code ''' Leetcode 0452. Minimum Number of Arrows to Burst Balloons Question Link : https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/ Solution Link : https://tofucode.com/posts/leetcode_0452_minimum-number-of-arrows-to-burst-balloons.html ''' class Solution : def findMinArrowShots ( self , points : List [ List [ int ]]) -> int : ''' Merge intervals but only merge and store the overlap [10,16],[2,8],[1,6],[7,12] sorted [1,6],[2,8],[7,12],[10,16] [1,6] [2,6] [2,6],[7,12] [2,6],[10, 12] [1,6],[2,8] and [7,12],[10,16] Time : O(n log n) Space: O(n) ''' intervals = sorted ( points , key = lambda x : x [ 0 ]) result = [] for interval in intervals : if not result : result . append ( interval ) continue last = result [ - 1 ] if last [ 1 ] >= interval [ 0 ]: result . pop () result . append ([ interval [ 0 ], min ( last [ 1 ], interval [ 1 ])]) else : result . append ( interval ) return len ( result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0452_minimum-number-of-arrows-to-burst-balloons.html","loc":"https://tofucode.com/posts/leetcode_0452_minimum-number-of-arrows-to-burst-balloons.html"},{"title":"Leetcode 0495. Teemo Attacking","text":"Question Link : https://leetcode.com/problems/teemo-attacking/ Difficulty: Easy Question Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack. You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration. Return the total number of seconds that Ashe is poisoned. Example 1: Input: timeSeries = [1,4], duration = 2 Output: 4 Explanation: Teemo's attacks on Ashe go as follows: - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2. - At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5. Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total. Example 2: Input: timeSeries = [1,2], duration = 2 Output: 3 Explanation: Teemo's attacks on Ashe go as follows: - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2. - At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3. Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total. Constraints: 1 <= timeSeries.length <= 104 0 <= timeSeries[i], duration <= 107 timeSeries is sorted in non-decreasing order. Solution Go through timeseries, and we keep adding the duration or the time to the next hit time Code ''' Leetcode 0495. Teemo Attacking Question Link : https://leetcode.com/problems/teemo-attacking/ Solution Link : https://tofucode.com/posts/leetcode_0495_teemo-attacking.html ''' class Solution : def findPoisonedDuration ( self , timeSeries : List [ int ], duration : int ) -> int : ''' Greedy: Use one pass, keep adding the duration or time to the next hit time, whichever is smaller Time : O(n) Space: O(n) ''' if not timeSeries or not duration : return 0 result = 0 for i in range ( len ( timeSeries ) - 1 ): result += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ) return result + duration class SolutionAlternative1 : def findPoisonedDuration ( self , timeSeries : List [ int ], duration : int ) -> int : ''' merge intervals, result is sum of all interval length Time : O(n) Space: O(n) ''' if not timeSeries or not duration : return 0 intervals = [[ t , t + duration ] for t in timeSeries ] result = [] for interval in intervals : if not result : result . append ( interval ) last = result [ - 1 ] if interval [ 0 ] < last [ 1 ]: result . pop () result . append ([ last [ 0 ], max ( last [ 1 ], interval [ 1 ])]) else : result . append ( interval ) d = [ x [ 1 ] - x [ 0 ] for x in result ] return sum ( d )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0495_teemo-attacking.html","loc":"https://tofucode.com/posts/leetcode_0495_teemo-attacking.html"},{"title":"Leetcode 2446. Determine if Two Events Have Conflict","text":"Question Link : https://leetcode.com/problems/determine-if-two-events-have-conflict/ Difficulty: Easy Question You are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where: event1 = [startTime1, endTime1] and event2 = [startTime2, endTime2]. Event times are valid 24 hours format in the form of HH:MM. A conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events). Return true if there is a conflict between two events. Otherwise, return false. Example 1: Input: event1 = [\"01:15\",\"02:00\"], event2 = [\"02:00\",\"03:00\"] Output: true Explanation: The two events intersect at time 2:00. Example 2: Input: event1 = [\"01:00\",\"02:00\"], event2 = [\"01:20\",\"03:00\"] Output: true Explanation: The two events intersect starting from 01:20 to 02:00. Example 3: Input: event1 = [\"10:00\",\"11:00\"], event2 = [\"14:00\",\"15:00\"] Output: false Explanation: The two events do not intersect. Constraints: evnet1.length == event2.length == 2. event1[i].length == event2[i].length == 5 startTime1 <= endTime1 startTime2 <= endTime2 All the event times follow the HH:MM format. Solution Check event 1 end time and event 2 start time Code ''' Leetcode 2446. Determine if Two Events Have Conflict Question Link : https://leetcode.com/problems/determine-if-two-events-have-conflict/ Solution Link : https://tofucode.com/posts/leetcode_2446_determine-if-two-events-have-conflict.html ''' class Solution : def haveConflict ( self , event1 : List [ str ], event2 : List [ str ]) -> bool : ''' Sort first so the first event happens first Only need to check: event1 end time and event2 start time There are only 2 events Time : O(1) Space: O(1) ''' events = sorted ([ event1 , event2 ]) end_time = events [ 0 ][ 1 ] start_time = events [ 1 ][ 0 ] if end_time < start_time : return False return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2446_determine-if-two-events-have-conflict.html","loc":"https://tofucode.com/posts/leetcode_2446_determine-if-two-events-have-conflict.html"},{"title":"Leetcode 1094. Car Pooling","text":"Question Link : https://leetcode.com/problems/car-pooling/ Difficulty: Medium Question There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west). You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car's initial location. Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise. Example 1: Input: trips = [[2,1,5],[3,3,7]], capacity = 4 Output: false Example 2: Input: trips = [[2,1,5],[3,3,7]], capacity = 5 Output: true Constraints: 1 <= trips.length <= 1000 trips[i].length == 3 1 <= numPassengersi <= 100 0 <= fromi < toi <= 1000 1 <= capacity <= 105 Solution Use a dict or an array to track what the passenger count is at every point, and then whenever that exceeds the capacity, we return False. Code ''' Leetcode 1094. Car Pooling Question Link : https://leetcode.com/problems/car-pooling/ Solution Link : https://tofucode.com/posts/leetcode_1094_car-pooling.html ''' class Solution : def carPooling ( self , trips : List [ List [ int ]], capacity : int ) -> bool : ''' location -> count check through every locaiton needs to be < capacity [2,1,5], passengers, from, to 1 -> 2 2 -> 2 3 -> 2 + 3 4 -> 2 + 3 5 -> 2 + 3 Time : O(1000 * 1000) every trip goes full length Space: O(1000) ''' location = {} # location -> passenger count for trip in trips : p , start , end = trip for i in range ( start , end ): location [ i ] = location . get ( i , 0 ) + p if location [ i ] > capacity : return False return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1094_car-pooling.html","loc":"https://tofucode.com/posts/leetcode_1094_car-pooling.html"},{"title":"Leetcode 2418. Sort the People","text":"Question Link : https://leetcode.com/problems/sort-the-people/ Difficulty: Easy Question You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n. For each index i, names[i] and heights[i] denote the name and height of the ith person. Return names sorted in descending order by the people's heights. Example 1: Input: names = [\"Mary\",\"John\",\"Emma\"], heights = [180,165,170] Output: [\"Mary\",\"Emma\",\"John\"] Explanation: Mary is the tallest, followed by Emma and John. Example 2: Input: names = [\"Alice\",\"Bob\",\"Bob\"], heights = [155,185,150] Output: [\"Bob\",\"Alice\",\"Bob\"] Explanation: The first Bob is the tallest, followed by Alice and the second Bob. Constraints: n == names.length == heights.length 1 <= n <= 103 1 <= names[i].length <= 20 1 <= heights[i] <= 105 names[i] consists of lower and upper case English letters. All the values of heights are distinct. Solution Use a hashmap to map height to name, and sort by height. Code ''' Leetcode 2418. Sort the People Question Link : https://leetcode.com/problems/sort-the-people/ Solution Link : https://tofucode.com/posts/leetcode_2418_sort-the-people.html ''' class Solution : def sortPeople ( self , names : List [ str ], heights : List [ int ]) -> List [ str ]: ''' height is distinct people = {} # height -> name sort based on key, return name Time : O(n) Space: O(n) ''' people = {} # height -> name for i in range ( len ( names )): p = names [ i ] h = heights [ i ] people [ h ] = p sorted_people = sorted ( people . items (), key = lambda x : x [ 0 ], reverse = True ) return [ x [ 1 ] for x in sorted_people ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2418_sort-the-people.html","loc":"https://tofucode.com/posts/leetcode_2418_sort-the-people.html"},{"title":"Leetcode 2423. Remove Letter To Equalize Frequency","text":"Question Link : https://leetcode.com/problems/remove-letter-to-equalize-frequency/ Difficulty: Easy Question You are given a 0-indexed string word, consisting of lowercase English letters. You need to select one index and remove the letter at that index from word so that the frequency of every letter present in word is equal. Return true if it is possible to remove one letter so that the frequency of all letters in word are equal, and false otherwise. Note: The frequency of a letter x is the number of times it occurs in the string. You must remove exactly one letter and cannot chose to do nothing. Example 1: Input: word = \"abcc\" Output: true Explanation: Select index 3 and delete it: word becomes \"abc\" and each character has a frequency of 1. Example 2: Input: word = \"aazz\" Output: false Explanation: We must delete a character, so either the frequency of \"a\" is 1 and the frequency of \"z\" is 2, or vice versa. It is impossible to make all present letters have equal frequency. Constraints: 2 <= word.length <= 100 word consists of lowercase English letters only. Solution First return True we would need to remove a char and check if all ther others chars are of equal counts, to do this we can use a hash map as a counter, and then loop through all possible chars, remove, and check if the condition is satisfied. Code ''' Leetcode 2423. Remove Letter To Equalize Frequency Question Link : https://leetcode.com/problems/remove-letter-to-equalize-frequency/ Solution Link : https://tofucode.com/posts/leetcode_2423_remove-letter-to-equalize-frequency.html ''' class Solution : def equalFrequency ( self , word : str ) -> bool : ''' go through and map char -> count When removing any char, everything that's left has equal frequency/count So in next for loop, we go through all possible chars: 1. remove 2. check if all other counts are the same (return True if it is) 3. add back 1 if not and keep going counter # char -> count a: 1 b: 1 c: 2 Time : O(n) Space: O(n) ''' counter = {} # char -> count for c in word : counter [ c ] = counter . get ( c , 0 ) + 1 candidates = set ([ c for c in word ]) for c in candidates : counter [ c ] -= 1 if counter [ c ] == 0 : counter . pop ( c ) # check all other counts are the same with a set if len ( set ( counter . values ())) == 1 : return True counter [ c ] = counter . get ( c , 0 ) + 1 return False class SolutionNope1 : def equalFrequency ( self , word : str ) -> bool : ''' Here we try to approach this by getting all the different frequencies Assumed that the True answer has only 2 frequencies and calculate the relationship there. There too many edges cases to consider, and this doesn't work. eg should be True: \"abcc\" \"bac\" \"abbcc\" \"zz\" Time : O(n) Space: O(n) ''' counts = {} # char -> count for c in word : counts [ c ] = counts . get ( c , 0 ) + 1 freq = {} # count -> count of count for _char , count in counts . items (): freq [ count ] = freq . get ( count , 0 ) + 1 # case \"bac\", but not \"aazz\" if len ( freq ) == 1 : [ k ] = freq . keys () return k == 1 # otherwise should have 2 freqences if len ( freq ) != 2 : return False # get the 2 counts, with a as the bigger one [ a , b ] = freq . keys () a , b = max ( a , b ), min ( a , b ) return a - 1 == b and freq [ a ] == 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2423_remove-letter-to-equalize-frequency.html","loc":"https://tofucode.com/posts/leetcode_2423_remove-letter-to-equalize-frequency.html"},{"title":"Leetcode 2414. Length of the Longest Alphabetical Continuous Substring","text":"Question Link : https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/ Difficulty: Medium Question An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string \"abcdefghijklmnopqrstuvwxyz\". For example, \"abc\" is an alphabetical continuous string, while \"acb\" and \"za\" are not. Given a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring. Example 1: Input: s = \"abacaba\" Output: 2 Explanation: There are 4 distinct continuous substrings: \"a\", \"b\", \"c\" and \"ab\". \"ab\" is the longest continuous substring. Example 2: Input: s = \"abcde\" Output: 5 Explanation: \"abcde\" is the longest continuous substring. Constraints: 1 <= s.length <= 105 s consists of only English lowercase letters. Solution We can either use a pointer or a stack to track the current continuous string. Code ''' Leetcode 2414. Length of the Longest Alphabetical Continuous Substring Question Link : https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/ Solution Link : https://tofucode.com/posts/leetcode_2414_length-of-the-longest-alphabetical-continuous-substring.html ''' class Solution : def longestContinuousSubstring ( self , s : str ) -> int : ''' abacaba stack: check if last one is in order [ab] ab a c ab a loop, return max abacaba i s abacaba si Time : O(n) Space: O(1) ''' if not s : return 0 result = 1 # start with the first char start = 0 # the start of the string, s[start, i] is the current string for i in range ( 1 , len ( s )): c = s [ i ] last = s [ i - 1 ] if ( ord ( c ) - ord ( last )) == 1 : result = max ( result , i + 1 - start ) else : start = i return result class SolutionAlternative1 : def longestContinuousSubstring ( self , s : str ) -> int : ''' abacaba [ab] stack: store in order string. check if last one is in order Time : O(n) Space: O(n) ''' if not s : return 0 stack = [] result = 0 for c in s : if not stack : stack . append ( c ) else : last = stack [ - 1 ] if ord ( c ) - ord ( last ) != 1 : stack = [] stack . append ( c ) result = max ( result , len ( stack )) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2414_length-of-the-longest-alphabetical-continuous-substring.html","loc":"https://tofucode.com/posts/leetcode_2414_length-of-the-longest-alphabetical-continuous-substring.html"},{"title":"Leetcode 2404. Most Frequent Even Element","text":"Question Link : https://leetcode.com/problems/most-frequent-even-element/ Difficulty: Easy Question Given an integer array nums, return the most frequent even element. If there is a tie, return the smallest one. If there is no such element, return -1. Example 1: Input: nums = [0,1,2,2,4,4,1] Output: 2 Explanation: The even elements are 0, 2, and 4. Of these, 2 and 4 appear the most. We return the smallest one, which is 2. Example 2: Input: nums = [4,4,4,9,2,4] Output: 4 Explanation: 4 is the even element appears the most. Example 3: Input: nums = [29,47,21,41,13,37,25,7] Output: -1 Explanation: There is no even element. Constraints: 1 <= nums.length <= 2000 0 <= nums[i] <= 105 Solution Count and a sort. Code ''' Leetcode 2404. Most Frequent Even Element Question Link : https://leetcode.com/problems/most-frequent-even-element/ Solution Link : https://tofucode.com/posts/leetcode_2404_most-frequent-even-element.html ''' class Solution : def mostFrequentEven ( self , nums : List [ int ]) -> int : ''' dict of even num -> count sort by count, return smallest num Time : O(n) Space: O(n) ''' counts = {} # even num -> count for num in nums : if num % 2 == 0 : counts [ num ] = counts . get ( num , 0 ) + 1 if not counts : return - 1 # most count, smallest num: sort by reversed count, than the number itself sorted_nums = sorted ( counts . items (), key = lambda x : ( - x [ 1 ], x [ 0 ])) return sorted_nums [ 0 ][ 0 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2404_most-frequent-even-element.html","loc":"https://tofucode.com/posts/leetcode_2404_most-frequent-even-element.html"},{"title":"Leetcode 2413. Smallest Even Multiple","text":"Question Link : https://leetcode.com/problems/smallest-even-multiple/ Difficulty: Easy Question Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n. Example 1: Input: n = 5 Output: 10 Explanation: The smallest multiple of both 5 and 2 is 10. Example 2: Input: n = 6 Output: 6 Explanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself. Constraints: 1 <= n <= 150 Solution Think about the differnt cases, and find the common pattern for n. Code ''' Leetcode 2413. Smallest Even Multiple Question Link : https://leetcode.com/problems/smallest-even-multiple/ Solution Link : https://tofucode.com/posts/leetcode_2413_smallest-even-multiple.html ''' class Solution : def smallestEvenMultiple ( self , n : int ) -> int : ''' 1,2 : return 2 n % 2 == 0 return n else return n * 2 - always even Time : O(1) Space: O(1) ''' if n <= 2 : return 2 if n % 2 == 0 : return n return n * 2","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2413_smallest-even-multiple.html","loc":"https://tofucode.com/posts/leetcode_2413_smallest-even-multiple.html"},{"title":"Leetcode 0901. Online Stock Span","text":"Question Link : https://leetcode.com/problems/online-stock-span/ Difficulty: Medium Question Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day. The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100,80,60,70,60,75,85], then the stock spans would be [1,1,1,2,1,4,6]. Implement the StockSpanner class: StockSpanner() Initializes the object of the class. int next(int price) Returns the span of the stock's price given that today's price is price. Example 1: Input [\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"] [[], [100], [80], [60], [70], [60], [75], [85]] Output [null, 1, 1, 1, 2, 1, 4, 6] Explanation StockSpanner stockSpanner = new StockSpanner(); stockSpanner.next(100); // return 1 stockSpanner.next(80); // return 1 stockSpanner.next(60); // return 1 stockSpanner.next(70); // return 2 stockSpanner.next(60); // return 1 stockSpanner.next(75); // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price. stockSpanner.next(85); // return 6 Constraints: 1 <= price <= 105 At most 104 calls will be made to next. Solution Since we need to keep checking back, we can use a stack, we also need to store how many smaller prices before are seen at each price, so we can use a tuple. Here we have a monotonic stack that is decreasing in price, and with each price, we store the span. Code ''' Leetcode 0901. Online Stock Span Question Link : https://leetcode.com/problems/online-stock-span/ Solution Link : https://tofucode.com/posts/leetcode_0901_online-stock-span.html ''' class StockSpanner : ''' 1: 100 1: 100 80 1: 100 80 60 2: 100 80 60 70 (60 and 70) 1: 100 80 60 70 60 4: 100 80 60 70 60 75 (60 70 60 75) stack keep checking back [(price, span count)] remove all that are smaller than the current price and add +1 monotonic decreasing stack 1: (100, 1) 1: (100, 1), (80, 1) 1: (100, 1), (80, 1), (60, 1) 2: (100, 1), (80, 1), (70, 2) 1: (100, 1), (80, 1), (70, 2), (60, 1) 4: (100, 1), (80, 1), (75, 4) 4 is: (2 + 1 + 1) Time : O(1) Space: O(n) ''' def __init__ ( self ): self . stack = [] def next ( self , price : int ) -> int : count = 1 while self . stack and self . stack [ - 1 ][ 0 ] <= price : count += self . stack . pop ()[ 1 ] self . stack . append (( price , count )) return count # Your StockSpanner object will be instantiated and called as such: # obj = StockSpanner() # param_1 = obj.next(price)","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0901_online-stock-span.html","loc":"https://tofucode.com/posts/leetcode_0901_online-stock-span.html"},{"title":"Leetcode 2427. Number of Common Factors","text":"Question Link : https://leetcode.com/problems/number-of-common-factors/ Difficulty: Easy Question Given two positive integers a and b, return the number of common factors of a and b. An integer x is a common factor of a and b if x divides both a and b. Example 1: Input: a = 12, b = 6 Output: 4 Explanation: The common factors of 12 and 6 are 1, 2, 3, 6. Example 2: Input: a = 25, b = 30 Output: 2 Explanation: The common factors of 25 and 30 are 1, 5. Constraints: 1 <= a, b <= 1000 Solution Check from 1 to the smallest number. Code ''' Leetcode 2427. Number of Common Factors Question Link : https://leetcode.com/problems/number-of-common-factors/ Solution Link : https://tofucode.com/posts/leetcode_2427_number-of-common-factors.html ''' class Solution : def commonFactors ( self , a : int , b : int ) -> int : ''' for loop 1 to min(a,b) and count Time : O(1) Space: O(1) ''' result = 0 for i in range ( 1 , min ( a , b ) + 1 ): if a % i == 0 and b % i == 0 : result += 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2427_number-of-common-factors.html","loc":"https://tofucode.com/posts/leetcode_2427_number-of-common-factors.html"},{"title":"Leetcode 2437. Number of Valid Clock Times","text":"Question Link : https://leetcode.com/problems/number-of-valid-clock-times/ Difficulty: Easy Question You are given a string of length 5 called time, representing the current time on a digital clock in the format \"hh:mm\". The earliest possible time is \"00:00\" and the latest possible time is \"23:59\". In the string time, the digits represented by the ? symbol are unknown, and must be replaced with a digit from 0 to 9. Return an integer answer, the number of valid clock times that can be created by replacing every ? with a digit from 0 to 9. Example 1: Input: time = \"?5:00\" Output: 2 Explanation: We can replace the ? with either a 0 or 1, producing \"05:00\" or \"15:00\". Note that we cannot replace it with a 2, since the time \"25:00\" is invalid. In total, we have two choices. Example 2: Input: time = \"0?:0?\" Output: 100 Explanation: Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices. Example 3: Input: time = \"??:??\" Output: 1440 Explanation: There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 * 60 = 1440 choices. Constraints: time is a valid string of length 5 in the format \"hh:mm\". \"00\" <= hh <= \"23\" \"00\" <= mm <= \"59\" Some of the digits might be replaced with '?' and need to be replaced with digits from 0 to 9. Solution Each digit can be a question mark, but each digit has different restriction, we can analyze the different cases, and the result would be the mutiplicqtion of all ?s. Code ''' Leetcode 2437. Number of Valid Clock Times Question Link : https://leetcode.com/problems/number-of-valid-clock-times/ Solution Link : https://tofucode.com/posts/leetcode_2437_number-of-valid-clock-times.html ''' class Solution : def countTime ( self , time : str ) -> int : ''' ab:cd Restriction on a b, how many valid number each place can have 1. a is 0 or 1, b can be all 10 numbers a: 2 (0 1) b: 10 (0-9) c: 6 (0-5) d: 10 (0-9) 2. a is 2, b has to be < 4 a: is 2 b: 4 (0 1 2 3) cd same Time : O(1) Space: O(1) ''' result = 1 a , b , c , d = time [ 0 ], time [ 1 ], time [ 3 ], time [ 4 ] if a == '?' and b == '?' : result *= 24 elif a == '?' and b != '?' : if int ( b ) >= 4 : result *= 2 else : result *= 3 elif a != '?' and b == '?' : if int ( a ) == 2 : result *= 4 else : result *= 10 if c == '?' : result *= 6 if d == '?' : result *= 10 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2437_number-of-valid-clock-times.html","loc":"https://tofucode.com/posts/leetcode_2437_number-of-valid-clock-times.html"},{"title":"Leetcode 2460. Apply Operations to an Array","text":"Question Link : https://leetcode.com/problems/apply-operations-to-an-array/ Difficulty: Easy Question You are given a 0-indexed array nums of size n consisting of non-negative integers. You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums: If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation. After performing all the operations, shift all the 0's to the end of the array. For example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0]. Return the resulting array. Note that the operations are applied sequentially, not all at once. Example 1: Input: nums = [1,2,2,1,1,0] Output: [1,4,2,0,0,0] Explanation: We do the following operations: - i = 0: nums[0] and nums[1] are not equal, so we skip this operation. - i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0]. - i = 2: nums[2] and nums[3] are not equal, so we skip this operation. - i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0]. - i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0]. After that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0]. Example 2: Input: nums = [0,1] Output: [1,0] Explanation: No operation can be applied, we just shift the 0 to the end. Constraints: 2 <= nums.length <= 2000 0 <= nums[i] <= 1000 Solution First go through the array and apply the operation. Second use two pointers with an anchor p to shift the zeros. Code ''' Leetcode 2460. Apply Operations to an Array Question Link : https://leetcode.com/problems/apply-operations-to-an-array/ Solution Link : https://tofucode.com/posts/leetcode_2460_apply-operations-to-an-array.html ''' class Solution : def applyOperations ( self , nums : List [ int ]) -> List [ int ]: ''' 1,2,2,1,1,0 1,4,0,1,1,0 1,4,0,2,0,0 1,4,2,0,0,0 2 loops, in place Time : O(n) Space: O(1) ''' for i in range ( len ( nums ) - 1 ): a = nums [ i ] b = nums [ i + 1 ] if a == b : nums [ i ] *= 2 nums [ i + 1 ] = 0 p = 0 for i in range ( len ( nums )): if nums [ i ] != 0 : nums [ i ], nums [ p ] = nums [ p ], nums [ i ] p += 1 return nums","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2460_apply-operations-to-an-array.html","loc":"https://tofucode.com/posts/leetcode_2460_apply-operations-to-an-array.html"},{"title":"Leetcode 1544. Make The String Great","text":"Question Link : https://leetcode.com/problems/make-the-string-great/ Difficulty: Easy Question Given a string s of lower and upper case English letters. A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where: 0 <= i <= s.length - 2 s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa. To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good. Return the string after making it good. The answer is guaranteed to be unique under the given constraints. Notice that an empty string is also good. Example 1: Input: s = \"leEeetcode\" Output: \"leetcode\" Explanation: In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\". Example 2: Input: s = \"abBAcC\" Output: \"\" Explanation: We have many possible scenarios, and all lead to the same answer. For example: \"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\" \"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\" Example 3: Input: s = \"s\" Output: \"s\" Constraints: 1 <= s.length <= 100 s contains only lower and upper case English letters. Solution Use a stack so we can check back and deviced if a pair needs to be removed. Code ''' Leetcode 1544. Make The String Great Question Link : https://leetcode.com/problems/make-the-string-great/ Solution Link : https://tofucode.com/posts/leetcode_1544_make-the-string-great.html ''' class Solution : def makeGood ( self , s : str ) -> str : ''' abBA if we remove bB, it will leave aA stack like closing prethesis remove when bB, aA, return what's left for abBAcC: a ab a _ c _ Time : O(n) Sapce: O(n) ''' stack = [] for c in s : if not stack or not self . sameCharDiffCase ( stack [ - 1 ], c ): stack . append ( c ) else : stack . pop () return '' . join ( stack ) def sameCharDiffCase ( self , a , b ): return a . isupper () and a . lower () == b or b . isupper () and b . lower () == a","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1544_make-the-string-great.html","loc":"https://tofucode.com/posts/leetcode_1544_make-the-string-great.html"},{"title":"Leetcode 2441. Largest Positive Integer That Exists With Its Negative","text":"Question Link : https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/ Difficulty: Easy Question Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array. Return the positive integer k. If there is no such integer, return -1. Example 1: Input: nums = [-1,2,-3,3] Output: 3 Explanation: 3 is the only valid k we can find in the array. Example 2: Input: nums = [-1,10,6,7,-7,1] Output: 7 Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value. Example 3: Input: nums = [-10,8,6,7,-2,-3] Output: -1 Explanation: There is no a single valid k, we return -1. Constraints: 1 <= nums.length <= 1000 -1000 <= nums[i] <= 1000 nums[i] != 0 Solution Can use two pointers with a sort or go though it and check the curernt number with a set. Code ''' Leetcode 2441. Largest Positive Integer That Exists With Its Negative Question Link : https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/ Solution Link : https://tofucode.com/posts/leetcode_2441_largest-positive-integer-that-exists-with-its-negative.html ''' class Solution : def findMaxK ( self , nums : List [ int ]) -> int : ''' set of all numbers Go through nums and mark the biggest that have -k in there as well Time : O(n) Space: O(n) ''' result = - 1 all_nums = set ( nums ) for num in nums : if num > result and - num in all_nums : result = num return result class SolutionAlternative1 : def findMaxK ( self , nums : List [ int ]) -> int : ''' set of all numbers Go through nums and mark the biggest that have -k in there as well Time : O(n log n) Space: O(1) ''' l = 0 r = len ( nums ) - 1 all_nums = sorted ( nums ) while l < r : s = all_nums [ l ] + all_nums [ r ] if s == 0 : return all_nums [ r ] elif s < 0 : l += 1 else : r -= 1 return - 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2441_largest-positive-integer-that-exists-with-its-negative.html","loc":"https://tofucode.com/posts/leetcode_2441_largest-positive-integer-that-exists-with-its-negative.html"},{"title":"Leetcode 2451. Odd String Difference","text":"Question Link : https://leetcode.com/problems/odd-string-difference/ Difficulty: Easy Question You are given an array of equal-length strings words. Assume that the length of each string is n. Each string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z' is 25. For example, for the string \"acb\", the difference integer array is [2 - 0, 1 - 2] = [2, -1]. All the strings in words have the same difference integer array, except one. You should find that string. Return the string in words that has different difference integer array. Example 1: Input: words = [\"adc\",\"wzy\",\"abc\"] Output: \"abc\" Explanation: - The difference integer array of \"adc\" is [3 - 0, 2 - 3] = [3, -1]. - The difference integer array of \"wzy\" is [25 - 22, 24 - 25]= [3, -1]. - The difference integer array of \"abc\" is [1 - 0, 2 - 1] = [1, 1]. The odd array out is [1, 1], so we return the corresponding string, \"abc\". Example 2: Input: words = [\"aaa\",\"bob\",\"ccc\",\"ddd\"] Output: \"bob\" Explanation: All the integer arrays are [0, 0] except for \"bob\", which corresponds to [13, -13]. Constraints: 3 <= words.length <= 100 n == words[i].length 2 <= n <= 20 words[i] consists of lowercase English letters. Solution Since there is only one that is different, we can set the first one as the target, and compare all others against the first one. Code ''' Leetcode 2451. Odd String Difference Question Link : https://leetcode.com/problems/odd-string-difference/ Solution Link : https://tofucode.com/posts/leetcode_2451_odd-string-difference.html ''' class Solution : A_ORD = ord ( 'a' ) def oddString ( self , words : List [ str ]) -> str : ''' Mark the first one as target, if we get a different one, set as suspect if have suspect: if current == suspect: return target else current == target: return suspect else: set suspect Time : O(n) Space: O(1) ''' t_word , target = self . getDiffArray ( words [ 0 ]) s_word = suspect = None for i in range ( 1 , len ( words )): word = words [ i ] _w , current = self . getDiffArray ( word ) if suspect : if current == suspect : return t_word if current == target : return s_word elif current != target : s_word , suspect = word , current return s_word def getDiffArray ( self , word ): ''' given a string, return the diff array ''' result = [] for i in range ( 1 , len ( word )): a = word [ i - 1 ] b = word [ i ] result . append (( ord ( b ) - Solution . A_ORD ) - ( ord ( a ) - Solution . A_ORD )) return ( word , result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2451_odd-string-difference.html","loc":"https://tofucode.com/posts/leetcode_2451_odd-string-difference.html"},{"title":"Leetcode 2456. Most Popular Video Creator","text":"Question Link : https://leetcode.com/problems/most-popular-video-creator/ Difficulty: Medium Question You are given two string arrays creators and ids, and an integer array views, all of length n. The ith video on a platform was created by creator[i], has an id of ids[i], and has views[i] views. The popularity of a creator is the sum of the number of views on all of the creator's videos. Find the creator with the highest popularity and the id of their most viewed video. If multiple creators have the highest popularity, find all of them. If multiple videos have the highest view count for a creator, find the lexicographically smallest id. Return a 2D array of strings answer where answer[i] = [creatori, idi] means that creatori has the highest popularity and idi is the id of their most popular video. The answer can be returned in any order. Example 1: Input: creators = [\"alice\",\"bob\",\"alice\",\"chris\"], ids = [\"one\",\"two\",\"three\",\"four\"], views = [5,10,5,4] Output: [[\"alice\",\"one\"],[\"bob\",\"two\"]] Explanation: The popularity of alice is 5 + 5 = 10. The popularity of bob is 10. The popularity of chris is 4. alice and bob are the most popular creators. For bob, the video with the highest view count is \"two\". For alice, the videos with the highest view count are \"one\" and \"three\". Since \"one\" is lexicographically smaller than \"three\", it is included in the answer. Example 2: Input: creators = [\"alice\",\"alice\",\"alice\"], ids = [\"a\",\"b\",\"c\"], views = [1,2,2] Output: [[\"alice\",\"b\"]] Explanation: The videos with id \"b\" and \"c\" have the highest view count. Since \"b\" is lexicographically smaller than \"c\", it is included in the answer. Constraints: n == creators.length == ids.length == views.length 1 <= n <= 105 1 <= creators[i].length, ids[i].length <= 5 creators[i] and ids[i] consist only of lowercase English letters. 0 <= views[i] <= 105 Solution We need to store all of the given info: name, id, view number, as well as the total popularity. We can do this with hashmap. Also much clearer with a new class. Code ''' Leetcode 2456. Most Popular Video Creator Question Link : https://leetcode.com/problems/most-popular-video-creator/ Solution Link : https://tofucode.com/posts/leetcode_2456_most-popular-video-creator.html ''' class Solution : def mostPopularCreator ( self , creators : List [ str ], ids : List [ str ], views : List [ int ]) -> List [ List [ str ]]: ''' popularity = sum (all views on all video) 1 loop: person -> views 2 loop: need sum of views - find top 3 loop: get all people with top reviews. sort based on views people = {} # name -> (popularity, [(sorted view, index)]) Time : O(n) Space: O(n) ''' people = {} # name -> (popularity, [(sorted view, index)]) for i in range ( len ( creators )): name = creators [ i ] vid = ids [ i ] v = views [ i ] people [ name ] = people . get ( name , []) + [( v , vid )] for name , view_list in people . items (): popularity = sum ([ x [ 0 ] for x in view_list ]) people [ name ] = ( popularity , people [ name ]) # sort by popularity, x[1] is the value, x[1][0] is popularity sorted_people = sorted ( people . items (), key = lambda x : x [ 1 ][ 0 ], reverse = True ) max_pop = sorted_people [ 0 ][ 1 ][ 0 ] # for only the top popularity, write the name and id to answer result = [] for person in sorted_people : if person [ 1 ][ 0 ] != max_pop : break view_list = person [ 1 ][ 1 ] # sort by view, negative so views are big to same, and then ids are lexicographical order view_list = sorted ( view_list , key = lambda x : ( - x [ 0 ], x [ 1 ])) result . append ([ person [ 0 ], view_list [ 0 ][ 1 ]]) return result class Creator : def __init__ ( self , name ): self . name = name self . view_list = [] # (view, id) self . popularity = None def addVideo ( self , view , vid ): self . view_list . append (( view , vid )) def getPopularity ( self ): if self . popularity : return self . popularity self . popularity = sum ([ x [ 0 ] for x in self . view_list ]) return self . popularity def getTopVideoWithName ( self ): # sort by view, negative so views are big to small, and then ids are lexicographical order view_list = sorted ( self . view_list , key = lambda x : ( - x [ 0 ], x [ 1 ])) return [ self . name , view_list [ 0 ][ 1 ]] class SolutionImproved1 : def mostPopularCreator ( self , creators : List [ str ], ids : List [ str ], views : List [ int ]) -> List [ List [ str ]]: ''' popularity = sum (all views on all video) Creator: name view_list popularity Time : O(n) Space: O(n) ''' people = {} # name -> creator for i in range ( len ( creators )): name = creators [ i ] vid = ids [ i ] v = views [ i ] person = people . get ( name , Creator ( name )) person . addVideo ( v , vid ) people [ name ] = person # sort by popularity, sorted_people = sorted ( people . items (), key = lambda x : x [ 1 ] . getPopularity (), reverse = True ) max_pop = sorted_people [ 0 ][ 1 ] . getPopularity () # for only the top popularity, write the name and id to answer result = [] for person in sorted_people : if person [ 1 ] . getPopularity () != max_pop : break result . append ( person [ 1 ] . getTopVideoWithName ()) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2456_most-popular-video-creator.html","loc":"https://tofucode.com/posts/leetcode_2456_most-popular-video-creator.html"},{"title":"Leetcode 2455. Average Value of Even Numbers That Are Divisible by Three","text":"Question Link : https://leetcode.com/problems/average-value-of-even-numbers-that-are-divisible-by-three/ Difficulty: Easy Question Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3. Note that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer. Example 1: Input: nums = [1,3,6,10,12,15] Output: 9 Explanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9. Example 2: Input: nums = [1,2,4,7,10] Output: 0 Explanation: There is no single number that satisfies the requirement, so return 0. Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 1000 Solution Go through nums and get the total and the count. Code ''' Leetcode 2455. Average Value of Even Numbers That Are Divisible by Three Question Link : https://leetcode.com/problems/average-value-of-even-numbers-that-are-divisible-by-three/ Solution Link : https://tofucode.com/posts/leetcode_2455_average-value-of-even-numbers-that-are-divisible-by-three.html ''' class Solution : def averageValue ( self , nums : List [ int ]) -> int : ''' even is / 2 / 3 so / 6 Time : O(n) Space: O(1) ''' total = 0 count = 0 for num in nums : if num % 6 == 0 : total += num count += 1 return total // count if count else 0","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2455_average-value-of-even-numbers-that-are-divisible-by-three.html","loc":"https://tofucode.com/posts/leetcode_2455_average-value-of-even-numbers-that-are-divisible-by-three.html"},{"title":"Leetcode 0283. Move Zeroes","text":"Question Link : https://leetcode.com/problems/move-zeroes/ Difficulty: Easy Question Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Example 1: Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2: Input: nums = [0] Output: [0] Constraints: 1 <= nums.length <= 104 -231 <= nums[i] <= 231 - 1 Follow up: Could you minimize the total number of operations done? Solution Use a pointer as anchor for the left most zero, and use another pointer to iterate Code ''' Leetcode 0283. Move Zeroes Question Link : https://leetcode.com/problems/move-zeroes/ Solution Link : https://tofucode.com/posts/leetcode_0283_move-zeroes.html ''' class Solution : def moveZeroes ( self , nums : List [ int ]) -> None : \"\"\" Do not return anything, modify nums in-place instead. \"\"\" ''' p: gets anchored as the left most 0 so when we get to a non zero, we can swap p and i start p at 0 is fine cause the first one if not zero will not do anything and just p +=1 i p 0 0 [2, 1, 0, 3, 12] swaped 1 1 [2, 1, 0, 3, 12] swaped 2 2 [2, 1, 0, 3, 12] nothing, i is at 0 3 2 [2, 1, 3, 0, 12] swaped, p + 1 to 3 4 3 [2, 1, 3, 12, 0] swaped Time : O(n) Space: O(1) ''' p = 0 # last zero position for i in range ( len ( nums )): if nums [ i ] != 0 : nums [ i ], nums [ p ] = nums [ p ], nums [ i ] p += 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0283_move-zeroes.html","loc":"https://tofucode.com/posts/leetcode_0283_move-zeroes.html"},{"title":"Leetcode 0345. Reverse Vowels of a String","text":"Question Link : https://leetcode.com/problems/reverse-vowels-of-a-string/ Difficulty: Easy Question Given a string s, reverse only all the vowels in the string and return it. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once. Example 1: Input: s = \"hello\" Output: \"holle\" Example 2: Input: s = \"leetcode\" Output: \"leotcede\" Constraints: 1 <= s.length <= 3 * 105 s consist of printable ASCII characters. Solution Use 2 pointers to go outside in and swap when needed. Code ''' Leetcode 0345. Reverse Vowels of a String Question Link : https://leetcode.com/problems/reverse-vowels-of-a-string/ Solution Link : https://tofucode.com/posts/leetcode_0345_reverse-vowels-of-a-string.html ''' class Solution : def reverseVowels ( self , s : str ) -> str : ''' hello l r l r - swap Time : O(n) Space: O(n) ''' vowels = set ([ c for c in 'aeiouAEIOU' ]) result = [ c for c in s ] l = 0 r = len ( s ) - 1 while l < r : while l < r and not result [ l ] in vowels : l += 1 while l < r and not result [ r ] in vowels : r -= 1 result [ l ], result [ r ] = result [ r ], result [ l ] l += 1 r -= 1 return '' . join ( result ) class SolutionAlternative1 : def reverseVowels ( self , s : str ) -> str : ''' Go through and get the vowels, and mark the positions with None, Use another loop to add the vowels back in in reverse order Time : O(n) Space: O(n) ''' if not s : return s result = [] vowels = set ([ c for c in 'aeiouAEIOU' ]) v = '' for c in s : if c in vowels : v += c result . append ( None ) else : result . append ( c ) v = v [:: - 1 ] idx = 0 for i in range ( len ( s )): c = s [ i ] if c in vowels : result [ i ] = v [ idx ] idx += 1 return '' . join ( result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0345_reverse-vowels-of-a-string.html","loc":"https://tofucode.com/posts/leetcode_0345_reverse-vowels-of-a-string.html"},{"title":"Leetcode 2131. Longest Palindrome by Concatenating Two Letter Words","text":"Question Link : https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/ Difficulty: Medium Question You are given an array of strings words. Each element of words consists of two lowercase English letters. Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once. Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0. A palindrome is a string that reads the same forward and backward. Example 1: Input: words = [\"lc\",\"cl\",\"gg\"] Output: 6 Explanation: One longest palindrome is \"lc\" + \"gg\" + \"cl\" = \"lcggcl\", of length 6. Note that \"clgglc\" is another longest palindrome that can be created. Example 2: Input: words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"] Output: 8 Explanation: One longest palindrome is \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\", of length 8. Note that \"lcyttycl\" is another longest palindrome that can be created. Example 3: Input: words = [\"cc\",\"ll\",\"xx\"] Output: 2 Explanation: One longest palindrome is \"cc\", of length 2. Note that \"ll\" is another longest palindrome that can be created, and so is \"xx\". Constraints: 1 <= words.length <= 105 words[i].length == 2 words[i] consists of lowercase English letters. Solution Identify the ways that the 2 letter words can be used to form a palindrome, keep a word to count map. go through the words list and match the pairs. This can be done in either one iteration or two iterations. Code ''' Leetcode 2131. Longest Palindrome by Concatenating Two Letter Words Question Link : https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/ Solution Link : https://tofucode.com/posts/leetcode_2131_longest-palindrome-by-concatenating-two-letter-words.html ''' class Solution : def longestPalindrome ( self , words : List [ str ]) -> int : ''' [\"lc\",\"cl\",\"gg\"] \"lc\" + \"gg\" + \"cl\" Each word is 2 chars either : aa OR ab build word counts word -> count lc: 1 cl: 1 gg: 1 go through words count again: diff char words: check if mirror exits, for every pair +4 char same char words: even number: can be added to both end, every pair +4 char odd number: can be added to the center - only 1, check at very end Time : O(n) Space: O(n) ''' counts = {} # word -> count for word in words : counts [ word ] = counts . get ( word , 0 ) + 1 print ( counts ) result = 0 remains_same_char_word = False for word , num in counts . items (): if word [ 0 ] != word [ 1 ]: reverse = word [ 1 ] + word [ 0 ] if reverse in counts : matches = min ( num , counts [ reverse ]) counts [ word ] = counts [ word ] - matches counts [ reverse ] = counts [ reverse ] - matches result += matches * 4 else : # every pair * 4 result += ( num // 2 ) * 4 if num % 2 != 0 : remains_same_char_word = True if remains_same_char_word : result += 2 return result class SolutionImproved1 : def longestPalindrome ( self , words : List [ str ]) -> int : ''' Do this in one loop: check as we go When there is a reverse, just need to -1 for the reverse remaining_same_char_word needs to be changed to a count Time : O(n) Space: O(n) ''' counts = {} # word -> count result = 0 remaining_same_char_word = 0 for word in words : if word [ 0 ] != word [ 1 ]: reverse = word [ 1 ] + word [ 0 ] if counts . get ( reverse , 0 ) > 0 : counts [ reverse ] -= 1 result += 4 else : counts [ word ] = counts . get ( word , 0 ) + 1 else : if counts . get ( word , 0 ) > 0 : counts [ word ] -= 1 result += 4 remaining_same_char_word -= 1 else : counts [ word ] = counts . get ( word , 0 ) + 1 remaining_same_char_word += 1 if remaining_same_char_word : result += 2 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2131_longest-palindrome-by-concatenating-two-letter-words.html","loc":"https://tofucode.com/posts/leetcode_2131_longest-palindrome-by-concatenating-two-letter-words.html"},{"title":"Leetcode 0206. Reverse Linked List","text":"Question Link : https://leetcode.com/problems/reverse-linked-list/ Difficulty: Easy Question Given the head of a singly linked list, reverse the list, and return the reversed list. Example 1: Input: head = [1,2,3,4,5] Output: [5,4,3,2,1] Example 2: Input: head = [1,2] Output: [2,1] Example 3: Input: head = [] Output: [] Constraints: The number of nodes in the list is the range [0, 5000]. -5000 <= Node.val <= 5000 Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? Solution Best solution is to do it in place with a temp pointer. We can use it to store p.next, reverse current, and then update p. Code ''' Leetcode 0206. Reverse Linked List Question Link : https://leetcode.com/problems/reverse-linked-list/ Solution Link : https://tofucode.com/posts/leetcode_0206_reverse-linked-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def reverseList ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: ''' [1,2,3,4,5] 1 <- 2 <- 3 For 2 <- 3: p at 2 last at 1 temp = 3 1. set temp as next one of p 2. point back 2 <- 3: last <- p.next 3. update last: last = 2 4. update p: p = temp Time : O(n) Space: O(1) ''' p = head last = None while p : # store p.next temp = p . next p . next = last last = p # update p p = temp return last class SolutionNaive1 : def reverseList ( self , head : ListNode ) -> ListNode : ''' Iteratively: Use a list to go through the list and store the nodes, then go back and link them Time : O(n) Space: O(n) ''' if not head : return head l = [] p = head while p : l . append ( p ) p = p . next p = l . pop () start = p while len ( l ) != 0 : node = l . pop () p . next = node p = node p . next = None return start","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0206_reverse-linked-list.html","loc":"https://tofucode.com/posts/leetcode_0206_reverse-linked-list.html"},{"title":"Leetcode 0234. Palindrome Linked List","text":"Question Link : https://leetcode.com/problems/palindrome-linked-list/ Difficulty: Easy Question Given the head of a singly linked list, return true if it is a palindrome or false otherwise. Example 1: Input: head = [1,2,2,1] Output: true Example 2: Input: head = [1,2] Output: false Constraints: The number of nodes in the list is in the range [1, 105]. 0 <= Node.val <= 9 Follow up: Could you do it in O(n) time and O(1) space? Solution Best solution is to use fast slow pointer to find the mid point, and then expand from the center to check equal. Naive solution would be traverse the whole list and store everything down and compare. Code ''' Leetcode 0234. Palindrome Linked List Question Link : https://leetcode.com/problems/palindrome-linked-list/ Solution Link : https://tofucode.com/posts/leetcode_0234_palindrome-linked-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def isPalindrome ( self , head : Optional [ ListNode ]) -> bool : ''' Use slow, fast pointers to get to the middle of the list, and then from the center go to both directions and if equal Time : O(n) Space: O(1) ''' slow = fast = head back = None while fast and fast . next : fast = fast . next . next # reverse slow . next , back , slow = back , slow , slow . next # if it's odd, slow goes past middle to the next one if fast : slow = slow . next # slow keeps going forward and back goes back while back : if back . val != slow . val : return False back = back . next slow = slow . next return True # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class SolutionNaive1 : def isPalindrome ( self , head : Optional [ ListNode ]) -> bool : ''' Use a list to store the path of values and check if that list is a palindrome Time : O(n) Space: O(n) ''' if not head : return True l = [] p = head while p is not None : l . append ( p . val ) p = p . next return l == l [:: - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0234_palindrome-linked-list.html","loc":"https://tofucode.com/posts/leetcode_0234_palindrome-linked-list.html"},{"title":"Leetcode 0226. Invert Binary Tree","text":"Question Link : https://leetcode.com/problems/invert-binary-tree/ Difficulty: Easy Question Given the root of a binary tree, invert the tree, and return its root. Example 1: Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] Example 2: Input: root = [2,1,3] Output: [2,3,1] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 100]. -100 <= Node.val <= 100 Solution Do a flip at every node. Remember to check None Code ''' Leetcode 0226. Invert Binary Tree Question Link : https://leetcode.com/problems/invert-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0226_invert-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def invertTree ( self , root : Optional [ TreeNode ]) -> Optional [ TreeNode ]: ''' For every node do an invert Time : O(n) Space: O(n) ''' if not root : return None root . left , root . right = self . invertTree ( root . right ), self . invertTree ( root . left ) return root","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0226_invert-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0226_invert-binary-tree.html"},{"title":"Leetcode 0543. Diameter of Binary Tree","text":"Question Link : https://leetcode.com/problems/diameter-of-binary-tree/ Difficulty: Easy Question Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them. Example 1: Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3]. Example 2: Input: root = [1,2] Output: 1 Constraints: The number of nodes in the tree is in the range [1, 104]. -100 <= Node.val <= 100 Solution Go through the whole tree and keep track of the max (left depth + right depth). Note the anwser does not need to pass the original root node so we can't only calculate depth sum of root.left and root.right. Code ''' Leetcode 0543. Diameter of Binary Tree Question Link : https://leetcode.com/problems/diameter-of-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0543_diameter-of-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def diameterOfBinaryTree ( self , root : Optional [ TreeNode ]) -> int : ''' diameter doesn't have to path root node traverse the whole tree and keep returning the max depth, the result would be the max of left max depth + right max depth Time : O(n) Space: O(n) ''' self . result = 0 self . traverse ( root ) return self . result def traverse ( self , node ): ''' max depth ''' if not node : return 0 left = self . traverse ( node . left ) right = self . traverse ( node . right ) self . result = max ( self . result , left + right ) return 1 + max ( left , right )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0543_diameter-of-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0543_diameter-of-binary-tree.html"},{"title":"Leetcode 0049. Group Anagrams","text":"Question Link : https://leetcode.com/problems/group-anagrams/ Difficulty: Medium Question Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] Example 2: Input: strs = [\"\"] Output: [[\"\"]] Example 3: Input: strs = [\"a\"] Output: [[\"a\"]] Constraints: 1 <= strs.length <= 104 0 <= strs[i].length <= 100 strs[i] consists of lowercase English letters. Solution for each we want to count the chars, and the same char count would mean anagrams. Use a hash map to store the char count to word mapping. Code ''' Leetcode 0049. Group Anagrams Question Link : https://leetcode.com/problems/group-anagrams/ Solution Link : https://tofucode.com/posts/leetcode_0049_group-anagrams.html ''' class Solution : def groupAnagrams ( self , strs : List [ str ]) -> List [ List [ str ]]: ''' result = char count string -> [word1, word2] for every word: word: eat 26 count: [1, 0, 0, 0, 1 ...] convert to a string, store in index_map Time : O(nm) n words, m highest length of a wrod Space: O(nm) ''' result = {} # char count string -> [word] for word in strs : count = [ 0 ] * 26 for c in word : count [ ord ( c ) - ord ( 'a' )] += 1 s = str ( count ) result [ s ] = result . get ( s , []) + [ word ] return result . values ()","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0049_group-anagrams.html","loc":"https://tofucode.com/posts/leetcode_0049_group-anagrams.html"},{"title":"Leetcode 0169. Majority Element","text":"Question Link : https://leetcode.com/problems/majority-element/ Difficulty: Easy Question Given an array nums of size n, return the majority element. The majority element is the element that appears more than ân / 2â times. You may assume that the majority element always exists in the array. Example 1: Input: nums = [3,2,3] Output: 3 Example 2: Input: nums = [2,2,1,1,1,2,2] Output: 2 Constraints: n == nums.length 1 <= n <= 5 * 104 -109 <= nums[i] <= 109 Follow-up: Could you solve the problem in linear time and in O(1) space? Solution Either using a hash map to count or boyer-moore-voting-algorithm Code ''' Leetcode 0169. Majority Element Question Link : https://leetcode.com/problems/majority-element/ Solution Link : https://tofucode.com/posts/leetcode_0169_majority-element.html ''' class Solution : def majorityElement ( self , nums : List [ int ]) -> int : ''' loop and count, exit when reachs more than half Time : O(n) Space: O(n) ''' half = len ( nums ) // 2 counts = {} # num -> count for num in nums : counts [ num ] = counts . get ( num , 0 ) + 1 if counts [ num ] > half : return num class SolutionImproved1 : def majorityElement ( self , nums : List [ int ]) -> int : ''' Boyce-Moore Algorithms If we can count +1 for the majority element, and -1 for all otehrs only keep 1 variable to track the count, and +1 if seeing the same one, -1 otherwise, if we reach 0 again: reset the majority element [2,2,1,1,1,2,2] 1 2 This is safe as we are discarding equal number of majority and non majority elements, We can still find the major element from the rest Time : O(n) Space: O(1) ''' count = 0 result = 0 for i in nums : if count == 0 : result = i if i == result : count += 1 else : count -= 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0169_majority-element.html","loc":"https://tofucode.com/posts/leetcode_0169_majority-element.html"},{"title":"Leetcode 1662. Check If Two String Arrays are Equivalent","text":"Question Link : https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/ Difficulty: Easy Question Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise. A string is represented by an array if the array elements concatenated in order forms the string. Example 1: Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"] Output: true Explanation: word1 represents string \"ab\" + \"c\" -> \"abc\" word2 represents string \"a\" + \"bc\" -> \"abc\" The strings are the same, so return true. Example 2: Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"] Output: false Example 3: Input: word1 = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"] Output: true Constraints: 1 <= word1.length, word2.length <= 103 1 <= word1[i].length, word2[i].length <= 103 1 <= sum(word1[i].length), sum(word2[i].length) <= 103 word1[i] and word2[i] consist of lowercase letters. Solution Caculate the 2 words and compare Code ''' Leetcode 1662. Check If Two String Arrays are Equivalent Question Link : https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/ Solution Link : https://tofucode.com/posts/leetcode_1662_check-if-two-string-arrays-are-equivalent.html ''' class Solution : def arrayStringsAreEqual ( self , word1 : List [ str ], word2 : List [ str ]) -> bool : ''' calculate w1, w2, compare the 2 Time : O(n) Space: O(1) ''' w1 = w2 = '' for part in word1 : w1 += part for part in word2 : w2 += part return w1 == w2","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1662_check-if-two-string-arrays-are-equivalent.html","loc":"https://tofucode.com/posts/leetcode_1662_check-if-two-string-arrays-are-equivalent.html"},{"title":"Leetcode 0160. Intersection of Two Linked Lists","text":"Question Link : https://leetcode.com/problems/intersection-of-two-linked-lists/ Difficulty: Easy Question Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. Custom Judge: The inputs to the judge are given as follows (your program is not given these inputs): intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node. listA - The first linked list. listB - The second linked list. skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node. skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node. The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted. Example 1: Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 Output: Intersected at '8' Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. - Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory. Example 2: Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Intersected at '2' Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3: Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: No intersection Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null. Constraints: The number of nodes of listA is in the m. The number of nodes of listB is in the n. 1 <= m, n <= 3 * 104 1 <= Node.val <= 105 0 <= skipA < m 0 <= skipB < n intersectVal is 0 if listA and listB do not intersect. intersectVal == listA[skipA] == listB[skipB] if listA and listB intersect. Follow up: Could you write a solution that runs in O(m + n) time and use only O(1) memory? Solution when one list ends, direct it to the start of the other list, this way the long short list cancels themself out Code ''' Leetcode 0160. Intersection of Two Linked Lists Question Link : https://leetcode.com/problems/intersection-of-two-linked-lists/ Solution Link : https://tofucode.com/posts/leetcode_0160_intersection-of-two-linked-lists.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution : def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> Optional [ ListNode ]: ''' when one list ends, direct it to the start of the other list [4,1,8,4,5] [5,6,1,8,4,5] A: 4,1,8,4,5 | 5,6,1,8,4,5 B: 5,6,1,8,4,5 | 4,1,8,4,5 Both pointer will meet at the intersection if p1 = p2 = None it means after the switch traversal they got to the end and have no intersection ''' if headA is None or headB is None : return None x = headA y = headB while True : if x == y : return x if x is None : x = headB else : x = x . next if y is None : y = headA else : y = y . next","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0160_intersection-of-two-linked-lists.html","loc":"https://tofucode.com/posts/leetcode_0160_intersection-of-two-linked-lists.html"},{"title":"Leetcode 0104. Maximum Depth of Binary Tree","text":"Question Link : https://leetcode.com/problems/maximum-depth-of-binary-tree/ Difficulty: Easy Question Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example 1: Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2: Input: root = [1,null,2] Output: 2 Constraints: The number of nodes in the tree is in the range [0, 104]. -100 <= Node.val <= 100 Solution Use Recursion Code ''' Leetcode 0104. Maximum Depth of Binary Tree Question Link : https://leetcode.com/problems/maximum-depth-of-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0104_maximum-depth-of-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def maxDepth ( self , root : Optional [ TreeNode ]) -> int : ''' Use recursion max(left, right) + 1 Time : O(n) Space: O(n) ''' if root is None : return 0 return max ( self . maxDepth ( root . left ), self . maxDepth ( root . right )) + 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0104_maximum-depth-of-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0104_maximum-depth-of-binary-tree.html"},{"title":"Leetcode 0136. Single Number","text":"Question Link : https://leetcode.com/problems/single-number/ Difficulty: Easy Question Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1: Input: nums = [2,2,1] Output: 1 Example 2: Input: nums = [4,1,2,1,2] Output: 4 Example 3: Input: nums = [1] Output: 1 Constraints: 1 <= nums.length <= 3 * 104 -3 * 104 <= nums[i] <= 3 * 104 Each element in the array appears twice except for one element which appears only once. Solution Any number that XOR it self would cancel itself out. So we can go through nums and xor everything Code ''' Leetcode 0136. Single Number Question Link : https://leetcode.com/problems/single-number/ Solution Link : https://tofucode.com/posts/leetcode_0136_single-number.html ''' class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ''' xor Time : O(n) Space: O(1) ''' result = nums [ 0 ] for i in range ( 1 , len ( nums )): result &#94;= nums [ i ] return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0136_single-number.html","loc":"https://tofucode.com/posts/leetcode_0136_single-number.html"},{"title":"Leetcode 2095. Delete the Middle Node of a Linked List","text":"Question Link : https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/ Difficulty: Medium Question You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list. The middle node of a linked list of size n is the ân / 2âth node from the start using 0-based indexing, where âxâ denotes the largest integer less than or equal to x. For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively. Example 1: Input: head = [1,3,4,7,1,2,6] Output: [1,3,4,1,2,6] Explanation: The above figure represents the given linked list. The indices of the nodes are written below. Since n = 7, node 3 with value 7 is the middle node, which is marked in red. We return the new list after removing this node. Example 2: Input: head = [1,2,3,4] Output: [1,2,4] Explanation: The above figure represents the given linked list. For n = 4, node 2 with value 3 is the middle node, which is marked in red. Example 3: Input: head = [2,1] Output: [2] Explanation: The above figure represents the given linked list. For n = 2, node 1 with value 1 is the middle node, which is marked in red. Node 0 with value 2 is the only node remaining after removing node 1. Constraints: The number of nodes in the list is in the range [1, 105]. 1 <= Node.val <= 105 Solution Use a fast pointer that travels at twice the speed of the slow pointer. When the fast one is at the end, the slow one is at the position that needs to be removed. Code ''' Leetcode 2095. Delete the Middle Node of a Linked List Question Link : https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/ Solution Link : https://tofucode.com/posts/leetcode_2095_delete-the-middle-node-of-a-linked-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def deleteMiddle ( self , head : Optional [ ListNode ]) -> Optional [ ListNode ]: ''' [1,3,4,7,1,2,6] s f l remove s using l.next Time : O(n) Space: O(1) ''' # return if zero or one node if not head or not head . next : return None fast = slow = last = head while fast and fast . next : last = slow slow = slow . next fast = fast . next . next # delete slow last . next = slow . next return head","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2095_delete-the-middle-node-of-a-linked-list.html","loc":"https://tofucode.com/posts/leetcode_2095_delete-the-middle-node-of-a-linked-list.html"},{"title":"Leetcode 0101. Symmetric Tree","text":"Question Link : https://leetcode.com/problems/symmetric-tree/ Difficulty: Easy Question Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). Example 1: Input: root = [1,2,2,3,4,4,3] Output: true Example 2: Input: root = [1,2,2,null,3,null,3] Output: false Constraints: The number of nodes in the tree is in the range [1, 1000]. -100 <= Node.val <= 100 Follow up: Could you solve it both recursively and iteratively? Solution Check Symmety by either recursively or iteratively checking is symmetric Code ''' Leetcode 0101. Symmetric Tree Question Link : https://leetcode.com/problems/symmetric-tree/ Solution Link : https://tofucode.com/posts/leetcode_0101_symmetric-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def isSymmetric ( self , root : Optional [ TreeNode ]) -> bool : ''' Recursively check branches are mirrors of each other Time : O(n) Space: O(n) ''' if not root : return True return self . isMirror ( root . left , root . right ) def isMirror ( self , x , y ): if x is None and y is None : return True if x is None and y is not None : return False if y is None and x is not None : return False if x . val != y . val : return False return self . isMirror ( x . left , y . right ) and self . isMirror ( x . right , y . left ) class SolutionAlternative1 : def isSymmetric ( self , root : Optional [ TreeNode ]) -> bool : ''' Flip one branch and compare if the two branches are equal with Recursion Time : O(n) Space: O(n) ''' if root is None : return True # flip the right and then compare the 2 self . flip ( root . right ) return self . equal ( root . left , root . right ) def flip ( self , x ): if x is None : return x . left , x . right = x . right , x . left self . flip ( x . left ) self . flip ( x . right ) def equal ( self , x , y ): if x is None and y is None : return True if x is None and y is not None : return False if y is None and x is not None : return False if x . val != y . val : return False return self . equal ( x . left , y . left ) and self . equal ( x . right , y . right ) class SolutionAlternative2 : def isSymmetric ( self , root : Optional [ TreeNode ]) -> bool : ''' Iterative with a queue Time : O(n) Space: O(n) ''' if root is None : return True queue = [] queue . append (( root . left , root . right )) while queue : x , y = queue . pop ( 0 ) if not x and not y : continue if not x or not y : return False if x . val != y . val : return False # here l and r are symmetric queue . append (( x . left , y . right )) queue . append (( x . right , y . left )) return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0101_symmetric-tree.html","loc":"https://tofucode.com/posts/leetcode_0101_symmetric-tree.html"},{"title":"Leetcode 0334. Increasing Triplet Subsequence","text":"Question Link : https://leetcode.com/problems/increasing-triplet-subsequence/ Difficulty: Medium Question Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false. Example 1: Input: nums = [1,2,3,4,5] Output: true Explanation: Any triplet where i < j < k is valid. Example 2: Input: nums = [5,4,3,2,1] Output: false Explanation: No triplet exists. Example 3: Input: nums = [2,1,5,0,4,6] Output: true Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6. Constraints: 1 <= nums.length <= 5 * 105 -231 <= nums[i] <= 231 - 1 Follow up: Could you implement a solution that runs in O(n) time complexity and O(1) space complexity? Solution Keep track of 2 pointers, and find 2 places where the second > the first, after we find this, if we come upon a thrid where third > second, we return True Code ''' Leetcode 0334. Increasing Triplet Subsequence Question Link : https://leetcode.com/problems/increasing-triplet-subsequence/ Solution Link : https://tofucode.com/posts/leetcode_0334_increasing-triplet-subsequence.html ''' class Solution : def increasingTriplet ( self , nums : List [ int ]) -> bool : ''' first, second, thrid Time : O(n) Space: O(1) ''' first = second = math . inf for n in nums : if n <= first : first = n elif n <= second : second = n else : return True return False","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0334_increasing-triplet-subsequence.html","loc":"https://tofucode.com/posts/leetcode_0334_increasing-triplet-subsequence.html"},{"title":"Leetcode 0070. Climbing Stairs","text":"Question Link : https://leetcode.com/problems/climbing-stairs/ Difficulty: Easy Question You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Example 1: Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2: Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step Constraints: 1 <= n <= 45 Solution Use dp as the number of ways at step i is the sum of the previous 2 Code ''' Leetcode 0070. Climbing Stairs Question Link : https://leetcode.com/problems/climbing-stairs/ Solution Link : https://tofucode.com/posts/leetcode_0070_climbing-stairs.html ''' class Solution : def climbStairs ( self , n : int ) -> int : ''' dp[i] number of ways to reach stairs i dp[i] = dp[i-2] + dp[i-1] Time : O(n) Space: O(n) ''' if n <= 2 : return n dp = [ 0 ] * n dp [ 0 ] = 1 dp [ 1 ] = 2 for i in range ( 2 , n ): dp [ i ] = dp [ i - 2 ] + dp [ i - 1 ] return dp [ - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0070_climbing-stairs.html","loc":"https://tofucode.com/posts/leetcode_0070_climbing-stairs.html"},{"title":"Leetcode 2432. The Employee That Worked on the Longest Task","text":"Question Link : https://leetcode.com/problems/the-employee-that-worked-on-the-longest-task/ Difficulty: Easy Question There are n employees, each with a unique id from 0 to n - 1. You are given a 2D integer array logs where logs[i] = [idi, leaveTimei] where: idi is the id of the employee that worked on the ith task, and leaveTimei is the time at which the employee finished the ith task. All the values leaveTimei are unique. Note that the ith task starts the moment right after the (i - 1)th task ends, and the 0th task starts at time 0. Return the id of the employee that worked the task with the longest time. If there is a tie between two or more employees, return the smallest id among them. Example 1: Input: n = 10, logs = [[0,3],[2,5],[0,9],[1,15]] Output: 1 Explanation: Task 0 started at 0 and ended at 3 with 3 units of times. Task 1 started at 3 and ended at 5 with 2 units of times. Task 2 started at 5 and ended at 9 with 4 units of times. Task 3 started at 9 and ended at 15 with 6 units of times. The task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1. Example 2: Input: n = 26, logs = [[1,1],[3,7],[2,12],[7,17]] Output: 3 Explanation: Task 0 started at 0 and ended at 1 with 1 unit of times. Task 1 started at 1 and ended at 7 with 6 units of times. Task 2 started at 7 and ended at 12 with 5 units of times. Task 3 started at 12 and ended at 17 with 5 units of times. The tasks with the longest time is task 1. The employees that worked on it is 3, so we return 3. Example 3: Input: n = 2, logs = [[0,10],[1,20]] Output: 0 Explanation: Task 0 started at 0 and ended at 10 with 10 units of times. Task 1 started at 10 and ended at 20 with 10 units of times. The tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0. Constraints: 2 <= n <= 500 1 <= logs.length <= 500 logs[i].length == 2 0 <= idi <= n - 1 1 <= leaveTimei <= 500 idi != idi+1 leaveTimei are sorted in a strictly increasing order. Solution Go through the logs and keep track of the max Code ''' Leetcode 2432. The Employee That Worked on the Longest Task Question Link : https://leetcode.com/problems/the-employee-that-worked-on-the-longest-task/ Solution Link : https://tofucode.com/posts/leetcode_2432_the-employee-that-worked-on-the-longest-task.html ''' class Solution : def hardestWorker ( self , n : int , logs : List [ List [ int ]]) -> int : ''' keep a max id and time, if there is a tie on time, we want the smallest id Time : O(n) Space: O(1) ''' longest_id = logs [ 0 ][ 0 ] longest_time = logs [ 0 ][ 1 ] for i in range ( 1 , len ( logs )): current_id , leave_time = logs [ i ] used_time = leave_time - logs [ i - 1 ][ 1 ] if used_time > longest_time or ( used_time == longest_time and current_id < longest_id ): longest_id = current_id longest_time = used_time return longest_id","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2432_the-employee-that-worked-on-the-longest-task.html","loc":"https://tofucode.com/posts/leetcode_2432_the-employee-that-worked-on-the-longest-task.html"},{"title":"Leetcode 2433. Find The Original Array of Prefix Xor","text":"Question Link : https://leetcode.com/problems/find-the-original-array-of-prefix-xor/ Difficulty: Medium Question You are given an integer array pref of size n. Find and return the array arr of size n that satisfies: pref[i] = arr[0] &#94; arr[1] &#94; ... &#94; arr[i]. Note that &#94; denotes the bitwise-xor operation. It can be proven that the answer is unique. Example 1: Input: pref = [5,2,0,3,1] Output: [5,7,2,3,2] Explanation: From the array [5,7,2,3,2] we have the following: - pref[0] = 5. - pref[1] = 5 &#94; 7 = 2. - pref[2] = 5 &#94; 7 &#94; 2 = 0. - pref[3] = 5 &#94; 7 &#94; 2 &#94; 3 = 3. - pref[4] = 5 &#94; 7 &#94; 2 &#94; 3 &#94; 2 = 1. Example 2: Input: pref = [13] Output: [13] Explanation: We have pref[0] = arr[0] = 13. Constraints: 1 <= pref.length <= 105 0 <= pref[i] <= 106 Solution By looking at the XOR truth table, one can find that using the result to XOR one number gives the other number Code ''' Leetcode 2433. Find The Original Array of Prefix Xor Question Link : https://leetcode.com/problems/find-the-original-array-of-prefix-xor/ Solution Link : https://tofucode.com/posts/leetcode_2433_find-the-original-array-of-prefix-xor.html ''' class Solution : def findArray ( self , pref : List [ int ]) -> List [ int ]: ''' if a &#94; b = c then b &#94; c = a Time : O(n) Space: O(n) ''' result = [ pref [ 0 ]] for i in range ( 1 , len ( pref )): result . append ( pref [ i - 1 ] &#94; pref [ i ]) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2433_find-the-original-array-of-prefix-xor.html","loc":"https://tofucode.com/posts/leetcode_2433_find-the-original-array-of-prefix-xor.html"},{"title":"Leetcode 0653. Two Sum IV - Input is a BST","text":"Question Link : https://leetcode.com/problems/two-sum-iv-input-is-a-bst/ Difficulty: Easy Question Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: Input: root = [5,3,6,2,4,null,7], k = 9 Output: true Example 2: Input: root = [5,3,6,2,4,null,7], k = 28 Output: false Constraints: The number of nodes in the tree is in the range [1, 104]. -104 <= Node.val <= 104 root is guaranteed to be a valid binary search tree. -105 <= k <= 105 Solution Go through the whole tree while keeping a seen set, and at each new node keep checking if (k - current.val) is in seen Code ''' Leetcode 0653. Two Sum IV - Input is a BST Question Link : https://leetcode.com/problems/two-sum-iv-input-is-a-bst/ Solution Link : https://tofucode.com/posts/leetcode_0653_two-sum-iv-input-is-a-bst.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def findTarget ( self , root : Optional [ TreeNode ], k : int ) -> bool : ''' seen = set() track seen number dfs: for every node: check k - current Time : O(n) Space: O(n) ''' stack = [ root ] seen = set () while stack : current = stack . pop () # dfs if k - current . val in seen : return True seen . add ( current . val ) if current . left : stack . append ( current . left ) if current . right : stack . append ( current . right ) return False class SolutionAlternative1 : def findTarget ( self , root : TreeNode , k : int ) -> bool : ''' Use inorder traversal and a hashmap Can also inorder traverse and store everything down, and then 2 pointers Time : O(n) Space: O(n) ''' seen = set () return self . traverse ( root , seen , k ) def traverse ( self , node , seen , k ): if not node : return False # in order l = self . traverse ( node . left , seen , k ) if l : return True if k - node . val in seen : return True seen . add ( node . val ) return self . traverse ( node . right , seen , k )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0653_two-sum-iv-input-is-a-bst.html","loc":"https://tofucode.com/posts/leetcode_0653_two-sum-iv-input-is-a-bst.html"},{"title":"Leetcode 0112. Path Sum","text":"Question Link : https://leetcode.com/problems/path-sum/ Difficulty: Easy Question Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. Example 1: Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Explanation: The root-to-leaf path with the target sum is shown. Example 2: Input: root = [1,2,3], targetSum = 5 Output: false Explanation: There two root-to-leaf paths in the tree: (1 --> 2): The sum is 3. (1 --> 3): The sum is 4. There is no root-to-leaf path with sum = 5. Example 3: Input: root = [], targetSum = 0 Output: false Explanation: Since the tree is empty, there are no root-to-leaf paths. Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 <= Node.val <= 1000 -1000 <= targetSum <= 1000 Solution Use recursion to check the whole tree, and return true when there is a sum at a leaf node Code ''' Leetcode 0112. Path Sum Question Link : https://leetcode.com/problems/path-sum/ Solution Link : https://tofucode.com/posts/leetcode_0112_path-sum.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def hasPathSum ( self , root : Optional [ TreeNode ], targetSum : int ) -> bool : ''' For True check: 1. sum 2. is leaf node Time : O(n) Space: O(n) ''' if not root : return False remain = targetSum - root . val if remain == 0 and not root . left and not root . right : return True return self . hasPathSum ( root . left , remain ) or self . hasPathSum ( root . right , remain )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0112_path-sum.html","loc":"https://tofucode.com/posts/leetcode_0112_path-sum.html"},{"title":"Leetcode 1578. Minimum Time to Make Rope Colorful","text":"Question Link : https://leetcode.com/problems/minimum-time-to-make-rope-colorful/ Difficulty: Medium Question Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon. Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope. Return the minimum time Bob needs to make the rope colorful. Example 1: Input: colors = \"abaac\", neededTime = [1,2,3,4,5] Output: 3 Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green. Bob can remove the blue balloon at index 2. This takes 3 seconds. There are no longer two consecutive balloons of the same color. Total time = 3. Example 2: Input: colors = \"abc\", neededTime = [1,2,3] Output: 0 Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope. Example 3: Input: colors = \"aabaa\", neededTime = [1,2,3,4,1] Output: 2 Explanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove. There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2. Constraints: n == colors.length == neededTime.length 1 <= n <= 105 1 <= neededTime[i] <= 104 colors contains only lowercase English letters. Solution Do not need to use DP, instead see the problem by splitting the ballons into groups by color and we need to remove the lower cost ones for each group. This would mean leaving the highest cost one, so cost for each group is sum time of group - max time in this group. Code ''' Leetcode 1578. Minimum Time to Make Rope Colorful Question Link : https://leetcode.com/problems/minimum-time-to-make-rope-colorful/ Solution Link : https://tofucode.com/posts/leetcode_1578_minimum-time-to-make-rope-colorful.html ''' class Solution : def minCost ( self , colors : str , neededTime : List [ int ]) -> int : ''' \"a,a,b,a,a\" [1,2,3,4,1] 1,2 4,1 for each group: needed time = sum time - max time Time : O(n) Space: O(1) ''' current = None currentMax = 0 currentSum = 0 result = 0 for i in range ( len ( colors )): if colors [ i ] == current : # update current sum, max currentMax = max ( currentMax , neededTime [ i ]) currentSum += neededTime [ i ] else : result += currentSum - currentMax # update current color, sum, max current = colors [ i ] currentMax = neededTime [ i ] currentSum = neededTime [ i ] # check the last group result += currentSum - currentMax return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1578_minimum-time-to-make-rope-colorful.html","loc":"https://tofucode.com/posts/leetcode_1578_minimum-time-to-make-rope-colorful.html"},{"title":"Leetcode 0746. Min Cost Climbing Stairs","text":"Question Link : https://leetcode.com/problems/min-cost-climbing-stairs/ Difficulty: Easy Question You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor. Example 1: Input: cost = [10,15,20] Output: 15 Explanation: You will start at index 1. - Pay 15 and climb two steps to reach the top. The total cost is 15. Example 2: Input: cost = [1,100,1,1,1,100,1,1,100,1] Output: 6 Explanation: You will start at index 0. - Pay 1 and climb two steps to reach index 2. - Pay 1 and climb two steps to reach index 4. - Pay 1 and climb two steps to reach index 6. - Pay 1 and climb one step to reach index 7. - Pay 1 and climb two steps to reach index 9. - Pay 1 and climb one step to reach the top. The total cost is 6. Constraints: 2 <= cost.length <= 1000 0 <= cost[i] <= 999 Solution Look back at -1 and -2 positions and take the min Code ''' Leetcode 0746. Min Cost Climbing Stairs Question Link : https://leetcode.com/problems/min-cost-climbing-stairs/ Solution Link : https://tofucode.com/posts/leetcode_0746_min-cost-climbing-stairs.html ''' class Solution : def minCostClimbingStairs ( self , cost : List [ int ]) -> int : ''' [10,15,20] [10 15 X Y] The End Y can either be achived: X -> Y or 15 -> Y In other words: 15 or X can be the ending Time : O(n) Space: O(n) ''' n = len ( cost ) dp = [ - 1 ] * n dp [ 0 ] = cost [ 0 ] dp [ 1 ] = cost [ 1 ] for i in range ( 2 , n ): dp [ i ] = min ( dp [ i - 1 ], dp [ i - 2 ]) + cost [ i ] return min ( dp [ - 2 ], dp [ - 1 ])","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0746_min-cost-climbing-stairs.html","loc":"https://tofucode.com/posts/leetcode_0746_min-cost-climbing-stairs.html"},{"title":"Leetcode 0406. Queue Reconstruction by Height","text":"Question Link : https://leetcode.com/problems/queue-reconstruction-by-height/ Difficulty: Medium Question You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi. Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue). Example 1: Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] Explanation: Person 0 has height 5 with no other people taller or the same height in front. Person 1 has height 7 with no other people taller or the same height in front. Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1. Person 3 has height 6 with one person taller or the same height in front, which is person 1. Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3. Person 5 has height 7 with one person taller or the same height in front, which is person 1. Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue. Example 2: Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] Constraints: 1 <= people.length <= 2000 0 <= hi <= 106 0 <= ki < people.length It is guaranteed that the queue can be reconstructed. Solution Try to write out what would happen if we sorted from decreasing h or increasing h, and how each one needs to be inserted with relation to its k. Code ''' Leetcode 0406. Queue Reconstruction by Height Question Link : https://leetcode.com/problems/queue-reconstruction-by-height/ Solution Link : https://tofucode.com/posts/leetcode_0406_queue-reconstruction-by-height.html ''' class Solution : def reconstructQueue ( self , people : List [ List [ int ]]) -> List [ List [ int ]]: ''' [7,0],[4,4],[7,1],[5,0],[6,1],[5,2] k: num of people in front >= me # start from smallest height [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] [4,4] [5,0] [5,2] [6,1] [7,0] [7,1] from h smallest to largest: count empties or same height till upto k and insert Time : O(nlogn + n&#94;2) Space: O(n) ''' result = [ None ] * len ( people ) # sort the array in increasing order of height, increasing of k # before: [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] # after : [[4,4],[5,0],[5,2],[6,1],[7,0],[7,1]] people = sorted ( people , key = lambda x : ( x [ 0 ], x [ 1 ])) for p in people : h , k = p for i in range ( len ( people )): if result [ i ] is None or result [ i ][ 0 ] == h : k -= 1 # found position for p, -1 now cause there were k before if k == - 1 : result [ i ] = p break return result class SolutionAlternative1 : def reconstructQueue ( self , people : List [ List [ int ]]) -> List [ List [ int ]]: ''' [7,0],[4,4],[7,1],[5,0],[6,1],[5,2] k: num of people in front >= me insert with k as index [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] 0: [7,0] 1: [7,0], [7,1] 1: [7,0], [6,1], [7,1] 1: [7,0], [6,1], [7,1] 0: [5,0], [7,0], [6,1], [7,1] 2: [5,0], [7,0], [5,2], [6,1], [7,1] 4: [5,0], [7,0], [5,2], [6,1], [4,4], [7,1] * persons with the same height are sorted by the second value Time : O(nlogn + n&#94;2) Space: O(n) ''' result = [] # sort the array in decreasing order of height, increasing of k # before: [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] # after: [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]] people . sort ( key = lambda x : ( - x [ 0 ], x [ 1 ])) for p in people : h , k = p # greedy insert with k as the index result . insert ( k , p ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0406_queue-reconstruction-by-height.html","loc":"https://tofucode.com/posts/leetcode_0406_queue-reconstruction-by-height.html"},{"title":"Leetcode 2326. Spiral Matrix IV","text":"Question Link : https://leetcode.com/problems/spiral-matrix-iv/ Difficulty: Medium Question You are given two integers m and n, which represent the dimensions of a matrix. You are also given the head of a linked list of integers. Generate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1. Return the generated matrix. Example 1: Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0] Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]] Explanation: The diagram above shows how the values are printed in the matrix. Note that the remaining spaces in the matrix are filled with -1. Example 2: Input: m = 1, n = 4, head = [0,1,2] Output: [[0,1,2,-1]] Explanation: The diagram above shows how the values are printed from left to right in the matrix. The last space in the matrix is set to -1. Constraints: 1 <= m, n <= 105 1 <= m * n <= 105 The number of nodes in the list is in the range [1, m * n]. 0 <= Node.val <= 1000 Solution Traverse matrix with dx, dy denoting movement in x and y direction and keep inserting the next val from the list Code ''' Leetcode 2326. Spiral Matrix IV Question Link : https://leetcode.com/problems/spiral-matrix-iv/ Solution Link : https://tofucode.com/posts/leetcode_2326_spiral-matrix-iv.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def spiralMatrix ( self , m : int , n : int , head : Optional [ ListNode ]) -> List [ List [ int ]]: ''' Use dx, dy to denote movement instead of a direction variable Time : O(n*m) Space: O(n*m) ''' result = [[ - 1 ] * n for i in range ( m )] x , y = 0 , 0 dx , dy = 1 , 0 # change in x , change in y p = head for i in range ( n * m ): # boundary for direction change if x + dx < 0 or x + dx > n - 1 or y + dy > m - 1 or y + dy < 0 or result [ y + dy ][ x + dx ] != - 1 : dx , dy = - dy , dx # update if not p : break result [ y ][ x ] = p . val # x, y as x is the horizontal movement p = p . next # move x , y = x + dx , y + dy return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2326_spiral-matrix-iv.html","loc":"https://tofucode.com/posts/leetcode_2326_spiral-matrix-iv.html"},{"title":"Leetcode 1710. Maximum Units on a Truck","text":"Question Link : https://leetcode.com/problems/maximum-units-on-a-truck/ Difficulty: Easy Question You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]: numberOfBoxesi is the number of boxes of type i. numberOfUnitsPerBoxi is the number of units in each box of the type i. You are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed truckSize. Return the maximum total number of units that can be put on the truck. Example 1: Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4 Output: 8 Explanation: There are: - 1 box of the first type that contains 3 units. - 2 boxes of the second type that contain 2 units each. - 3 boxes of the third type that contain 1 unit each. You can take all the boxes of the first and second types, and one box of the third type. The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8. Example 2: Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10 Output: 91 Constraints: 1 <= boxTypes.length <= 1000 1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000 1 <= truckSize <= 106 Solution Sort by the highest value, and greedily take from the front until truck is full Code ''' Leetcode 1710. Maximum Units on a Truck Question Link : https://leetcode.com/problems/maximum-units-on-a-truck/ Solution Link : https://tofucode.com/posts/leetcode_1710_maximum-units-on-a-truck.html ''' class Solution : def maximumUnits ( self , boxTypes : List [ List [ int ]], truckSize : int ) -> int : ''' [[5,10],[2,5],[4,7],[3,9]] [5,10], [3,9], [4,7], [2,5] 10 50 + 27 + 14 = 91 Time : O(n log n) Space: O(n) ''' boxes = sorted ( boxTypes , key = lambda x : - x [ 1 ]) result = 0 idx = 0 currentTruck = truckSize while idx < len ( boxes ) and currentTruck > 0 : currentBoxes = boxes [ idx ][ 0 ] take = min ( currentBoxes , currentTruck ) result += take * boxes [ idx ][ 1 ] currentTruck -= take idx += 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1710_maximum-units-on-a-truck.html","loc":"https://tofucode.com/posts/leetcode_1710_maximum-units-on-a-truck.html"},{"title":"Leetcode 0462. Minimum Moves to Equal Array Elements II","text":"Question Link : https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/ Difficulty: Medium Question Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal. In one move, you can increment or decrement an element of the array by 1. Test cases are designed so that the answer will fit in a 32-bit integer. Example 1: Input: nums = [1,2,3] Output: 2 Explanation: Only two moves are needed (remember each move increments or decrements one element): [1,2,3] => [2,2,3] => [2,2,2] Example 2: Input: nums = [1,10,2,9] Output: 16 Constraints: n == nums.length 1 <= nums.length <= 105 -109 <= nums[i] <= 109 Solution We are basically looking for a point that produces the min sum of distances to all other points, that's the median Code ''' Leetcode 0462. Minimum Moves to Equal Array Elements II Question Link : https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/ Solution Link : https://tofucode.com/posts/leetcode_0462_minimum-moves-to-equal-array-elements-ii.html ''' class Solution : def minMoves2 ( self , nums : List [ int ]) -> int : ''' Use median not average Time : O(n log n) Space: O(n) ''' median = sorted ( nums )[ len ( nums ) // 2 ] moves = [ abs ( num - median ) for num in nums ] return sum ( moves )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0462_minimum-moves-to-equal-array-elements-ii.html","loc":"https://tofucode.com/posts/leetcode_0462_minimum-moves-to-equal-array-elements-ii.html"},{"title":"Leetcode 1647. Minimum Deletions to Make Character Frequencies Unique","text":"Question Link : https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/ Difficulty: Medium Question A string s is called good if there are no two different characters in s that have the same frequency. Given a string s, return the minimum number of characters you need to delete to make s good. The frequency of a character in a string is the number of times it appears in the string. For example, in the string \"aab\", the frequency of 'a' is 2, while the frequency of 'b' is 1. Example 1: Input: s = \"aab\" Output: 0 Explanation: s is already good. Example 2: Input: s = \"aaabbbcc\" Output: 2 Explanation: You can delete two 'b's resulting in the good string \"aaabcc\". Another way it to delete one 'b' and one 'c' resulting in the good string \"aaabbc\". Example 3: Input: s = \"ceabaacb\" Output: 2 Explanation: You can delete both 'c's resulting in the good string \"eabaab\". Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored). Constraints: 1 <= s.length <= 105 s contains only lowercase English letters. Solution Count the frequency and sort in reverse. Go through it and use a max_freq marker to calculate what the max possible freq is Code ''' Leetcode 1647. Minimum Deletions to Make Character Frequencies Unique Question Link : https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/ Solution Link : https://tofucode.com/posts/leetcode_1647_minimum-deletions-to-make-character-frequencies-unique.html ''' class Solution : def minDeletions ( self , s : str ) -> int : ''' \"aaabbbcc\" a: 3 b: 3 c: 2 \"ceabaacb\" a: 3 b: 2 c: 2 e: 1 count first, sort by value, from highest to lowest freq: keep trying max_freq # s has n length, and k number of distinct chars (which is 26 max) Time : O(n) Space: O(1) ''' counts = {} # letter -> count for c in s : counts [ c ] = counts . get ( c , 0 ) + 1 max_freq = len ( s ) result = 0 for k , v in sorted ( counts . items (), key = lambda x : x [ 1 ], reverse = True ): if v > max_freq : result += v - max_freq # frequency of 0 is ignored if max_freq > 0 : max_freq -= 1 else : max_freq = v - 1 return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1647_minimum-deletions-to-make-character-frequencies-unique.html","loc":"https://tofucode.com/posts/leetcode_1647_minimum-deletions-to-make-character-frequencies-unique.html"},{"title":"Leetcode 1423. Maximum Points You Can Obtain from Cards","text":"Question Link : https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/ Difficulty: Medium Question There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k, return the maximum score you can obtain. Example 1: Input: cardPoints = [1,2,3,4,5,6,1], k = 3 Output: 12 Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12. Example 2: Input: cardPoints = [2,2,2], k = 2 Output: 4 Explanation: Regardless of which two cards you take, your score will always be 4. Example 3: Input: cardPoints = [9,7,7,9,7,7,9], k = 7 Output: 55 Explanation: You have to take all the cards. Your score is the sum of points of all cards. Constraints: 1 <= cardPoints.length <= 105 1 <= cardPoints[i] <= 104 1 <= k <= cardPoints.length Solution First calculate the sum of the first k elements which is the starting window, then at each step we remove the latest one from the front and add in one from the back. Take the max point any time that's in the window. Code ''' Leetcode 1423. Maximum Points You Can Obtain from Cards Question Link : https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/ Solution Link : https://tofucode.com/posts/leetcode_1423_maximum-points-you-can-obtain-from-cards.html ''' class Solution : def maxScore ( self , cardPoints : List [ int ], k : int ) -> int : ''' [1,2,3,4,5,6,1], k = 3 5,6,1 sum (1,2,3) = 6 -3+1 = 4 -2+6 = 8 -1+5 = 12 Time : O(k) Space: O(1) ''' n = len ( cardPoints ) current = sum ( cardPoints [: k ]) result = current for i in range ( k ): current = current - cardPoints [ k - 1 - i ] + cardPoints [ n - 1 - i ] result = max ( result , current ) return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1423_maximum-points-you-can-obtain-from-cards.html","loc":"https://tofucode.com/posts/leetcode_1423_maximum-points-you-can-obtain-from-cards.html"},{"title":"Leetcode 0665. Non-decreasing Array","text":"Question Link : https://leetcode.com/problems/non-decreasing-array/ Difficulty: Medium Question Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element. We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2). Example 1: Input: nums = [4,2,3] Output: true Explanation: You could modify the first 4 to 1 to get a non-decreasing array. Example 2: Input: nums = [4,2,1] Output: false Explanation: You can't get a non-decreasing array by modify at most one element. Constraints: n == nums.length 1 <= n <= 104 -105 <= nums[i] <= 105 Solution Test out a few examples to find that there are different cases of where the fix needs to be Code ''' Leetcode 0665. Non-decreasing Array Question Link : https://leetcode.com/problems/non-decreasing-array/ Solution Link : https://tofucode.com/posts/leetcode_0665_non-decreasing-array.html ''' class Solution : def checkPossibility ( self , nums : List [ int ]) -> bool : ''' monotonic-stack - but can skip one when i is at number 2: [4, 2, 3] skip i-1 [1, 4, 2, 5] skip i-1 skip 4 works [3, 4, 2, 5] skip i skip 4 does not work skip 2 works when i = 2, Time : O(n) Space: O(1) ''' skipped = False for i in range ( 1 , len ( nums )): if nums [ i - 1 ] > nums [ i ]: if skipped : return False # skip i: make it the same to keep going if i - 2 >= 0 and nums [ i - 2 ] > nums [ i ]: nums [ i ] = nums [ i - 1 ] # skip i-1 skipped = True return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0665_non-decreasing-array.html","loc":"https://tofucode.com/posts/leetcode_0665_non-decreasing-array.html"},{"title":"Leetcode 2294. Partition Array Such That Maximum Difference Is K","text":"Question Link : https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/ Difficulty: Medium Question You are given an integer array nums and an integer k. You may partition nums into one or more subsequences such that each element in nums appears in exactly one of the subsequences. Return the minimum number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is at most k. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Example 1: Input: nums = [3,6,1,2,5], k = 2 Output: 2 Explanation: We can partition nums into the two subsequences [3,1,2] and [6,5]. The difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2. The difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1. Since two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed. Example 2: Input: nums = [1,2,3], k = 1 Output: 2 Explanation: We can partition nums into the two subsequences [1,2] and [3]. The difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1. The difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0. Since two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3]. Example 3: Input: nums = [2,2,4,5], k = 0 Output: 3 Explanation: We can partition nums into the three subsequences [2,2], [4], and [5]. The difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0. The difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0. The difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0. Since three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed. Constraints: 1 <= nums.length <= 105 0 <= nums[i] <= 105 0 <= k <= 105 Solution To create the min partition, we first sort it and then go through and group the closet ones. Also +1 for the ending partition Code ''' Leetcode 2294. Partition Array Such That Maximum Difference Is K Question Link : https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/ Solution Link : https://tofucode.com/posts/leetcode_2294_partition-array-such-that-maximum-difference-is-k.html ''' class Solution : def partitionArray ( self , nums : List [ int ], k : int ) -> int : ''' [1,2,3,5,6] 1. sort it 2. loop through and update count when > 2 Time : O(nlogn) Space: O(n) ''' if not nums : return 0 nums = sorted ( nums ) result = 0 last = nums [ 0 ] for num in nums : if num - last > k : result += 1 last = num # +1 for the last partition return result + 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2294_partition-array-such-that-maximum-difference-is-k.html","loc":"https://tofucode.com/posts/leetcode_2294_partition-array-such-that-maximum-difference-is-k.html"},{"title":"Leetcode 2284. Sender With Largest Word Count","text":"Question Link : https://leetcode.com/problems/sender-with-largest-word-count/ Difficulty: Medium Question You have a chat log of n messages. You are given two string arrays messages and senders where messages[i] is a message sent by senders[i]. A message is list of words that are separated by a single space with no leading or trailing spaces. The word count of a sender is the total number of words sent by the sender. Note that a sender may send more than one message. Return the sender with the largest word count. If there is more than one sender with the largest word count, return the one with the lexicographically largest name. Note: Uppercase letters come before lowercase letters in lexicographical order. \"Alice\" and \"alice\" are distinct. Example 1: Input: messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"], senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"] Output: \"Alice\" Explanation: Alice sends a total of 2 + 3 = 5 words. userTwo sends a total of 2 words. userThree sends a total of 3 words. Since Alice has the largest word count, we return \"Alice\". Example 2: Input: messages = [\"How is leetcode for everyone\",\"Leetcode is useful for practice\"], senders = [\"Bob\",\"Charlie\"] Output: \"Charlie\" Explanation: Bob sends a total of 5 words. Charlie sends a total of 5 words. Since there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie. Constraints: n == messages.length == senders.length 1 <= n <= 104 1 <= messages[i].length <= 100 1 <= senders[i].length <= 10 messages[i] consists of uppercase and lowercase English letters and ' '. All the words in messages[i] are separated by a single space. messages[i] does not have leading or trailing spaces. senders[i] consists of uppercase and lowercase English letters only. Solution Use a hashmap to count for each person, than go through the map to find the max Code ''' Leetcode 2284. Sender With Largest Word Count Question Link : https://leetcode.com/problems/sender-with-largest-word-count/ Solution Link : https://tofucode.com/posts/leetcode_2284_sender-with-largest-word-count.html ''' class Solution : def largestWordCount ( self , messages : List [ str ], senders : List [ str ]) -> str : ''' messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"] senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"] {} # sender -> message count loop through map to find largest sender with max count Time: O(n) Space: O(n) ''' counts = {} # sender -> message count for i in range ( len ( messages )): message = messages [ i ] sender = senders [ i ] counts [ sender ] = counts . get ( sender , 0 ) + self . countWords ( message ) result = \"\" max_count = 0 for sender , count in counts . items (): if count > max_count or ( count == max_count and sender > result ): result = sender max_count = count return result def countWords ( self , message ): return len ( message . split ( ' ' ))","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2284_sender-with-largest-word-count.html","loc":"https://tofucode.com/posts/leetcode_2284_sender-with-largest-word-count.html"},{"title":"Leetcode 0167. Two Sum II - Input Array Is Sorted","text":"Question Link : https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ Difficulty: Medium Question Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. Example 1: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]. Example 2: Input: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]. Example 3: Input: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2]. Constraints: 2 <= numbers.length <= 3 * 104 -1000 <= numbers[i] <= 1000 numbers is sorted in non-decreasing order. -1000 <= target <= 1000 The tests are generated such that there is exactly one solution. Solution Since the numbers are sorted we can start two pointers from each end and move inwards till the sum is the target Code ''' Leetcode 0167. Two Sum II - Input Array Is Sorted Question Link : https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ Solution Link : https://tofucode.com/posts/leetcode_0167_two-sum-ii-input-array-is-sorted.html ''' class Solution : def twoSum ( self , numbers : List [ int ], target : int ) -> List [ int ]: ''' Either move i+1 or move j-1 till the sum is target Time : O(n) Space: O(1) ''' i = 0 j = len ( numbers ) - 1 while i < j : s = numbers [ i ] + numbers [ j ] if s == target : return [ i + 1 , j + 1 ] elif s < target : i += 1 else : j -= 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0167_two-sum-ii-input-array-is-sorted.html","loc":"https://tofucode.com/posts/leetcode_0167_two-sum-ii-input-array-is-sorted.html"},{"title":"Leetcode 2283. Check if Number Has Equal Digit Count and Digit Value","text":"Question Link : https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/ Difficulty: Easy Question You are given a 0-indexed string num of length n consisting of digits. Return true if for every index i in the range 0 <= i < n, the digit i occurs num[i] times in num, otherwise return false. Example 1: Input: num = \"1210\" Output: true Explanation: num[0] = '1'. The digit 0 occurs once in num. num[1] = '2'. The digit 1 occurs twice in num. num[2] = '1'. The digit 2 occurs once in num. num[3] = '0'. The digit 3 occurs zero times in num. The condition holds true for every index in \"1210\", so return true. Example 2: Input: num = \"030\" Output: false Explanation: num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num. num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num. num[2] = '0'. The digit 2 occurs zero times in num. The indices 0 and 1 both violate the condition, so return false. Constraints: n == num.length 1 <= n <= 10 num consists of digits. Solution First loops counts each digit, second loop checks if the condition is met Code ''' Leetcode 2283. Check if Number Has Equal Digit Count and Digit Value Question Link : https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/ Solution Link : https://tofucode.com/posts/leetcode_2283_check-if-number-has-equal-digit-count-and-digit-value.html ''' class Solution : def digitCount ( self , num : str ) -> bool : ''' Use a Counter and 2 loops Time : O(n) Space: O(n) ''' count = {} # digit => count for i in range ( len ( num )): n = int ( num [ i ]) count [ n ] = count . get ( n , 0 ) + 1 for i in range ( len ( num )): n = int ( num [ i ]) if count . get ( i , 0 ) != n : return False return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2283_check-if-number-has-equal-digit-count-and-digit-value.html","loc":"https://tofucode.com/posts/leetcode_2283_check-if-number-has-equal-digit-count-and-digit-value.html"},{"title":"Leetcode 2287. Rearrange Characters to Make Target String","text":"Question Link : https://leetcode.com/problems/rearrange-characters-to-make-target-string/ Difficulty: Easy Question You are given two 0-indexed strings s and target. You can take some letters from s and rearrange them to form new strings. Return the maximum number of copies of target that can be formed by taking letters from s and rearranging them. Example 1: Input: s = \"ilovecodingonleetcode\", target = \"code\" Output: 2 Explanation: For the first copy of \"code\", take the letters at indices 4, 5, 6, and 7. For the second copy of \"code\", take the letters at indices 17, 18, 19, and 20. The strings that are formed are \"ecod\" and \"code\" which can both be rearranged into \"code\". We can make at most two copies of \"code\", so we return 2. Example 2: Input: s = \"abcba\", target = \"abc\" Output: 1 Explanation: We can make one copy of \"abc\" by taking the letters at indices 0, 1, and 2. We can make at most one copy of \"abc\", so we return 1. Note that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of \"abc\". Example 3: Input: s = \"abbaccaddaeea\", target = \"aaaaa\" Output: 1 Explanation: We can make one copy of \"aaaaa\" by taking the letters at indices 0, 3, 6, 9, and 12. We can make at most one copy of \"aaaaa\", so we return 1. Constraints: 1 <= s.length <= 100 1 <= target.length <= 10 s and target consist of lowercase English letters. Solution Count the chars that is given and needed, do a division to find the possible copies Code ''' Leetcode 2287. Rearrange Characters to Make Target String Question Link : https://leetcode.com/problems/rearrange-characters-to-make-target-string/ Solution Link : https://tofucode.com/posts/leetcode_2287_rearrange-characters-to-make-target-string.html ''' class Solution : def rearrangeCharacters ( self , s : str , target : str ) -> int : ''' 1. Count how many times each char is given 2. Count how many times each char is needed 3. Do a division to see how many copies each char can provide 4. Take the min which is the bottleneck Time : O(1) s and target length is constant Space: O(1) ''' given_counts = [ 0 ] * 26 # given: count of a b c ... for c in s : i = ord ( c ) - ord ( 'a' ) given_counts [ i ] += 1 need_counts = [ 0 ] * 26 # needed: count of a b c ... for c in target : i = ord ( c ) - ord ( 'a' ) need_counts [ i ] += 1 copies = [] # for all the needed chars, how many copies each char can provide for i in range ( len ( need_counts )): if need_counts [ i ] != 0 : copies . append ( given_counts [ i ] // need_counts [ i ]) return min ( copies )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2287_rearrange-characters-to-make-target-string.html","loc":"https://tofucode.com/posts/leetcode_2287_rearrange-characters-to-make-target-string.html"},{"title":"Leetcode 2293. Min Max Game","text":"Question Link : https://leetcode.com/problems/min-max-game/ Difficulty: Easy Question You are given a 0-indexed integer array nums whose length is a power of 2. Apply the following algorithm on nums: Let n be the length of nums. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n / 2. For every even index i where 0 <= i < n / 2, assign the value of newNums[i] as min(nums[2 * i], nums[2 * i + 1]). For every odd index i where 0 <= i < n / 2, assign the value of newNums[i] as max(nums[2 * i], nums[2 * i + 1]). Replace the array nums with newNums. Repeat the entire process starting from step 1. Return the last number that remains in nums after applying the algorithm. Example 1: Input: nums = [1,3,5,2,4,8,2,2] Output: 1 Explanation: The following arrays are the results of applying the algorithm repeatedly. First: nums = [1,5,4,2] Second: nums = [1,4] Third: nums = [1] 1 is the last remaining number, so we return 1. Example 2: Input: nums = [3] Output: 3 Explanation: 3 is already the last remaining number, so we return 3. Constraints: 1 <= nums.length <= 1024 1 <= nums[i] <= 109 nums.length is a power of 2. Solution Write a recursion based on the given rules. Code ''' Leetcode 2293. Min Max Game Question Link : https://leetcode.com/problems/min-max-game/ Solution Link : https://tofucode.com/posts/leetcode_2293_min-max-game.html ''' class Solution : def minMaxGame ( self , nums : List [ int ]) -> int : if len ( nums ) == 1 : return nums [ 0 ] half = len ( nums ) // 2 temp = [ None ] * half for i in range ( half ): if i % 2 == 0 : temp [ i ] = min ( nums [ 2 * i ], nums [ 2 * i + 1 ]) else : temp [ i ] = max ( nums [ 2 * i ], nums [ 2 * i + 1 ]) return self . minMaxGame ( temp )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_2293_min-max-game.html","loc":"https://tofucode.com/posts/leetcode_2293_min-max-game.html"},{"title":"Leetcode 0647. Palindromic Substrings","text":"Question Link : https://leetcode.com/problems/palindromic-substrings/ Difficulty: Medium Question Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string. Example 1: Input: s = \"abc\" Output: 3 Explanation: Three palindromic strings: \"a\", \"b\", \"c\". Example 2: Input: s = \"aaa\" Output: 6 Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". Constraints: 1 <= s.length <= 1000 s consists of lowercase English letters. Solution This is a palindrome problem where we need to use center expansion for each char in the string, and check ood and even cases of palindromes Code ''' Leetcode 0647. Palindromic Substrings Question Link : https://leetcode.com/problems/palindromic-substrings/ Solution Link : https://tofucode.com/posts/leetcode_0647_palindromic-substrings.html ''' class Solution : def countSubstrings ( self , s : str ) -> int : ''' Go through every char and expand from the center Need to check odd and even cases of palindromes Time : O(n&#94;2) Space: O(1) ''' count = 0 for i in range ( len ( s )): count += self . countPalindrome ( s , i , i ) count += self . countPalindrome ( s , i , i + 1 ) return count def countPalindrome ( self , s , l , r ): ''' returns Palindrome count starting at l, r index''' start = l while l >= 0 and r <= len ( s ) - 1 : if s [ l ] == s [ r ]: l -= 1 r += 1 else : break return start - l","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0647_palindromic-substrings.html","loc":"https://tofucode.com/posts/leetcode_0647_palindromic-substrings.html"},{"title":"Leetcode 0897. Increasing Order Search Tree","text":"Question Link : https://leetcode.com/problems/increasing-order-search-tree/ Difficulty: Easy Question Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child. Example 1: Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9] Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] Example 2: Input: root = [5,1,7] Output: [1,null,5,null,7] Constraints: The number of nodes in the given tree will be in the range [1, 100]. 0 <= Node.val <= 1000 Solution Use the same left traversal as the iterator problem and link the right pointer, and set the left pointer to None Code ''' Leetcode 0897. Increasing Order Search Tree Question Link : https://leetcode.com/problems/increasing-order-search-tree/ Solution Link : https://tofucode.com/posts/leetcode_0897_increasing-order-search-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def increasingBST ( self , root : TreeNode ) -> TreeNode : ''' Time : O(n) Space: O(h) ''' if not root : return # store in reverse so we can pop() self . stack = [] self . traverseLeft ( root ) last = self . next () new_head = last while self . hasNext (): node = self . next () last . right = node node . left = None last = node return new_head def next ( self ): node = self . stack . pop () if node . right : self . traverseLeft ( node . right ) return node def hasNext ( self ) -> bool : return len ( self . stack ) > 0 def traverseLeft ( self , node ): if not node : return self . stack . append ( node ) self . traverseLeft ( node . left )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0897_increasing-order-search-tree.html","loc":"https://tofucode.com/posts/leetcode_0897_increasing-order-search-tree.html"},{"title":"Leetcode 0700. Search in a Binary Search Tree","text":"Question Link : https://leetcode.com/problems/search-in-a-binary-search-tree/ Difficulty: Easy Question You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null. Example 1: Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Example 2: Input: root = [4,2,7,1,3], val = 5 Output: [] Constraints: The number of nodes in the tree is in the range [1, 5000]. 1 <= Node.val <= 107 root is a binary search tree. 1 <= val <= 107 Solution Recursive or Iterative Code ''' Leetcode 0700. Search in a Binary Search Tree Question Link : https://leetcode.com/problems/search-in-a-binary-search-tree/ Solution Link : https://tofucode.com/posts/leetcode_0700_search-in-a-binary-search-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def searchBST ( self , root : Optional [ TreeNode ], val : int ) -> Optional [ TreeNode ]: ''' Recursive Time : O(log n) Space: O(1) ''' if not root : return if val == root . val : return root elif val < root . val : return self . searchBST ( root . left , val ) else : return self . searchBST ( root . right , val ) class SolutionAlternative1 : def searchBST ( self , root : Optional [ TreeNode ], val : int ) -> Optional [ TreeNode ]: ''' Iterative Time : O(log n) Space: O(1) ''' node = root while node : if node . val == val : return node elif node . val < val : node = node . right else : node = node . left return None","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0700_search-in-a-binary-search-tree.html","loc":"https://tofucode.com/posts/leetcode_0700_search-in-a-binary-search-tree.html"},{"title":"Leetcode 0289. Game of Life","text":"Question Link : https://leetcode.com/problems/game-of-life/ Difficulty: Medium Question According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\" The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state. Example 1: Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]] Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]] Example 2: Input: board = [[1,1],[1,0]] Output: [[1,1],[1,1]] Constraints: m == board.length n == board[i].length 1 <= m, n <= 25 board[i][j] is 0 or 1. Follow up: Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems? Solution With Extra space, we can check all cells based on the original board With no extra space, we can use different numbers to encode more info Code ''' Leetcode 0289. Game of Life Question Link : https://leetcode.com/problems/game-of-life/ Solution Link : https://tofucode.com/posts/leetcode_0289_game-of-life.html ''' class Solution : def gameOfLife ( self , board : List [ List [ int ]]) -> None : ''' With another board: go through each one and calculated he updated status Time : O(mn) Space: O(mn) ''' if len ( board ) == 0 : return rows = len ( board ) cols = len ( board [ 0 ]) if rows else 0 temp = [[ 0 ] * cols for x in range ( rows )] for i in range ( rows ): for j in range ( cols ): temp [ i ][ j ] = self . getState ( i , j , board , rows , cols ) # copy the board over board [:] = temp [:] def getState ( self , i , j , board , rows , cols ): offsets = [( - 1 , - 1 ), ( - 1 , 0 ), ( - 1 , 1 ), ( 0 , - 1 ), ( 0 , 1 ), ( 1 , - 1 ), ( 1 , 0 ), ( 1 , 1 )] live = 0 cell = board [ i ][ j ] for offset in offsets : x = i + offset [ 0 ] y = j + offset [ 1 ] if 0 <= x < rows and 0 <= y < cols : if board [ x ][ y ] == 1 : live += 1 # Any live cell with fewer than two live neighbors dies, as if caused by under-population. if live < 2 and cell == 1 : return 0 # Any live cell with two or three live neighbors lives on to the next generation. if ( live == 2 or live == 3 ) and cell == 1 : return 1 # Any live cell with more than three live neighbors dies, as if by over-population.. if live > 3 and cell == 1 : return 0 # Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. if cell == 0 and live == 3 : return 1 return cell class SolutionFollowUp1 : def gameOfLife ( self , board : List [ List [ int ]]) -> None : ''' Follow up: Could you solve it in-place? To do it in place: * need to save a intermediate state * later run another loop to turn it to 1, 0 End up Alive: 1: live 2: dead -> live End up Dead: 0: dead -1: live -> dead Time : O(mn) Space: O(1) ''' if len ( board ) == 0 : return rows = len ( board ) cols = len ( board [ 0 ]) if rows else 0 # update with intermediate state for i in range ( rows ): for j in range ( cols ): board [ i ][ j ] = self . getState ( board , i , j , rows , cols ) # process another loop to write 1, 0 based on state info for i in range ( rows ): for j in range ( cols ): if board [ i ][ j ] >= 1 : board [ i ][ j ] = 1 else : board [ i ][ j ] = 0 def getState ( self , board , i , j , rows , cols ): offsets = [( - 1 , - 1 ), ( - 1 , 0 ), ( - 1 , 1 ), ( 0 , - 1 ), ( 0 , 1 ), ( 1 , - 1 ), ( 1 , 0 ), ( 1 , 1 )] live = 0 cell = board [ i ][ j ] for offset in offsets : x = i + offset [ 0 ] y = j + offset [ 1 ] if 0 <= x < rows and 0 <= y < cols : if self . wasAlive ( board [ x ][ y ]): live += 1 # Any live cell with fewer than two live neighbors dies, as if caused by under-population. if live < 2 and cell == 1 : return - 1 # live -> dead # Any live cell with two or three live neighbors lives on to the next generation. if ( live == 2 or live == 3 ) and cell == 1 : return 1 # Any live cell with more than three live neighbors dies, as if by over-population.. if live > 3 and cell == 1 : return - 1 # live -> dead # Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. if cell == 0 and live == 3 : return 2 # dead -> live return cell def wasAlive ( self , i ): return i == 1 or i == - 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0289_game-of-life.html","loc":"https://tofucode.com/posts/leetcode_0289_game-of-life.html"},{"title":"Leetcode 0347. Top K Frequent Elements","text":"Question Link : https://leetcode.com/problems/top-k-frequent-elements/ Difficulty: Medium Question Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 <= nums.length <= 105 k is in the range [1, the number of unique elements in the array]. It is guaranteed that the answer is unique. Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size. Solution First get a number to count map, then get the count to frequency map, last is to take the top k from the frequency map Code ''' Leetcode 0347. Top K Frequent Elements Question Link : https://leetcode.com/problems/top-k-frequent-elements/ Solution Link : https://tofucode.com/posts/leetcode_0347_top-k-frequent-elements.html ''' class Solution : def topKFrequent ( self , nums : List [ int ], k : int ) -> List [ int ]: ''' freq: count -> number list Sort and take the top K Time : O(n) + O(m logm) m is the number of frequencies Space: O(n) ''' counts = {} # number -> count freq = {} # count -> number list for n in nums : counts [ n ] = counts . get ( n , 0 ) + 1 for n , v in counts . items (): freq [ v ] = freq . get ( v , []) + [ n ] # sorted by requency, take the highest ones first occur_list = sorted ( freq . keys (), reverse = True ) result = [] while len ( result ) < k : num_list = freq . get ( occur_list . pop ( 0 )) result += num_list return result [: k ] class SolutionImproved1 : def topKFrequent ( self , nums : List [ int ], k : int ) -> List [ int ]: ''' freq: count -> number list Skip sort: find the Max freq, take that, and then keep try -1 (like bucket sort) Time : O(n) Space: O(n) ''' counts = {} # number -> count freq = {} # count -> number list for n in nums : counts [ n ] = counts . get ( n , 0 ) + 1 for n , v in counts . items (): freq [ v ] = freq . get ( v , []) + [ n ] occur = max ( freq . keys ()) result = [] while len ( result ) < k : if occur in freq : num_list = freq . pop ( occur ) result += num_list occur -= 1 return result [: k ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0347_top-k-frequent-elements.html","loc":"https://tofucode.com/posts/leetcode_0347_top-k-frequent-elements.html"},{"title":"Leetcode 0682. Baseball Game","text":"Question Link : https://leetcode.com/problems/baseball-game/ Difficulty: Easy Question You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds' scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following: An integer x - Record a new score of x. \"+\" - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. \"D\" - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. \"C\" - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. Example 1: Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"] Output: 30 Explanation: \"5\" - Add 5 to the record, record is now [5]. \"2\" - Add 2 to the record, record is now [5, 2]. \"C\" - Invalidate and remove the previous score, record is now [5]. \"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10]. \"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15]. The total sum is 5 + 10 + 15 = 30. Example 2: Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"] Output: 27 Explanation: \"5\" - Add 5 to the record, record is now [5]. \"-2\" - Add -2 to the record, record is now [5, -2]. \"4\" - Add 4 to the record, record is now [5, -2, 4]. \"C\" - Invalidate and remove the previous score, record is now [5, -2]. \"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4]. \"9\" - Add 9 to the record, record is now [5, -2, -4, 9]. \"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5]. \"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14]. The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27. Example 3: Input: ops = [\"1\"] Output: 1 Constraints: 1 <= ops.length <= 1000 ops[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104]. For operation \"+\", there will always be at least two previous scores on the record. For operations \"C\" and \"D\", there will always be at least one previous score on the record. Solution Note that isdigit() does not check for negative numbers so either do a left strip first or add number in the else statement Code ''' Leetcode 0682. Baseball Game Question Link : https://leetcode.com/problems/baseball-game/ Solution Link : https://tofucode.com/posts/leetcode_0682_baseball-game.html ''' class Solution : def calPoints ( self , ops : List [ str ]) -> int : result = [] for x in ops : if x . lstrip ( \"-\" ) . isdigit (): result . append ( int ( x )) elif x == \"+\" : result . append ( result [ - 1 ] + result [ - 2 ]) elif x == \"D\" : result . append ( result [ - 1 ] * 2 ) elif x == \"C\" : result . pop () return sum ( result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0682_baseball-game.html","loc":"https://tofucode.com/posts/leetcode_0682_baseball-game.html"},{"title":"Leetcode 0344. Reverse String","text":"Question Link : https://leetcode.com/problems/reverse-string/ Difficulty: Easy Question Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. Example 1: Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] Example 2: Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] Constraints: 1 <= s.length <= 105 s[i] is a printable ascii character. Solution Use 2 pointers from start and end and swap Code ''' Leetcode 0344. Reverse String Question Link : https://leetcode.com/problems/reverse-string/ Solution Link : https://tofucode.com/posts/leetcode_0344_reverse-string.html ''' class Solution : def reverseString ( self , s : List [ str ]) -> None : \"\"\" Do not return anything, modify s in-place instead. \"\"\" if not s : return i = 0 j = len ( s ) - 1 while i < j : s [ i ], s [ j ] = s [ j ], s [ i ] i += 1 j -= 1","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0344_reverse-string.html","loc":"https://tofucode.com/posts/leetcode_0344_reverse-string.html"},{"title":"Leetcode 0074. Search a 2D Matrix","text":"Question Link : https://leetcode.com/problems/search-a-2d-matrix/ Difficulty: Medium Question Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: true Example 2: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output: false Constraints: m == matrix.length n == matrix[i].length 1 <= m, n <= 100 -104 <= matrix[i][j], target <= 104 Solution Use 2x binary search with a bisect_left, note that the first one for the row position we use everthing of the last column Code ''' Leetcode 0074. Search a 2D Matrix Question Link : https://leetcode.com/problems/search-a-2d-matrix/ Solution Link : https://tofucode.com/posts/leetcode_0074_search-a-2d-matrix.html ''' class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : ''' 2x Binary search Time : O(log m + log n) Space: O(1) ''' if not matrix or not matrix [ 0 ]: return False # use the right most col as we are doing bisect_left row = self . binarySearch ([ x [ - 1 ] for x in matrix ], target ) if row == len ( matrix ): return False col = self . binarySearch ( matrix [ row ], target ) if col == len ( matrix [ row ]): return False return matrix [ row ][ col ] == target def binarySearch ( self , nums , target ): ''' bisect_left: returns the left index that target would go ''' l = 0 r = len ( nums ) while l < r : mid = ( l + r ) // 2 if nums [ mid ] < target : l = mid + 1 else : r = mid return l","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0074_search-a-2d-matrix.html","loc":"https://tofucode.com/posts/leetcode_0074_search-a-2d-matrix.html"},{"title":"Leetcode 0991. Broken Calculator","text":"Question Link : https://leetcode.com/problems/broken-calculator/ Difficulty: Medium Question There is a broken calculator that has the integer startValue on its display initially. In one operation, you can: multiply the number on display by 2, or subtract 1 from the number on display. Given two integers startValue and target, return the minimum number of operations needed to display target on the calculator. Example 1: Input: startValue = 2, target = 3 Output: 2 Explanation: Use double operation and then decrement operation {2 -> 4 -> 3}. Example 2: Input: startValue = 5, target = 8 Output: 2 Explanation: Use decrement and then double {5 -> 4 -> 8}. Example 3: Input: startValue = 3, target = 10 Output: 3 Explanation: Use double, decrement and double {3 -> 6 -> 5 -> 10}. Constraints: 1 <= x, y <= 109 Solution Because there are only 2 operations, and given the odd even of a number, only 1 operation can be take if we work backwards Think in reverse since it will reveal the single correct path Code ''' Leetcode 0991. Broken Calculator Question Link : https://leetcode.com/problems/broken-calculator/ Solution Link : https://tofucode.com/posts/leetcode_0991_broken-calculator.html ''' class Solution : def brokenCalc ( self , startValue : int , target : int ) -> int : result = 0 while target > startValue : # // 2 when we can, otherwise +1 if target % 2 == 0 : target //= 2 else : target += 1 result += 1 # the remaining diff is made up with the -1 operation result += startValue - target return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0991_broken-calculator.html","loc":"https://tofucode.com/posts/leetcode_0991_broken-calculator.html"},{"title":"Leetcode 0946. Validate Stack Sequences","text":"Question Link : https://leetcode.com/problems/validate-stack-sequences/ Difficulty: Medium Question Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise. Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. Constraints: 1 <= pushed.length <= 1000 0 <= pushed[i] <= 1000 All the elements of pushed are unique. popped.length == pushed.length popped is a permutation of pushed. Solution Simulated keep pushing into a stack Whenever there a chance to pop based on popped, greedily pop that Code ''' Leetcode 0946. Validate Stack Sequences Question Link : https://leetcode.com/problems/validate-stack-sequences/ Solution Link : https://tofucode.com/posts/leetcode_0946_validate-stack-sequences.html ''' class Solution : def validateStackSequences ( self , pushed : List [ int ], popped : List [ int ]) -> bool : ''' Whenever there's one that can be popped, try to keep popping [1,2,3,4,5] [4,5,3,2,1] ''' idx = 0 # idx of popped stack = [] for x in pushed : stack . append ( x ) while stack and idx < len ( popped ) and stack [ - 1 ] == popped [ idx ]: stack . pop () idx += 1 # valid if went through all of popped return idx == len ( popped )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0946_validate-stack-sequences.html","loc":"https://tofucode.com/posts/leetcode_0946_validate-stack-sequences.html"},{"title":"Leetcode 1249. Minimum Remove to Make Valid Parentheses","text":"Question Link : https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/ Difficulty: Medium Question Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Example 1: Input: s = \"lee(t(c)o)de)\" Output: \"lee(t(c)o)de\" Explanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted. Example 2: Input: s = \"a)b(c)d\" Output: \"ab(c)d\" Example 3: Input: s = \"))((\" Output: \"\" Explanation: An empty string is also valid. Constraints: 1 <= s.length <= 105 s[i] is either'(' , ')', or lowercase English letter. Solution Use a stack to cancel out the parentheses, the ones that are left are the invalid ones We run another loop through the stack to strip out the invalid ones from the string Code ''' Leetcode 1249. Minimum Remove to Make Valid Parentheses Question Link : https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/ Solution Link : https://tofucode.com/posts/leetcode_1249_minimum-remove-to-make-valid-parentheses.html ''' class Solution : def minRemoveToMakeValid ( self , s : str ) -> str : ''' lee(t(c)o)de) stack: ( (( ( Nothing ) remove what ever is left Time : O(n) Space: O(n) ''' stack = [] for i in range ( len ( s )): c = s [ i ] if c == '(' or c == ')' : if stack : last = stack [ - 1 ] if last [ 1 ] == '(' and c == ')' : stack . pop () else : stack . append (( i , c )) else : stack . append (( i , c )) # remove the invalid ones result = list ( s ) for i , c in stack : result [ i ] = '' return '' . join ( result )","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_1249_minimum-remove-to-make-valid-parentheses.html","loc":"https://tofucode.com/posts/leetcode_1249_minimum-remove-to-make-valid-parentheses.html"},{"title":"Leetcode 0138. Copy List with Random Pointer","text":"Question Link : https://leetcode.com/problems/copy-list-with-random-pointer/ Difficulty: Medium Question A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list. Example 1: Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]] Output: [[7,null],[13,0],[11,4],[10,2],[1,0]] Example 2: Input: head = [[1,1],[2,1]] Output: [[1,1],[2,1]] Example 3: Input: head = [[3,null],[3,0],[3,null]] Output: [[3,null],[3,0],[3,null]] Constraints: 0 <= n <= 1000 -104 <= Node.val <= 104 Node.random is null or is pointing to some node in the linked list. Solution This is essentially a list iteration with a bit of extra work to deal with the random pointers with a hashmap Alternatively recursive solution can also be very clean Code ''' Leetcode 0138. Copy List with Random Pointer Question Link : https://leetcode.com/problems/copy-list-with-random-pointer/ Solution Link : https://tofucode.com/posts/leetcode_0138_copy-list-with-random-pointer.html ''' \"\"\" # Definition for a Node. class Node: def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None): self.val = int(x) self.next = next self.random = random \"\"\" class Solution : def copyRandomList ( self , head : 'Optional[Node]' ) -> 'Optional[Node]' : ''' list iteration with a hashmap old pointers -> new node Time : O(n) space: O(n) ''' pointers = {} # old pointers -> new node dummy = Node ( 0 ) p = head new_p = dummy while p : # get or create new node pointers [ p ] = pointers . get ( p , Node ( p . val )) # if there is random: get or create random r = p . random if r : pointers [ r ] = pointers . get ( r , Node ( r . val )) pointers [ p ] . random = pointers [ r ] # set up the new random node # move both pointers new_p . next = pointers [ p ] new_p = new_p . next p = p . next return dummy . next class SolutionAlternative1 : def copyRandomList ( self , head : 'Optional[Node]' ) -> 'Optional[Node]' : ''' list iteration with a hashmap old pointers -> new node Time : O(n) space: O(n) ''' self . pointers = {} # old pointer -> new node return self . copyRandom ( head ) def copyRandom ( self , head ): if head == None : return None if head in self . pointers : return self . pointers [ head ] # create a new node. node = Node ( head . val ) # save in hashmap self . pointers [ head ] = node # keep going to next and random via recursion node . next = self . copyRandom ( head . next ) node . random = self . copyRandom ( head . random ) return node","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0138_copy-list-with-random-pointer.html","loc":"https://tofucode.com/posts/leetcode_0138_copy-list-with-random-pointer.html"},{"title":"Leetcode 0061. Rotate List","text":"Question Link : https://leetcode.com/problems/rotate-list/ Difficulty: Medium Question Given the head of a linked list, rotate the list to the right by k places. Example 1: Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2: Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints: The number of nodes in the list is in the range [0, 500]. -100 <= Node.val <= 100 0 <= k <= 2 * 109 Solution Connect the tail to the head of the list to form a ring, this way the new problem becomes as to where to cut a new list We can k % count to find the actual offset needed to move since this is a ring Code ''' Leetcode 0061. Rotate List Question Link : https://leetcode.com/problems/rotate-list/ Solution Link : https://tofucode.com/posts/leetcode_0061_rotate-list.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def rotateRight ( self , head : Optional [ ListNode ], k : int ) -> Optional [ ListNode ]: ''' [1,2,3,4,5] T H count = 5 k = 2 offset = 2 # position calculated from start of the list head_position = 3 tail_position = 2 Time : O(n) Space: O(1) ''' if not head or not head . next : return head # keep a count of the size so we know where to move count = 1 # set up a ring p = head while p . next : count += 1 p = p . next p . next = head # find the new head and tail p = head offset = k % count head_position = count - offset # subtract to go from the back tail_position = head_position - 1 for i in range ( tail_position ): p = p . next # cut the ring result = p . next p . next = None return result","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0061_rotate-list.html","loc":"https://tofucode.com/posts/leetcode_0061_rotate-list.html"},{"title":"Leetcode 0141. Linked List Cycle","text":"Question Link : https://leetcode.com/problems/linked-list-cycle/ Difficulty: Easy Question Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). Example 2: Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 0th node. Example 3: Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. Constraints: The number of the nodes in the list is in the range [0, 104]. -105 <= Node.val <= 105 pos is -1 or a valid index in the linked-list. Follow up: Can you solve it using O(1) (i.e. constant) memory? Solution Use two pointer where the fast the twice the speed of the slow one If there is a cycle the fast one would catch up with the slow one Code ''' Leetcode 0141. Linked List Cycle Question Link : https://leetcode.com/problems/linked-list-cycle/ Solution Link : https://tofucode.com/posts/leetcode_0141_linked-list-cycle.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution : def hasCycle ( self , head : Optional [ ListNode ]) -> bool : ''' Time : O(n) Space: O(1) ''' fast = head slow = head while True : if fast is None or fast . next is None : return False fast = fast . next . next slow = slow . next if fast == slow : return True","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0141_linked-list-cycle.html","loc":"https://tofucode.com/posts/leetcode_0141_linked-list-cycle.html"},{"title":"Leetcode 0021. Merge Two Sorted Lists","text":"Question Link : https://leetcode.com/problems/merge-two-sorted-lists/ Difficulty: Easy Question You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Example 1: Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2: Input: list1 = [], list2 = [] Output: [] Example 3: Input: list1 = [], list2 = [0] Output: [0] Constraints: The number of nodes in both lists is in the range [0, 50]. -100 <= Node.val <= 100 Both list1 and list2 are sorted in non-decreasing order. Solution Use 2 pointers to trace both lists and form a new list starting at a dummy head pointer When one list ends, we can append the remains of the other list onto the combined list Code ''' Leetcode 0021. Merge Two Sorted Lists Question Link : https://leetcode.com/problems/merge-two-sorted-lists/ Solution Link : https://tofucode.com/posts/leetcode_0021_merge-two-sorted-lists.html ''' # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def mergeTwoLists ( self , list1 : Optional [ ListNode ], list2 : Optional [ ListNode ]) -> Optional [ ListNode ]: p1 = list1 p2 = list2 head = ListNode () x = head while p1 and p2 : if p1 . val < p2 . val : x . next = p1 p1 = p1 . next else : x . next = p2 p2 = p2 . next x = x . next if p1 : x . next = p1 else : x . next = p2 return head . next","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0021_merge-two-sorted-lists.html","loc":"https://tofucode.com/posts/leetcode_0021_merge-two-sorted-lists.html"},{"title":"Leetcode 0740. Delete and Earn","text":"Question Link : https://leetcode.com/problems/delete-and-earn/ Difficulty: Medium Question You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times: Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1. Return the maximum number of points you can earn by applying the above operation some number of times. Example 1: Input: nums = [3,4,2] Output: 6 Explanation: You can perform the following operations: - Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2]. - Delete 2 to earn 2 points. nums = []. You earn a total of 6 points. Example 2: Input: nums = [2,2,3,3,3,4] Output: 9 Explanation: You can perform the following operations: - Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3]. - Delete a 3 again to earn 3 points. nums = [3]. - Delete a 3 once more to earn 3 points. nums = []. You earn a total of 9 points. Constraints: 1 <= nums.length <= 2 * 104 1 <= nums[i] <= 104 Solution First observation is that for any number that we take, we'd want to tak all intances of that number, so we can reduce nums to a counting dict This then is the same problem as the house robber problem where dp is used to solve whether to take the adjacent number Code ''' Leetcode 0740. Delete and Earn Question Link : https://leetcode.com/problems/delete-and-earn/ Solution Link : https://tofucode.com/posts/leetcode_0740_delete-and-earn.html ''' class Solution : def deleteAndEarn ( self , nums : List [ int ]) -> int : ''' [2,2,3,3,3,4] map: num -> count 2: 2 3: 3 4: 1 dp[i] = max(taking last one, not taking last one + num * count) With n elements, and k as the max number Time : O(n + x) Space: O(n + x) ''' if not nums : return 0 counts = {} for num in nums : counts [ num ] = counts . get ( num , 0 ) + 1 # + 1 so the last key is included, and can direct access with dp[-1] dp = [ 0 ] * ( max ( counts . keys ()) + 1 ) for i in range ( 1 , len ( dp )): if i == 1 : dp [ i ] = max ( dp [ i - 1 ], i * counts . get ( i , 0 )) else : dp [ i ] = max ( dp [ i - 1 ], dp [ i - 2 ] + i * counts . get ( i , 0 )) return dp [ - 1 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0740_delete-and-earn.html","loc":"https://tofucode.com/posts/leetcode_0740_delete-and-earn.html"},{"title":"Leetcode 0799. Champagne Tower","text":"Question Link : https://leetcode.com/problems/champagne-tower/ Difficulty: Medium Question We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row. Each glass holds one cup of champagne. Then, some champagne is poured into the first glass at the top. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. (A glass at the bottom row has its excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full. After two cups of champagne are poured, the two glasses on the second row are half full. After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now. After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below. Now after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed.) Example 1: Input: poured = 1, query_row = 1, query_glass = 1 Output: 0.00000 Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty. Example 2: Input: poured = 2, query_row = 1, query_glass = 1 Output: 0.50000 Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange. Example 3: Input: poured = 100000009, query_row = 33, query_glass = 17 Output: 1.00000 Constraints: 0 <= poured <= 109 0 <= query_glass <= query_row < 100 Solution Just simulate how the pouring happens Here we create a tower with 100 rows just like the description This means we'd need to check if next row exists when pouring in the double for loop we can just query tower[query_row][query_glass] in the end For the pouring: think of all the glasses as left aligned in the 2d array, and the ones to pour into for [i][j] are [i+1][j] and [i+1][j+1] Code ''' Leetcode 0799. Champagne Tower Question Link : https://leetcode.com/problems/champagne-tower/ Solution Link : https://tofucode.com/posts/leetcode_0799_champagne-tower.html ''' class Solution : def champagneTower ( self , poured : int , query_row : int , query_glass : int ) -> float : ''' Use similation 2 0 0 0 0 0 1 .5 .5 0 0 0 for every row including the query_row: for every col: check if excess Time : O(1) Rows&#94;2 but Rows is fixed Space: O(1) ''' tower = [[ 0 ] * x for x in range ( 1 , 101 )] # first: len 1, last: len 100 tower [ 0 ][ 0 ] = poured for i in range ( query_row + 1 ): for j in range ( len ( tower [ i ])): # if there's a next row and current cup >= 1 if i + 1 < len ( tower ) and tower [ i ][ j ] >= 1 : half = ( tower [ i ][ j ] - 1 ) / 2.0 tower [ i + 1 ][ j ] += half tower [ i + 1 ][ j + 1 ] += half tower [ i ][ j ] = 1 return tower [ query_row ][ query_glass ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0799_champagne-tower.html","loc":"https://tofucode.com/posts/leetcode_0799_champagne-tower.html"},{"title":"Leetcode 0413. Arithmetic Slices","text":"Question Link : https://leetcode.com/problems/arithmetic-slices/ Difficulty: Medium Question An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences. Given an integer array nums, return the number of arithmetic subarrays of nums. A subarray is a contiguous subsequence of the array. Example 1: Input: nums = [1,2,3,4] Output: 3 Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself. Example 2: Input: nums = [1] Output: 0 Constraints: 1 <= nums.length <= 5000 -1000 <= nums[i] <= 1000 Solution At any time you have an subarray with >= 3 elements, and want to add the next number to the Sequence, you are extending the sequence * And add an amount of subarraies based on the current count. This hints at dp Code ''' Leetcode 0413. Arithmetic Slices Question Link : https://leetcode.com/problems/arithmetic-slices/ Solution Link : https://tofucode.com/posts/leetcode_0413_arithmetic-slices.html ''' class Solution : def numberOfArithmeticSlices ( self , nums : List [ int ]) -> int : ''' eg. 1,2,3,4,5 (sub) [1, 2, 3] at 3: have this with the first 3 elements (sub ) [1,2,3,4] at 4: 1 subarray for every subarray that starts at the current sequence and ends at 4 (dp[i-1]) (sub) [2, 3, 4] at 4: + 1 for the 3 element ending at 4 idx: 0 1 2 3 arr: [1,2,3,4] dp: [0 0 1 x] dp[i] = number of subarrays that end at index i x = (1 from dp[i-1]) + 1 dp[i] = dp[i-1] + 1 return sum(dp) ''' dp = [ 0 ] * len ( nums ) result = 0 for i in range ( 2 , len ( dp )): if self . endsAtArithSubarray ( nums , i ): dp [ i ] = dp [ i - 1 ] + 1 result += dp [ i ] return result def endsAtArithSubarray ( self , nums , i ): return nums [ i ] - nums [ i - 1 ] == nums [ i - 1 ] - nums [ i - 2 ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0413_arithmetic-slices.html","loc":"https://tofucode.com/posts/leetcode_0413_arithmetic-slices.html"},{"title":"Leetcode 0509. Fibonacci Number","text":"Question Link : https://leetcode.com/problems/fibonacci-number/ Difficulty: Easy Question The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n > 1. Given n, calculate F(n). Example 1: Input: n = 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: Input: n = 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: Input: n = 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Constraints: 0 <= n <= 30 Solution Use recursion and a cache. Code ''' Leetcode 0509. Fibonacci Number Question Link : https://leetcode.com/problems/fibonacci-number/ Solution Link : https://tofucode.com/posts/leetcode_0509_fibonacci-number.html ''' class Solution : # @functools.cache def fib ( self , n : int ) -> int : ''' base: F(0) = 0, F(1) = 1 func: F(n) = F(n - 1) + F(n - 2), for n > 1 eg. fib(4) fib(3) + fib(2) fib(2)+fib(1) Time: O(n) Space: O(n) ''' cache = { 0 : 0 , 1 : 1 } # n -> number return self . getFib ( cache , n ) def getFib ( self , cache , n ): if n in cache : return cache [ n ] cache [ n ] = self . getFib ( cache , n - 1 ) + self . getFib ( cache , n - 2 ) return cache [ n ]","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0509_fibonacci-number.html","loc":"https://tofucode.com/posts/leetcode_0509_fibonacci-number.html"},{"title":"Leetcode 0606. Construct String from Binary Tree","text":"Question Link : https://leetcode.com/problems/construct-string-from-binary-tree/ Difficulty: Easy Question Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: root = [1,2,3,4] Output: \"1(2(4))(3)\" Explanation: Originally, it needs to be \"1(2(4)())(3()())\", but you need to omit all the unnecessary empty parenthesis pairs. And it will be \"1(2(4))(3)\" Example 2: Input: root = [1,2,3,null,4] Output: \"1(2()(4))(3)\" Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. Constraints: The number of nodes in the tree is in the range [1, 104]. -1000 <= Node.val <= 1000 Solution Use recursion to build the string while considering different cases of when to omit the parenthesis. Code ''' Leetcode 0606. Construct String from Binary Tree Question Link : https://leetcode.com/problems/construct-string-from-binary-tree/ Solution Link : https://tofucode.com/posts/leetcode_0606_construct-string-from-binary-tree.html ''' # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def tree2str ( self , t : TreeNode ) -> str : ''' current + left + right 1 (2(4)()) (3()()) (4)() 3()() Time: O(n) Space: O(n) ''' if not t : return \"\" current = str ( t . val ) left = self . wrap ( self . tree2str ( t . left )) right = self . wrap ( self . tree2str ( t . right )) if not t . left and not t . right : return current elif not t . right : return current + left return current + left + right def wrap ( self , s ): return '(' + s + ')'","tags":"Leetcode","url":"https://tofucode.com/posts/leetcode_0606_construct-string-from-binary-tree.html","loc":"https://tofucode.com/posts/leetcode_0606_construct-string-from-binary-tree.html"}]};